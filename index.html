<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Diamond IQ — Chips + Targets + Coach Tools (JSON situations)</title>
<style>
  /* --- Base UI --- */
  body{margin:0;font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#f6f7fb;color:#1f2937}
  header{display:flex;align-items:center;gap:10px;padding:12px;background:#fff;border-bottom:1px solid #e5e7eb;position:sticky;top:0;z-index:10}
  header h1{margin:0 8px 0 0;font-size:16px;font-weight:800}
  select,button,input[type="number"],input[type="range"]{padding:6px 10px;font-weight:700;border:1px solid #e5e7eb;border-radius:8px;background:#fff}
  button{cursor:pointer}
  .btn-green{background:#16a34a;color:#fff;border-color:#15803d}
  .btn-orange{background:#f97316;color:#fff;border-color:#ea580c}
  .btn-slate{background:#fff;color:#334155;border:1px solid #cbd5e1}
  .btn-small{ padding:4px 8px; font-size:12px; line-height:1.2; }

  #startBtn:disabled {
    background:#f1f5f9;
    color:#94a3b8;
    border-color:#cbd5e1;
    cursor:not-allowed;
  }

  #resetBtn:disabled {
    background:#f1f5f9;
    color:#94a3b8;
    border-color:#cbd5e1;
    cursor:not-allowed;
  }

  /* Grey-out Check Positions button when disabled */
  #checkBtn:disabled {
    background:#e5e7eb !important;
    color:#94a3b8 !important;
    border-color:#cbd5e1 !important;
    cursor:not-allowed;
  }

  /* HUD badges */
  .hud{display:flex;gap:10px;margin-left:auto;align-items:center}
  .badge{
    display:inline-flex;align-items:center;gap:6px;
    padding:6px 10px;border-radius:999px;font-weight:900;font-size:13px;
    border:1px solid rgba(0,0,0,.08); box-shadow:0 1px 2px rgba(0,0,0,.06);
    background:#f8fafc;color:#0b1321;
  }
  .badge-score{background:#ecfeff;border-color:#a5f3fc}
  .badge-tries{background:#eef2ff;border-color:#c7d2fe}
  .badge .dot{width:10px;height:10px;border-radius:50%;box-shadow:inset 0 0 0 1px rgba(0,0,0,.08)}
  .dot-score{background:#06b6d4}
  .dot-tries{background:#6366f1}

  .app{display:grid;grid-template-columns:1fr 340px;gap:14px;padding:14px;max-width:min(1600px,96vw);margin:0 auto}
  .card{background:#fff;border:1px solid #e5e7eb;border-radius:10px;padding:10px}
  .sideCol{display:flex;flex-direction:column;gap:12px}

  /* Field + overlays */
  #wrap{position:relative}
  #fieldImg{display:block;width:100%;height:auto;border-radius:10px;background:#fff}
  .overlay{position:absolute;inset:0;pointer-events:none}
  #targetsLayer{pointer-events:none;z-index:2;} /* visual-only container (kept for layering) */
  #ballLayer{pointer-events:none;z-index:3;}

  /* Chips (direct children of #wrap) */
  :root { --chip-size: 36px; --chip-font: 14px; }
  .chip{
    position:absolute; transform:translate(-50%,-50%);
    width:var(--chip-size); height:var(--chip-size);
    border-radius:50%;
    display:flex; align-items:center; justify-content:center;
    font-weight:700; font-size:var(--chip-font); color:#fff; cursor:grab;
    box-shadow:0 1px 3px rgba(0,0,0,.35);
    user-select:none; touch-action:none; pointer-events:auto;
    z-index:1;
  }
  .chip:active{transform:translate(-50%,-50%) scale(1.045)}
  .chip.Battery{background:#f59e0b}
  .chip.Infield{background:#2563eb}
  .chip.Outfield{background:#dc2626}
  .chip.locked{cursor:not-allowed;opacity:.7}

  /* Targets (direct children of #wrap) */
  .tgt{
    position:absolute;transform:translate(-50%,-50%);
    border:3px solid rgba(255,255,255,.98);
    border-radius:999px;display:none;
    box-shadow:0 0 0 3px rgba(0,0,0,.28),0 0 0 10px rgba(255,255,255,.18);
    background:rgba(0,0,0,0.05);
    touch-action:none; z-index:2;
  }
  .tgt.draggable{cursor:grab;pointer-events:auto;}
  .tgt.good{background:rgba(22,163,74,.25)}
  .tgt.bad{background:rgba(239,68,68,.25)}
  .tgt .tgt-label{
    position:absolute;top:calc(100% + 6px);left:50%;transform:translateX(-50%);
    padding:2px 7px;border-radius:6px;font-weight:900;font-size:12px;
    color:#0b1321;background:rgba(255,255,255,.95);border:1px solid rgba(0,0,0,.2);
    white-space:nowrap;display:none
  }
  .tgt.show-label .tgt-label{display:block}
  .tgt.locked{cursor:not-allowed}

  /* Ball path + ball */
  #ballLayer svg{ width:100%; height:100%; display:block; }
  .ball{
    position:absolute; transform:translate(-50%,-50%);
    width:14px; height:14px; border-radius:50%;
    background:#fff;
    /* Solid black outline + a soft drop shadow */
    box-shadow:0 0 0 2px #000, 0 1px 3px rgba(0,0,0,.35);
    z-index:3; pointer-events:auto; cursor:grab; /* enable dragging in coach mode */
  }
  .ball.locked{ pointer-events:none; cursor:default; opacity:.95; }

  /* Runner (animated batter) + static base runners as black diamonds */
  .runner,
  .baseRunner{
    position:absolute;
    transform:translate(-50%,-50%) rotate(45deg); /* diamond */
    width:14px; height:14px;           /* scaled in JS */
    background:#0b0b0b;                /* black fill */
    box-shadow:
      0 0 0 2px #ffffff,               /* white outline */
      0 1px 2px rgba(0,0,0,.30);       /* soft drop */
    border-radius:4px;                  /* slight rounding like bases */
    z-index:3; pointer-events:none;
  }

  /* Label inside the diamond: counter-rotate to stay upright */
  .runner .rlabel,
  .baseRunner .rlabel{
    position:absolute; inset:0;
    display:flex; align-items:center; justify-content:center;
    transform:rotate(-45deg);
    color:#fff; font-weight:900; font-size:13px; /* bumped default font */
    text-shadow:0 1px 1px rgba(0,0,0,.35);
    user-select:none;
  }

  /* square black for moving existing runners */
  .movingRunner{
    width:14px; height:14px;
    background:#111;
    border-radius:2px; /* tiny rounding */
    box-shadow:0 0 0 2px #fff;  /* thin white outline for contrast */
  }

  /* Coach hit target marker (direct child of #wrap) */
  .hitTarget{
    position:absolute; transform:translate(-50%,-50%);
    width:18px; height:18px; border-radius:50%;
    background:#f97316; box-shadow:0 0 0 2px #7c2d12 inset, 0 0 0 2px #ffffff;
    cursor:grab; touch-action:none; pointer-events:auto;
    z-index:4;
  }
  .hitTarget:active{ transform:translate(-50%,-50%) scale(1.05); }

  /* Password modal */
  #pwModal{
    position:fixed; inset:0; background:rgba(0,0,0,.35);
    display:none; align-items:center; justify-content:center; z-index:1000;
  }
  #pwModal .box{
    background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:16px;min-width:280px;
    box-shadow:0 10px 30px rgba(0,0,0,.25);
  }

  /* Coach Tools subsections */
  .coachGrid{display:grid;gap:8px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .subsec{border:1px dashed #e5e7eb;border-radius:10px;padding:8px;margin-top:6px}
  .subsec > .title{font-weight:800;color:#334155;margin-bottom:6px;font-size:13px}
  .hint{font-size:12px;color:#64748b;font-weight:700}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
  .hidden{display:none!important}
</style>
</head>
<body>

<header>
  <h1>Diamond IQ</h1>
  <select id="sitSelect" aria-label="Situation"></select>
  <span id="runnersBadge" class="badge"><span style="background:#10b981"></span>Runners: <b><span id="runnersVal">—</span></b></span>
  <span id="outsHud" class="badge badge-tries" style="margin-left:2px">
    Outs: <b><span id="outsVal">0</span></b>
  </span>
  <button id="startBtn" class="btn-green">Start Situation</button>
  <button id="resetBtn" class="btn-orange">Reset</button>
  <button id="checkBtn" class="btn-green" disabled>Check Positions</button>

  <div id="hud" class="hud">
    <span id="scoreBadge" class="badge badge-score"><span class="dot dot-score"></span>Score: <b><span id="scoreVal">0</span>/9</b></span>
    <span id="triesBadge" class="badge badge-tries"><span class="dot dot-tries"></span>Tries remaining: <b><span id="triesVal">0</span></b></span>
  </div>

  <button id="coachBtn" class="btn-slate">Coach Tools</button>
</header>

<main class="app">
  <section class="card">
    <div id="wrap">
      <img id="fieldImg" src="baseballfield.png" alt="Baseball Field">
      <!-- visual-only layers kept for z-ordering -->
      <div id="targetsLayer" class="overlay"></div>
      <div id="ballLayer" class="overlay"></div>
      <!-- chips, rings, and hit marker are appended directly to #wrap -->
    </div>
  </section>

  <aside class="sideCol">
    <div class="card">
      <strong>How to play</strong>
      <ol style="margin:6px 0 0 1.2em">
        <li>Select a situation.</li>
        <li>Press <em>Start Situation</em> (3 tries).</li>
        <li>Drag the 9 chips into position.</li>
        <li>Press <em>Check Positions</em> (uses 1 try).</li>
      </ol>
      <div id="curSitDesc"  style="margin-top:6px;color:#475569;font-weight:600"></div>
    </div>

    <!-- Coach Tools (hidden until unlocked) -->
    <div id="coachCard" class="card hidden">
      <div class="coachGrid">
        <div class="row">
          <strong>Coach Tools</strong>
          <span id="coachStatus" class="mono" style="color:#64748b">locked</span>
          <span class="hint"> (drag chips, targets & hit marker while unlocked)</span>
        </div>

        <!-- Situation Builder -->
        <div class="subsec">
          <div class="title">Situation Builder</div>

          <div class="row">
            <label class="hint">Title:</label>
            <input id="newTitleInput" type="text" style="flex:1;min-width:120px"/>
          </div>
          <div class="row">
            <label class="hint">Description:</label>
            <input id="newDescInput" type="text" style="flex:2;min-width:200px"/>
          </div>

          <div class="row">
            <label class="hint">Outs:</label>
            <select id="outsSelScenario">
              <option value="0">0 outs</option>
              <option value="1">1 out</option>
              <option value="2">2 outs</option>
            </select>
          </div>

          <!-- Single refresh button -->
          <div class="row">
            <button id="newScenarioBtn"  class="btn-slate">➕ New Scenario</button>
            <button id="saveScenarioBtn" class="btn-slate">🔄 Refresh Situation</button>
            <span id="scenarioMsg" class="hint" style="margin-left:auto"></span>
          </div>
        </div>

        <!-- Runners on Base -->
        <div class="subsec">
          <div class="title">Runners on Base</div>
          <span class="hint" style="margin-left:auto">Updates HUD instantly</span>
          <div class="row" id="runnersRow">
            <label class="hint">Select base runners:</label>
            <label><input id="run1B" type="checkbox"> 1B</label>
            <label><input id="run2B" type="checkbox"> 2B</label>
            <label><input id="run3B" type="checkbox"> 3B</label>
          </div>
        </div>

        <!-- Targets & Tolerance -->
        <div class="subsec">
          <div class="title">Targets & Tolerance</div>
          <div class="row">
            <label class="hint">Target:</label>
            <select id="tolTargetSel"></select>
            <label class="hint">Tolerance:</label>
            <input id="tolNum" type="number" min="5" max="400" step="1" value="65"/>
            <input id="tolRange" type="range" min="5" max="400" step="1" value="65" style="flex:1"/>
          </div>
        </div>

        <!-- Ball Hit (single) -->
        <div class="subsec">
          <div class="title">Ball Hit</div>
          <div class="hint">Drag the <b>orange</b> marker to set the ball’s landing spot and set batter advance for this situation.</div>
            <button id="testHitBtn" class="btn-green" style="margin-left:auto;padding:4px 8px;font-size:12px;line-height:1.2">▶ Test</button>
          <div class="row">
            <label class="hint">Hit type:</label>
            <select id="hitTypeSel">
              <option value="line">Line drive</option>
              <option value="popup">Pop up</option>
              <option value="grounder">Grounder</option>
            </select>
            <select id="advanceSel" title="Batter bases to advance (1–3)">
              <option value="1">1 (Single)</option>
              <option value="2">2 (Double)</option>
              <option value="3">3 (Triple)</option>
            </select>
          </div>
        </div>

        <!-- Export -->
        <div class="subsec">
          <div class="title">Export</div>
          <div class="row">
            <button id="downloadCurrentBtn" class="btn-slate">⬇️ Download Current JSON</button>
            <button id="downloadAllBtn" class="btn-slate">⬇️ Download ALL JSON</button>
            <button id="copyAllBtn" class="btn-slate">📋 Copy ALL JSON</button>
          </div>
        </div>
      </div>
    </div>
  </aside>
</main>

<!-- Password modal -->
<div id="pwModal">
  <div class="box">
    <div style="font-weight:800;margin-bottom:8px">Enter Coach Password</div>
    <input id="pwInput" type="password" style="width:100%;padding:8px;border:1px solid #e5e7eb;border-radius:8px"/>
    <div id="pwMsg" style="color:#ef4444;margin-top:6px;min-height:1.2em"></div>
    <div class="row" style="justify-content:flex-end;margin-top:10px">
      <button id="pwOk" class="btn-green">Unlock</button>
      <button id="pwCancel" class="btn-slate">Cancel</button>
    </div>
  </div>
</div>

<script>
/* =======================
   Constants & pure helpers
   ======================= */
const IMG_W=3000, IMG_H=2487;
const DEFAULT_TOL=65;
const POS_IDS=['P','C','1B','2B','SS','3B','LF','CF','RF'];
const HOME_NATIVE = { x:1500, y:2147 };
const BASES_NATIVE = {
  home:{x:1501,y:2032}, first:{x:1903,y:1577}, second:{x:1465,y:1192}, third:{x:1101,y:1630}
};

const Fcopy = o => JSON.parse(JSON.stringify(o));
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const clampInt=(v,min,max)=>{v=Math.floor(Number(v)); if(Number.isNaN(v)) v=min; return clamp(v,min,max);};
const lerp=(a,b,t)=>a+(b-a)*t;
function quadBezier(p0,p1,p2,t){return {x:(1-t)*(1-t)*p0.x+2*(1-t)*t*p1.x+t*t*p2.x,y:(1-t)*(1-t)*p0.y+2*(1-t)*t*p1.y+t*t*p2.y};}

/* =======================
   App state (mutable)
   ======================= */
let SITUATIONS = [];
const SITUATIONS_FALLBACK = [];
let currentSituation = null;

let startsMap = {};
let hitsMap   = {};

let gameActive = false;
let remainingTries = 0;
const MAX_TRIES = 3;

let coachUnlocked = false;

let runnerEl = null;
let runnerAnimId = null;
let runnerLastBase = 'home';

let imgRect={width:1,height:1,left:0,top:0};
let CHIP_PX = 36;

let ballSvg=null, ballPath=null, ballEl=null, hitMarker=null;
let animReq=null;

let liveRunners = { first:false, second:false, third:false };
let _animSuppressedBases = new Set();

/* =======================
   DOM refs
   ======================= */
const img=document.getElementById('fieldImg');
const wrap=document.getElementById('wrap');
const targetsLayer=document.getElementById('targetsLayer');
const ballLayer=document.getElementById('ballLayer');

const sitSelect=document.getElementById('sitSelect');
const startBtn=document.getElementById('startBtn');
const resetBtn=document.getElementById('resetBtn');
const checkBtn=document.getElementById('checkBtn');
const scoreVal=document.getElementById('scoreVal');
const triesVal=document.getElementById('triesVal');
const curSitLabel=document.getElementById('curSitLabel');
const curSitDesc = document.getElementById('curSitDesc');

const coachBtn=document.getElementById('coachBtn');
const coachCard=document.getElementById('coachCard');
const coachStatus=document.getElementById('coachStatus');

const tolTargetSel=document.getElementById('tolTargetSel');
const tolNum=document.getElementById('tolNum');
const tolRange=document.getElementById('tolRange');

const hitTypeSel=document.getElementById('hitTypeSel');
const testHitBtn=document.getElementById('testHitBtn');
const advanceSel=document.getElementById('advanceSel');

const downloadCurrentBtn=document.getElementById('downloadCurrentBtn');
const downloadAllBtn=document.getElementById('downloadAllBtn');
const copyAllBtn=document.getElementById('copyAllBtn');

const pwModal=document.getElementById('pwModal');
const pwInput=document.getElementById('pwInput');
const pwOk=document.getElementById('pwOk');
const pwCancel=document.getElementById('pwCancel');
const pwMsg=document.getElementById('pwMsg');

const newTitleInput   = document.getElementById('newTitleInput');
const newDescInput    = document.getElementById('newDescInput');
const newScenarioBtn  = document.getElementById('newScenarioBtn');
const seedTargetsBtn  = document.getElementById('seedTargetsBtn');
const saveScenarioBtn = document.getElementById('saveScenarioBtn');
const scenarioMsg     = document.getElementById('scenarioMsg');

const outsValHud      = document.getElementById('outsVal');
const outsSelScenario = document.getElementById('outsSelScenario');
const runnersValHud   = document.getElementById('runnersVal');

const run1B = document.getElementById('run1B');
const run2B = document.getElementById('run2B');
const run3B = document.getElementById('run3B');

/* =======================
   Geometry & scaling (deduped)
   ======================= */
function unitToCss(native){ return { left:native.x*(imgRect.width/IMG_W), top:native.y*(imgRect.height/IMG_H) }; }
function cssToUnit(left,top){ return { x:left*(IMG_W/imgRect.width), y:top*(IMG_H/imgRect.height) }; }
function nativeToCssPoint(pt){ const css=unitToCss(pt); return { x:css.left, y:css.top }; }

function updateChipScale(){
  const base = Math.min(imgRect.width, imgRect.height);
  const size = clamp(Math.round(base * 0.056), 10, 36);
  CHIP_PX = size;
  const fz = clamp(Math.round(size * 0.42), 8, 14);
  wrap.style.setProperty('--chip-size', size + 'px');
  wrap.style.setProperty('--chip-font', fz + 'px');
}

function tolToCssDiameter(tol, allowTiny=false){
  const s = Math.min(imgRect.width / IMG_W, imgRect.height / IMG_H);
  const dCss = 2 * tol * s;
  if (allowTiny) return Math.max(6, Math.round(dCss));
  const minByChip = CHIP_PX * 1.8;
  return Math.round(Math.max(dCss, minByChip));
}

/* =======================
   ✨ Resize & Layout (single source of truth)
   ======================= */
function sizeOverlays(){
  if (!wrap) return;

  // 1) Snapshot new container rect
  const r = wrap.getBoundingClientRect();
  imgRect = { width:r.width, height:r.height, left:r.left, top:r.top };

  // 2) Scale chip size + fonts and scale markers (ball/runner/hit marker)
  updateChipScale();

  // 3) Re-position all chips from native coords
  POS_IDS.forEach(id => placeToken(id));

  // 4) Reposition + resize target rings from model
  if (currentSituation && currentSituation.targets){
    getAllRings().forEach(el => {
      const id  = el.dataset.id;
      const tgt = currentSituation.targets[id];
      if (!tgt) return;
      const css = unitToCss(tgt);
      el.style.left = css.left + 'px';
      el.style.top  = css.top  + 'px';
      const dpx = tolToCssDiameter(Number(tgt.tol) || DEFAULT_TOL, /*allowTiny*/ coachUnlocked);
      el.style.width  = dpx + 'px';
      el.style.height = dpx + 'px';
    });
  }

  // 5) Ball graphics: reset and rebuild SVG to match new viewBox
  if (animReq){ cancelAnimationFrame(animReq); animReq = null; }
  if (ballSvg) ballSvg.innerHTML = '';
  buildBallGraphics(); // also calls syncBallToHit()

  // 6) Reposition coach hit marker (if visible)
  if (hitMarker && currentSituation && currentSituation.hit){
    const css = unitToCss(currentSituation.hit);
    hitMarker.style.left = css.left + 'px';
    hitMarker.style.top  = css.top  + 'px';
  }

  // 7) Repaint static base-runner dots and snap animated runner to base
  renderBaseRunners();
  if (runnerEl && runnerEl.style.display !== 'none'){
    placeRunnerAtBase(runnerLastBase);
  }

  scaleMarkers();
}

/* schedule layout on next frame (avoid resize jank) */
let _resizeRaf = null;
function scheduleLayout(){
  if (_resizeRaf) cancelAnimationFrame(_resizeRaf);
  _resizeRaf = requestAnimationFrame(() => {
    _resizeRaf = null;
    sizeOverlays();
  });
}

/* observe #wrap — reacts to container changes, not just window resize */
let _wrapResizeObserver = null;
function observeWrap(){
  if (!window.ResizeObserver || !wrap) return;
  try{
    if (_wrapResizeObserver) _wrapResizeObserver.disconnect();
    _wrapResizeObserver = new ResizeObserver(() => scheduleLayout());
    _wrapResizeObserver.observe(wrap);
  }catch{}
}

/* global listeners */
window.addEventListener('resize', scheduleLayout);
window.addEventListener('orientationchange', scheduleLayout);

/* =======================
   🎯 Marker Scaling (single copy)
   Scales: .ball, .runner, .baseRunner, .hitTarget + SVG stroke width
   ======================= */
// Increased starting sizes; still scale down/up responsively
const BASE_MARKER_SIZES = {
  ball:40,
  runner:50,      // animated batter
  baseRunner:50,  // static on-base runners
  hit:40
};

function uiScale(){
  return Math.min(imgRect.width / IMG_W, imgRect.height / IMG_H);
}

function getBallStrokeWidth(){
  const s = uiScale();
  return clamp(Math.round(3 * s * 1.1), 2, 6);
}

function scaleMarkers(){
  const s = uiScale();
  const sizePx = (base, min=8, max=28) => clamp(Math.round(base * s), min, max);

  wrap.querySelectorAll('.runner .rlabel, .baseRunner .rlabel').forEach(el=>{
    const s = uiScale();
    el.style.fontSize = clamp(Math.round(13 * s * 1.05), 11, 18) + 'px';
  });

  // Ball
  if (ballEl){
    const d = sizePx(BASE_MARKER_SIZES.ball, 8, 26);
    ballEl.style.width  = d + 'px';
    ballEl.style.height = d + 'px';
    const outline = clamp(Math.round(2 * s), 1, 3);
    const drop    = clamp(Math.round(3 * s), 1, 4);
    ballEl.style.boxShadow = `0 0 0 ${outline}px #000, 0 1px ${drop}px rgba(0,0,0,.35)`;
  }

  // Animated batter
  if (runnerEl){
    const d = sizePx(BASE_MARKER_SIZES.runner, 8, 24);
    runnerEl.style.width  = d + 'px';
    runnerEl.style.height = d + 'px';
  }

  // Static + moving base runners
  if (wrap){
    wrap.querySelectorAll('.baseRunner, .movingRunner').forEach(el=>{
      const d = sizePx(BASE_MARKER_SIZES.baseRunner, 12, 48);
      el.style.width  = d + 'px';
      el.style.height = d + 'px';
    });
  }

  // Orange hit marker
  if (hitMarker){
    const d = sizePx(BASE_MARKER_SIZES.hit, 10, 28);
    hitMarker.style.width  = d + 'px';
    hitMarker.style.height = d + 'px';
  }
}

/* Optional: wrap animateHit to force scaling at animation start */
const _origAnimateHit = typeof animateHit === 'function' ? animateHit : null;
if (_origAnimateHit){
  window.animateHit = function(style){
    scaleMarkers();
    _origAnimateHit(style);
  };
}

/* =======================
   Chips (tokens) — REQUIRED (restores placeToken etc.)
   ======================= */

/* Default starting spots (native image coords) */
const DEFAULT_STARTS = {
  P:{x:1500,y:1631},  C:{x:1503,y:2147},
  '1B':{x:1917,y:1461}, '2B':{x:1824,y:1158}, SS:{x:1149,y:1158}, '3B':{x:1119,y:1450},
  LF:{x:742,y:790},  CF:{x:1466,y:482}, RF:{x:2273,y:772}
};

/* Token registry: id -> { el, pos:{x,y} } */
const tokens = new Map();

/* Remove any existing chips */
function clearChips(){
  if (!wrap) return;
  wrap.querySelectorAll('.chip').forEach(n=>n.remove());
  tokens.clear();
}

/* Build 9 draggable chips and place them at the current situation starts */
function buildTokens(){
  clearChips();

  const sKey = (currentSituation && currentSituation.key) || (SITUATIONS[0] && SITUATIONS[0].key);

  POS_IDS.forEach(id=>{
    const el=document.createElement('div');

    const group = (['P','C'].includes(id) ? 'Battery'
                 : (['1B','2B','SS','3B'].includes(id) ? 'Infield' : 'Outfield'));

    el.className = `chip ${group}`;
    el.textContent = id;
    wrap.appendChild(el);

    // pick a start from saved map (if any), else DEFAULT_STARTS
    const start = sKey ? getStartFor(sKey,id) : DEFAULT_STARTS[id];

    tokens.set(id, { el, pos: Fcopy(start) });
    placeToken(id);
    makeChipDraggable(el,id);
  });
}

/* Position a single chip according to its native pos -> CSS px */
function placeToken(id){
  const rec = tokens.get(id);
  if (!rec || !rec.pos || !rec.el) return;   // safe if buildTokens hasn't run yet
  const css = unitToCss(rec.pos);
  rec.el.style.left = css.left + 'px';
  rec.el.style.top  = css.top  + 'px';
}

/* Can the user drag chips right now? */
function canDrag(){
  return coachUnlocked || (gameActive && remainingTries > 0);
}

/* Basic pointer-driven dragging (writes native coords back to tokens map) */
function makeChipDraggable(el,id){
  let drag=null;

  el.addEventListener('pointerdown', e=>{
    if (!canDrag()) return;
    e.preventDefault();
    el.setPointerCapture(e.pointerId);

    const rec = tokens.get(id);
    const css = unitToCss(rec.pos);

    drag = { cx:e.clientX, cy:e.clientY, left:css.left, top:css.top };

    const onMove = (e2)=>{
      if (!drag) return;
      const left = drag.left + (e2.clientX - drag.cx);
      const top  = drag.top  + (e2.clientY - drag.cy);
      el.style.left = left + 'px';
      el.style.top  = top  + 'px';
      // save as native coords so layout rescales cleanly
      const native = cssToUnit(left, top);
      tokens.get(id).pos = { x: native.x, y: native.y };
    };

    const onUp = ()=>{
      window.removeEventListener('pointermove', onMove);
      drag = null;
    };

    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp, { once:true });
  });
}

/* =======================
   Targets (rings)
   ======================= */
function getRingEl(id){ return wrap.querySelector(`.tgt[data-id="${id}"]`); }
function getAllRings(){ return Array.from(wrap.querySelectorAll('.tgt')); }
function buildTargets(){
  getAllRings().forEach(n=>n.remove());
  const t=currentSituation.targets||{};
  Object.entries(t).forEach(([id,pt])=>{
    const ring=document.createElement('div');
    ring.className='tgt'; ring.dataset.id = id;
    const css=unitToCss(pt);
    ring.style.left=css.left+'px'; ring.style.top =css.top +'px';
    const label=document.createElement('span');
    label.className='tgt-label'; label.textContent=id;
    ring.appendChild(label);
    const tol = Number(pt.tol) || DEFAULT_TOL;
    const dpx = tolToCssDiameter(tol, coachUnlocked);
    ring.style.width  = dpx + 'px';
    ring.style.height = dpx + 'px';
    if (coachUnlocked){
      ring.style.display='block';
      ring.classList.add('show-label','draggable'); ring.classList.remove('locked');
      makeTargetDraggable(ring,id);
    } else {
      ring.style.display='none';
      ring.classList.remove('show-label','draggable'); ring.classList.add('locked');
    }
    wrap.appendChild(ring);
  });
}
function makeTargetDraggable(el,id){
  let drag=null;
  el.addEventListener('pointerdown',e=>{
    if(!coachUnlocked) return;
    e.preventDefault();
    el.setPointerCapture(e.pointerId);
    drag={cx:e.clientX,cy:e.clientY,left:parseFloat(el.style.left),top:parseFloat(el.style.top)};
    window.addEventListener('pointermove',onMove);
    window.addEventListener('pointerup',onUp,{once:true});
  });
  function onMove(e){
    if(!drag) return;
    const left=drag.left+(e.clientX-drag.cx);
    const top =drag.top +(e.clientY-drag.cy);
    el.style.left=left+'px'; el.style.top=top+'px';
    const pt=cssToUnit(left,top);
    setTargetFor(currentSituation.key,id,pt,currentSituation.targets?.[id]?.tol ?? DEFAULT_TOL);
  }
  function onUp(){ window.removeEventListener('pointermove',onMove); drag=null; }
}

/* =======================
   Runners & Outs
   ======================= */
function normalizeRunnersOn(obj){ const src=obj||{}; return { first:!!src.first, second:!!src.second, third:!!src.third }; }
function runnersStateToArray(r){ const out=[]; if(r.first)out.push('1B'); if(r.second)out.push('2B'); if(r.third)out.push('3B'); return out; }
function getRunnersFromCheckboxes(){ return { first:!!(run1B&&run1B.checked), second:!!(run2B&&run2B.checked), third:!!(run3B&&run3B.checked) }; }
function updateRunnersHudFromLive(){
  if (!runnersValHud) return;
  const arr = runnersStateToArray(normalizeRunnersOn(liveRunners));
  runnersValHud.textContent = arr.length ? arr.join(',') : '—';
}
function setRunnersOn(next,{quiet=true}={}){
  if (!currentSituation) return;
  const newState = next ? normalizeRunnersOn(next) : normalizeRunnersOn(getRunnersFromCheckboxes());
  currentSituation.runnersOn = { ...newState };
  if (!gameActive) liveRunners = { ...newState };
  if (run1B&&run2B&&run3B){ run1B.checked=!!newState.first; run2B.checked=!!newState.second; run3B.checked=!!newState.third; }
  updateRunnersHudFromLive();
  renderBaseRunners();
  scaleMarkers();
  if (!quiet && scenarioMsg){ scenarioMsg.textContent='Runners updated'; setTimeout(()=>scenarioMsg.textContent='',900); }
}
function setOuts(value,{quiet=true}={}){
  if (!currentSituation) return;
  const v = clampInt(value,0,2);
  currentSituation.outs = v;
  if (outsValHud) outsValHud.textContent = String(v);
  if (outsSelScenario && outsSelScenario.value !== String(v)) outsSelScenario.value = String(v);
  if (!quiet && scenarioMsg){ scenarioMsg.textContent='Outs updated'; setTimeout(()=>{scenarioMsg.textContent='';},900); }
}
/* draw/remove base runners  */
function renderBaseRunners(state, exclude = new Set()){
  // Merge explicit excludes + global suppression
  const blocked = new Set([...exclude, ..._animSuppressedBases]);

  // Only remove static dots; keep animated movers alive
  if (wrap) wrap.querySelectorAll('.baseRunner:not(.movingRunner)').forEach(n=>n.remove());

  const r = state ? normalizeRunnersOn(state) : normalizeRunnersOn(liveRunners);

  const add=(baseName)=>{
    if (blocked.has(baseName)) return; // skip bases we’re animating
    const pos=BASES_NATIVE[baseName]; if(!pos||!wrap) return;
    const m=document.createElement('div');
    m.className='baseRunner';
    m.dataset.base = baseName;
    const css=unitToCss(pos);
    m.style.left=css.left+'px';
    m.style.top =css.top +'px';
    wrap.appendChild(m);
  };

  if (r.first)  add('first');
  if (r.second) add('second');
  if (r.third)  add('third');

  if (typeof scaleMarkers === 'function') scaleMarkers();
}
function advanceRunnersState(state,bases){
  bases = clampInt(bases,0,3);
  const r = normalizeRunnersOn(state);
  if (bases<=0) return {...r};
  const occ=[]; if(r.first)occ.push(1); if(r.second)occ.push(2); if(r.third)occ.push(3);
  occ.sort((a,b)=>b-a);
  const dest={1:false,2:false,3:false};
  for(const b of occ){ const nb=b+bases; if (nb<4) dest[nb]=true; }
  return { first:!!dest[1], second:!!dest[2], third:!!dest[3] };
}

/* =======================
   Ball & Hit
   ======================= */
function buildBallGraphics(){
  ballLayer.innerHTML = '';
  const svgNS='http://www.w3.org/2000/svg';
  const svg=document.createElementNS(svgNS,'svg');
  svg.setAttribute('viewBox',`0 0 ${imgRect.width} ${imgRect.height}`);
  ballSvg=svg; ballLayer.appendChild(svg);
  if (!ballEl){
    ballEl=document.createElement('div');
    ballEl.className='ball'; ballEl.style.display='none';
    wrap.appendChild(ballEl);
    makeBallDraggable(ballEl);
  }
  syncBallToHit();
}
function ensureDefaultHit(){
  if (!currentSituation) return;
  if (!currentSituation.hit || isNaN(currentSituation.hit.x) || isNaN(currentSituation.hit.y)){
    currentSituation.hit = { x:1500, y:900 };
  }
}
function syncBallToHit(){
  if (!ballEl || !currentSituation) return;
  ensureDefaultHit();
  const css=unitToCss(currentSituation.hit);
  ballEl.style.left=css.left+'px'; ballEl.style.top=css.top+'px';
  ballEl.style.display = (coachUnlocked || gameActive) ? 'block' : 'none';
  ballEl.classList.toggle('locked', !coachUnlocked);
}
function makeBallDraggable(el){
  let drag=null;
  el.addEventListener('pointerdown',e=>{
    if (!coachUnlocked) return;
    e.preventDefault(); el.setPointerCapture(e.pointerId);
    drag={cx:e.clientX,cy:e.clientY,left:parseFloat(el.style.left)||0, top:parseFloat(el.style.top)||0};
    window.addEventListener('pointermove',onMove);
    window.addEventListener('pointerup',onUp,{once:true});
  });
  function onMove(e){
    if(!drag) return;
    const left=drag.left+(e.clientX-drag.cx), top=drag.top+(e.clientY-drag.cy);
    el.style.left=left+'px'; el.style.top=top+'px';
    const pt=cssToUnit(left,top);
    if(currentSituation) currentSituation.hit={ x:Math.round(pt.x), y:Math.round(pt.y) };
  }
  function onUp(){ window.removeEventListener('pointermove',onMove); drag=null; }
}
function placeHitMarker(){
  if (hitMarker){ hitMarker.remove(); hitMarker=null; }
  if (!coachUnlocked) return;
  ensureDefaultHit();
  const css=unitToCss(currentSituation.hit);
  hitMarker=document.createElement('div');
  hitMarker.className='hitTarget'; hitMarker.style.left=css.left+'px'; hitMarker.style.top=css.top+'px';
  wrap.appendChild(hitMarker); makeHitMarkerDraggable(hitMarker);
}
function makeHitMarkerDraggable(el){
  let drag=null;
  el.addEventListener('pointerdown',e=>{
    if (!coachUnlocked) return;
    e.preventDefault(); el.setPointerCapture(e.pointerId);
    drag={cx:e.clientX,cy:e.clientY,left:parseFloat(el.style.left),top:parseFloat(el.style.top)};
    window.addEventListener('pointermove',onMove);
    window.addEventListener('pointerup',onUp,{once:true});
  });
  function onMove(e){
    if(!drag) return;
    const left=drag.left+(e.clientX-drag.cx), top=drag.top+(e.clientY-drag.cy);
    el.style.left=left+'px'; el.style.top=top+'px';
    const pt=cssToUnit(left,top);
    currentSituation.hit={ x:Math.round(pt.x), y:Math.round(pt.y) };
    syncBallToHit();
  }
  function onUp(){ window.removeEventListener('pointermove',onMove); drag=null; }
}
function mapHitTypeToAdvance(hitType){
  switch((hitType||'').toLowerCase()){
    case 'grounder': return 1;
    case 'line':     return 2;
    case 'popup':    return 0;
    default:         return 1;
  }
}
function animateHit(style){
  const sit=currentSituation; if(!sit) return;
  ensureDefaultHit(); style = style || sit.hitType || 'line';
  if (ballSvg) ballSvg.innerHTML='';
  const startCss=nativeToCssPoint(HOME_NATIVE), endCss=nativeToCssPoint(sit.hit);
  const svgNS='http://www.w3.org/2000/svg';
  if (style==='line' || style==='grounder'){
    ballPath=document.createElementNS(svgNS,'line');
    Object.entries({x1:startCss.x,y1:startCss.y,x2:endCss.x,y2:endCss.y}).forEach(([k,v])=>ballPath.setAttribute(k,v));
    ballPath.setAttribute('stroke','#0ea5e9');
    ballPath.setAttribute('stroke-width', String(getBallStrokeWidth()));
    if (style==='grounder') ballPath.setAttribute('stroke-dasharray','8 8');
    ballSvg.appendChild(ballPath);
  } else {
    const midX=(startCss.x+endCss.x)/2, midY=(startCss.y+endCss.y)/2;
    const curveUp = Math.max(90, Math.hypot(endCss.x - startCss.x, endCss.y - startCss.y) * 0.36); // higher arc
    const ctrl={x:midX,y:midY-curveUp};
    const d=`M ${startCss.x},${startCss.y} Q ${ctrl.x},${ctrl.y} ${endCss.x},${endCss.y}`;
    ballPath=document.createElementNS(svgNS,'path');
    ballPath.setAttribute('d',d); ballPath.setAttribute('fill','none');
    ballPath.setAttribute('stroke','#0ea5e9');
    ballPath.setAttribute('stroke-width', String(getBallStrokeWidth()));
    ballSvg.appendChild(ballPath);
  }
  ballEl.style.left=`${startCss.x}px`; ballEl.style.top=`${startCss.y}px`; ballEl.style.display='block';
  const dist=Math.hypot(endCss.x-startCss.x,endCss.y-startCss.y);
  const duration = clamp(1200 + dist * 0.90, 1500, 3200); // slower + smoother
  let t0=performance.now(); if (animReq) cancelAnimationFrame(animReq);
  const p0={x:startCss.x,y:startCss.y}, p2={x:endCss.x,y:endCss.y};
  const popupCtrl=(()=>{const midX=(startCss.x+endCss.x)/2, midY=(startCss.y+endCss.y)/2;
    const curveUp = Math.max(90, Math.hypot(endCss.x - startCss.x, endCss.y - startCss.y) * 0.36); // higher arc
    return {x:midX,y:midY-curveUp};})();
  function step(now){
    const t=clamp((now-t0)/duration,0,1);
    const pos=(style==='popup')?quadBezier(p0,popupCtrl,p2,t):{x:lerp(p0.x,p2.x,t),y:lerp(p0.y,p2.y,t)};
    ballEl.style.left=`${pos.x}px`; ballEl.style.top=`${pos.y}px`;
    if (t<1) animReq=requestAnimationFrame(step);
    else { if (ballSvg) ballSvg.innerHTML=''; animReq=null; if (ballEl) ballEl.style.display='block'; }
  }
  animReq=requestAnimationFrame(step);
}
function ensureRunner(){
  if (!runnerEl){
    runnerEl = document.createElement('div');
    runnerEl.className = 'runner';
    runnerEl.style.display = 'none';

    // Add label element inside (counter-rotated via CSS)
    const lab = document.createElement('span');
    lab.className = 'rlabel';
    lab.textContent = 'B'; // Batter when moving
    runnerEl.appendChild(lab);

    wrap.appendChild(runnerEl);
  }
}
function placeRunnerAtBase(base){
  ensureRunner();
  runnerLastBase = base;

  const pt = BASES_NATIVE[base] || BASES_NATIVE.home;
  const css = unitToCss(pt);

  runnerEl.style.left = css.left + 'px';
  runnerEl.style.top  = css.top  + 'px';
  runnerEl.style.display = 'block';

  // Label B1/B2/B3 on base; hide on home
  const lab = runnerEl.querySelector('.rlabel');
  if (lab){
    lab.textContent =
      base === 'first'  ? 'B1' :
      base === 'second' ? 'B2' :
      base === 'third'  ? 'B3' : 'B';
  }
}
function hideRunner(){ if (runnerEl) runnerEl.style.display='none'; runnerLastBase='home'; }
function animateBatterAdvance(basesAdvanced, onDone){
  ensureRunner();
  if (runnerAnimId){ cancelAnimationFrame(runnerAnimId); runnerAnimId=null; }

  // Normalize + clamp
  basesAdvanced = clampInt(basesAdvanced, 0, 4);

  // Path of bases (index is "bases moved")
  const path=['home','first','second','third','home'];
  const legs=path.slice(0, Math.min(4,basesAdvanced)+1);

  // No advance: hide/snap on home and finish
  if (basesAdvanced<=0){
    placeRunnerAtBase('home');
    runnerEl.style.display='none';
    runnerLastBase='home';
    if (typeof onDone === 'function') onDone('home');
    return;
  }

  placeRunnerAtBase(legs[0]);
  let legIdx=0;

  const runLeg=()=>{
    if (legIdx>=legs.length-1){
      // Finished
      const destBase = legs[legs.length-1];      // first/second/third/home
      runnerLastBase = destBase;
      if (typeof onDone === 'function') onDone(destBase);
      return;
    }
    const fromName=legs[legIdx], toName=legs[legIdx+1];
    const fromCss=nativeToCssPoint(BASES_NATIVE[fromName]);
    const toCss  =nativeToCssPoint(BASES_NATIVE[toName]);
    const dist=Math.hypot(toCss.x-fromCss.x,toCss.y-fromCss.y);

    // Slower, to match your GIF feel
    const duration=clamp(700+dist*0.55, 800, 1600);

    let t0=performance.now();
    const step=(now)=>{
      const t=clamp((now-t0)/duration,0,1);
      const e=1-Math.pow(1-t,3);
      runnerEl.style.left=lerp(fromCss.x,toCss.x,e)+'px';
      runnerEl.style.top =lerp(fromCss.y,toCss.y,e)+'px';
      runnerEl.style.display='block';
      if (t<1) runnerAnimId=requestAnimationFrame(step);
      else { runnerLastBase=toName; legIdx++; runLeg(); }
    };
    runnerAnimId=requestAnimationFrame(step);
  };
  runLeg();
}

const BASE_ORDER = ['first', 'second', 'third', 'home'];

/**
 * Animate a runner that starts on a base (first/second/third) forward `advance` bases.
 * Returns a Promise that resolves when this runner's animation finishes.
 */
function animateExistingRunnerFrom(baseName, advance){
  return new Promise(resolve=>{
    // Nothing to do
    const startIdx = BASE_ORDER.indexOf(baseName);
    if (startIdx < 0 || advance <= 0) return resolve();

    // Remove the static dot for this base so we don't double-draw
    const toRemove = wrap.querySelector(`.baseRunner[data-base="${baseName}"]`);
    if (toRemove) toRemove.remove();

    // Create a moving element (reuse .baseRunner styling)
    const mover = document.createElement('div');
    mover.className = 'movingRunner';
    mover.style.position = 'absolute';
    mover.style.transform = 'translate(-50%,-50%)';
    wrap.appendChild(mover);

    // Let it scale like other markers
    if (typeof scaleMarkers === 'function') scaleMarkers();

    // Build its path across legs
    const destIdx = Math.min(startIdx + advance, BASE_ORDER.length - 1); // up to "home"
    const legs = BASE_ORDER.slice(startIdx, destIdx + 1); // e.g. ['first','second','third'] (or 'home')

    // Place at starting base
    const startCss = nativeToCssPoint(BASES_NATIVE[legs[0]]);
    mover.style.left = startCss.x + 'px';
    mover.style.top  = startCss.y + 'px';
    mover.style.display = 'block';

    let leg = 0, animId=null;

    const runLeg = ()=>{
      if (leg >= legs.length - 1){
        // If finished on "home", remove; otherwise we’ll later redraw statically via renderBaseRunners
        if (mover && mover.parentNode) mover.remove();
        return resolve();
      }
      const fromName = legs[leg];
      const toName   = legs[leg + 1];
      const fromCss  = nativeToCssPoint(BASES_NATIVE[fromName]);
      const toCss    = nativeToCssPoint(BASES_NATIVE[toName]);
      const dist     = Math.hypot(toCss.x - fromCss.x, toCss.y - fromCss.y);

      // Match your slower, smooth feel
      const duration = clamp(700 + dist * 0.55, 800, 1600);

      let t0 = performance.now();
      const step = (now)=>{
        const t = clamp((now - t0) / duration, 0, 1);
        const e = 1 - Math.pow(1 - t, 3); // smooth ease-out
        mover.style.left = lerp(fromCss.x, toCss.x, e) + 'px';
        mover.style.top  = lerp(fromCss.y, toCss.y, e) + 'px';
        if (t < 1) animId = requestAnimationFrame(step);
        else { leg++; runLeg(); }
      };
      animId = requestAnimationFrame(step);
    };

    runLeg();
  });
}

/**
 * Animate all existing runners (first/second/third) forward `advance` bases in parallel.
 * Calls onDone(finalState) when all have finished (finalState excludes batter).
 */
function animateExistingRunnersAdvance(advance, onDone){
  const start = normalizeRunnersOn(liveRunners);

  const movers = [];
  if (start.first)  movers.push('first');
  if (start.second) movers.push('second');
  if (start.third)  movers.push('third');

  if (movers.length === 0){
    const finalState = advanceRunnersState(start, advance);
    if (typeof onDone === 'function') onDone(finalState);
    return;
  }

  // Suppress the starting bases for movers (no static dot while they run)
  movers.forEach(b => _animSuppressedBases.add(b));

  // Initial paint while suppressed (so their start dots disappear immediately)
  renderBaseRunners(start);

  // Animate all movers
  Promise.all(movers.map(b => animateExistingRunnerFrom(b, advance)))
    .then(()=>{
      // Compute final state and clear suppression
      const finalState = advanceRunnersState(start, advance);
      movers.forEach(b => _animSuppressedBases.delete(b));

      // Repaint final positions (no ghosts)
      renderBaseRunners(finalState);

      if (typeof onDone === 'function') onDone(finalState);
    });
}

/* =======================
   Coach tools & visibility
   ======================= */
const CALIB_PASSWORD='coach';
function applyCoachVisibility(){
  coachCard.classList.toggle('hidden', !coachUnlocked);
  getAllRings().forEach(el=> el.style.display = coachUnlocked ? 'block' : 'none');
  if (coachUnlocked){ if (!hitMarker) placeHitMarker(); } else { if (hitMarker){ hitMarker.remove(); hitMarker=null; } }
  syncBallToHit();
}
function setChipsLocked(locked){ tokens.forEach(({el})=> el.classList.toggle('locked', locked && !coachUnlocked)); }
function updateHud(scoreCount){ scoreVal.textContent=String(scoreCount ?? 0); triesVal.textContent=coachUnlocked ? '∞' : String(remainingTries); }
function setCoachMode(enabled){
  coachUnlocked = !!enabled;
  coachStatus.textContent = coachUnlocked ? 'unlocked' : 'locked';
  coachStatus.style.color = coachUnlocked ? '#16a34a' : '#64748b';
  if (coachUnlocked) setChipsLocked(false); else setChipsLocked(!gameActive || remainingTries===0);
  buildTargets(); applyCoachVisibility(); updateHud(Number(scoreVal.textContent)||0);
}
function openPwModal(){ pwModal.style.display='flex'; pwMsg.textContent=''; pwInput.value=''; pwInput.focus(); }
function closePwModal(){ pwModal.style.display='none'; }
function tryUnlock(){ if(pwInput.value===CALIB_PASSWORD){ closePwModal(); setCoachMode(true); } else { pwMsg.textContent='Incorrect password.'; } }

/* =======================
   Situations I/O & helpers
   ======================= */
const STORAGE_STARTS='bb_iq_starts_v2';
const STORAGE_HITS  ='bb_iq_hits_v1';

function defaultStartsMap(){
  const map = {};
  (SITUATIONS||[]).forEach(s=>{ map[s.key] = s.starts ? Fcopy(s.starts) : Fcopy(DEFAULT_STARTS); });
  return map;
}
function loadStarts(){
  startsMap = defaultStartsMap();
  try{
    const raw = localStorage.getItem(STORAGE_STARTS); if (!raw) return;
    const saved = JSON.parse(raw);
    Object.keys(saved||{}).forEach(k=>{
      const dst = startsMap[k] || (startsMap[k]=Fcopy(DEFAULT_STARTS));
      POS_IDS.forEach(id=>{
        const v = saved[k]?.[id];
        if (v && !isNaN(v.x) && !isNaN(v.y)) dst[id] = { x:Math.round(Number(v.x)), y:Math.round(Number(v.y)) };
      });
    });
  }catch(e){ console.warn('[Starts] localStorage merge error:', e); }
}
function saveStarts(){ try{ localStorage.setItem(STORAGE_STARTS, JSON.stringify(startsMap)); }catch{} }
function getStartFor(sKey,id){ const s = startsMap[sKey] || DEFAULT_STARTS; return s[id] || DEFAULT_STARTS[id]; }
function setStartFor(sKey,id,pt){ if(!startsMap[sKey]) startsMap[sKey]=Fcopy(DEFAULT_STARTS); startsMap[sKey][id]={x:pt.x,y:pt.y}; }

function loadHits(){ try{ const raw=localStorage.getItem(STORAGE_HITS); hitsMap = raw ? JSON.parse(raw) : {}; }catch{ hitsMap={}; } }
function saveHits(){ try{ localStorage.setItem(STORAGE_HITS, JSON.stringify(hitsMap)); }catch{} }
function getHitSaved(sKey){ const v=hitsMap[sKey]; return (v && !isNaN(v.x) && !isNaN(v.y)) ? { x:Math.round(v.x), y:Math.round(v.y) } : null; }
function setHitSaved(sKey, pt){ if (!pt || isNaN(pt.x) || isNaN(pt.y)) return; hitsMap[sKey] = { x:Math.round(pt.x), y:Math.round(pt.y) }; }

function setTargetFor(sKey,id,pt,tol=DEFAULT_TOL){
  const s = SITUATIONS.find(x=>x.key===sKey); if(!s) return;
  if(!s.targets) s.targets={};
  const prevTol = s.targets[id]?.tol;
  s.targets[id] = { x:Math.round(pt.x), y:Math.round(pt.y), tol:Number(tol||prevTol||DEFAULT_TOL) };
}
function getTargetFor(sKey,id){
  const s = SITUATIONS.find(x=>x.key===sKey);
  return (s && s.targets && s.targets[id]) ? s.targets[id] : null;
}

function normPoint(px){
  if (!px || isNaN(px.x) || isNaN(px.y)) return null;
  let x=Number(px.x), y=Number(px.y);
  if (x>=0 && x<=1 && y>=0 && y<=1){ x=Math.round(x*IMG_W); y=Math.round(y*IMG_H); } else { x=Math.round(x); y=Math.round(y); }
  return {x,y};
}
function normalizeStarts(obj){
  if (!obj || typeof obj !== 'object') return null;
  const out={}; POS_IDS.forEach(id=>{ if (obj[id]){ const p=normPoint(obj[id]); if(p) out[id]=p; }});
  return Object.keys(out).length ? out : null;
}
function normalizeTargets(obj){
  const out={}; if (!obj || typeof obj !== 'object') return out;
  POS_IDS.forEach(id=>{ const raw=obj[id]; if(raw){ const p=normPoint(raw); if(p){ out[id]={ x:p.x, y:p.y, tol:Number(raw.tol)||DEFAULT_TOL }; } } });
  return out;
}
function normalizeHit(obj){ if (!obj || typeof obj !== 'object') return {}; const p=normPoint(obj); return p ? {x:p.x,y:p.y} : {}; }
function mapHitType(v){ const t=String(v||'').toLowerCase(); return (t==='line'||t==='popup'||t==='grounder')?t:'line'; }

async function loadSituationsFromJson(){
  try{
    const res = await fetch('./situations.json?ts=' + Date.now(), { cache:'no-store' });
    if(!res.ok) throw new Error('HTTP '+res.status);
    const arr = await res.json();
    if (!Array.isArray(arr)) throw new Error('situations.json must be an array');
    SITUATIONS = arr.map((s,i)=>{
      const safe={...s};
      safe.key   = String(s.key||'').trim() || `S${i+1}`;
      safe.title = s.title || safe.key;
      safe.desc  = s.desc  || '';
      safe.targets = normalizeTargets(s.targets)||{};
      safe.starts  = normalizeStarts(s.starts);
      safe.hit     = normalizeHit(s.hit);
      safe.hitType = mapHitType(s.hitType);
      const advJSON = (typeof s.batterAdvance==='number') ? clampInt(s.batterAdvance,0,4) : null;
      safe.batterAdvance = (advJSON!=null) ? advJSON : mapHitTypeToAdvance(safe.hitType);
      safe.outs = clampInt((s.outs ?? 0), 0, 2);
      safe.runnersOn = normalizeRunnersOn(s.runnersOn);
      return safe;
    });
    console.info('[Situations] Loaded', SITUATIONS.length);
  }catch(err){
    console.warn('[Situations] JSON load failed, using fallback:', err?.message||err);
    SITUATIONS = (SITUATIONS_FALLBACK||[]).map((s,i)=>({
      ...s, key:String(s.key||'').trim() || `S${i+1}`, targets:normalizeTargets(s.targets)||{},
      starts:normalizeStarts(s.starts), hit:normalizeHit(s.hit), hitType:'line',
      outs:clampInt((s.outs ?? 0),0,2), runnersOn:normalizeRunnersOn(s.runnersOn)
    }));
  }
}

/* =======================
   Situation lifecycle
   ======================= */
function syncScenarioInputsFromCurrent(){
  if (!currentSituation) return;

  if (newTitleInput) newTitleInput.value = currentSituation.title || currentSituation.key || '';
  if (newDescInput)  newDescInput.value  = currentSituation.desc  || '';

  // also mirror into the left panel
  if (curSitLabel) curSitLabel.textContent = currentSituation.title || '';
  if (curSitDesc)  curSitDesc.textContent  = currentSituation.desc  || '';

  const o = clampInt((currentSituation.outs ?? 0), 0, 2);
  setOuts(o, {quiet:true});
}
function startsToTargets(starts, tol=DEFAULT_TOL){
  const out={}; POS_IDS.forEach(id=>{ const p=starts[id]; if(p) out[id]={ x:Math.round(p.x), y:Math.round(p.y), tol:Number(tol)||DEFAULT_TOL }; });
  return out;
}
function seedTargetsFromStarts(){
  if (!currentSituation) return;
  const onscreenStarts = getOnscreenStarts();
  currentSituation.targets = startsToTargets(onscreenStarts, DEFAULT_TOL);
  buildTargets(); if (!coachUnlocked) getAllRings().forEach(el=> el.style.display='none');
  if (scenarioMsg){ scenarioMsg.textContent='Targets seeded from starts.'; setTimeout(()=> scenarioMsg.textContent='', 1400); }
}
function genSlug(s){return String(s||'S').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'').slice(0,24)||'s';}
function genUniqueKey(title){
  const base=genSlug(title||'scenario'); let k=base, i=2; const has=key=>(SITUATIONS||[]).some(s=>s.key===key);
  while(has(k)) k=`${base}-${i++}`; return k.toUpperCase();
}
function makeBlankScenario(){
  const title=(newTitleInput?.value.trim())||(currentSituation?.title?`${currentSituation.title} (New)`:'New Scenario');
  const desc =(newDescInput?.value.trim()) || (currentSituation?.desc||'');
  const key  = genUniqueKey(title);
  const outsInit = outsSelScenario ? clampInt(outsSelScenario.value,0,2) : clampInt(currentSituation?.outs ?? 0,0,2);
  const runnersInit = getRunnersFromCheckboxes();

  return {
    key,
    title,
    desc,
    starts: Fcopy(DEFAULT_STARTS),
    // 👇 give the new situation visible rings immediately
    targets: startsToTargets(DEFAULT_STARTS, DEFAULT_TOL),
    hit: { x:1500, y:900 },
    hitType: 'line',
    batterAdvance: 1,
    outs: outsInit,
    runnersOn: normalizeRunnersOn(runnersInit)
  };
}
function addNewScenario(){
  const s=makeBlankScenario(); SITUATIONS.push(s);
  startsMap[s.key]=Fcopy(s.starts); saveStarts();
  populateSituations(); setSituation(s.key);
  if (scenarioMsg){ scenarioMsg.textContent='New scenario created.'; setTimeout(()=> scenarioMsg.textContent='',1400); }
}
function saveCurrentScenario(){
  if (!currentSituation) return;

  // Title/Desc from inputs
  if (newTitleInput){
    const t = newTitleInput.value.trim();
    if (t) currentSituation.title = t;
  }
  if (newDescInput){
    currentSituation.desc = newDescInput.value.trim();
  }

  // Outs (HUD sync)
  if (outsSelScenario){
    setOuts(outsSelScenario.value, {quiet:true});
  } else {
    currentSituation.outs = clampInt(currentSituation.outs ?? 0, 0, 2);
  }

  // Runners (model + HUD + markers)
  setRunnersOn(getRunnersFromCheckboxes(), {quiet:true});

  // Starts from chips -> persist
  const starts = getOnscreenStarts();
  currentSituation.starts = Fcopy(starts);
  startsMap[currentSituation.key] = Fcopy(starts);
  saveStarts();

  // Targets from rings (or seed from starts)
  let targets = getRenderedTargets();
  if (!targets || Object.keys(targets).length === 0){
    targets = {};
    POS_IDS.forEach(id=>{
      const p = starts[id];
      if (p) targets[id] = { x:Math.round(p.x), y:Math.round(p.y), tol:DEFAULT_TOL };
    });
  }
  currentSituation.targets = {};
  Object.entries(targets).forEach(([id,pt])=>{
    currentSituation.targets[id] = { x:Math.round(pt.x), y:Math.round(pt.y), tol:Number(pt.tol)||DEFAULT_TOL };
  });

  // Hit + meta (+ persist)
  ensureDefaultHit();
  currentSituation.hitType = (hitTypeSel && hitTypeSel.value) || currentSituation.hitType || 'line';
  currentSituation.batterAdvance = clampInt((advanceSel && advanceSel.value) ?? currentSituation.batterAdvance ?? 1, 0, 4);
  setHitSaved(currentSituation.key, currentSituation.hit);
  saveHits();

  // Refresh UI
  populateSituations();
  sitSelect.value = currentSituation.key;
  // update the left panel immediately (title + desc)
  if (curSitLabel) curSitLabel.textContent = currentSituation.title || '';
  if (curSitDesc)  curSitDesc.textContent  = currentSituation.desc  || '';

  syncScenarioInputsFromCurrent();
  renderBaseRunners();
  scaleMarkers();
  updateRunnersHudFromLive();

  if (scenarioMsg){ scenarioMsg.textContent='Scenario saved.'; setTimeout(()=> scenarioMsg.textContent='', 1400); }
}
function populateSituations(){
  const prev = sitSelect ? sitSelect.value : '';
  if (sitSelect) sitSelect.innerHTML='';
  (SITUATIONS||[]).forEach(s=>{
    const o=document.createElement('option'); o.value=s.key; o.textContent=s.title || s.key; sitSelect.appendChild(o);
  });
  const want = (SITUATIONS||[]).some(s=>s.key===prev) ? prev : (SITUATIONS[0] && SITUATIONS[0].key);
  if (want && sitSelect) sitSelect.value = want;
}
function setSituation(key){
  currentSituation = SITUATIONS.find(s=>s.key===key) || SITUATIONS[0];
  if (!currentSituation) return;

  if (!tokens || tokens.size===0) buildTokens();
  resetBallAndRunnerForSituation();

  // Title + Description UI
  if (curSitLabel) curSitLabel.textContent = currentSituation.title || '';
  if (curSitDesc)  curSitDesc.textContent  = currentSituation.desc  || '';

  const savedHit = getHitSaved(currentSituation.key); if (savedHit) currentSituation.hit = savedHit;

  // Tolerance dropdown
  tolTargetSel.innerHTML='';
  POS_IDS.forEach(id=>{
    const opt=document.createElement('option'); opt.value=id; opt.textContent=id;
    tolTargetSel.appendChild(opt);
  });

  // Move chips to starts
  POS_IDS.forEach(id=>{
    const t=tokens.get(id); if(!t) return;
    t.pos = Fcopy(getStartFor(currentSituation.key,id));
    placeToken(id);
  });

  // If this situation has no targets yet, seed them from the current chip starts
  if (!currentSituation.targets || Object.keys(currentSituation.targets).length === 0) {
    currentSituation.targets = startsToTargets(getOnscreenStarts(), DEFAULT_TOL);
  }

  // Targets & coach visibility
  buildTargets();
  if (!coachUnlocked) getAllRings().forEach(el=> el.style.display='none');

  // HUD / controls
  updateHud(0); gameActive=false; remainingTries=0;
  startBtn.disabled=false; resetBtn.disabled=true; checkBtn.disabled=true;
  setChipsLocked(!coachUnlocked);

  // Tolerance inputs
  const firstId=POS_IDS[0];
  tolTargetSel.value=firstId;
  syncTolInputsFromModel(firstId);

  // Hit + ball
  placeHitMarker();
  syncBallToHit();

  // Hit meta
  if (typeof currentSituation.hitType==='string') hitTypeSel.value=currentSituation.hitType;
  else currentSituation.hitType = hitTypeSel.value || 'line';

  if (typeof currentSituation.batterAdvance==='number') {
    advanceSel.value = String(clampInt(currentSituation.batterAdvance,0,4));
  } else {
    advanceSel.value = String(mapHitTypeToAdvance(currentSituation.hitType));
    currentSituation.batterAdvance = clampInt(advanceSel.value,0,4);
  }

  // Outs and runners
  const outsInit=clampInt((currentSituation.outs ?? 0),0,2);
  setOuts(outsInit,{quiet:true});
  setRunnersOn(normalizeRunnersOn(currentSituation.runnersOn), {quiet:true});

  // Sync Coach Tool inputs
  syncScenarioInputsFromCurrent();
  applyCoachVisibility();

  renderBaseRunners();
  scaleMarkers();
  updateRunnersHudFromLive();
}

/* =======================
   Export helpers
   ======================= */
function getOnscreenStarts(){ const out={}; POS_IDS.forEach(id=>{ const rec=tokens.get(id); if(rec&&rec.pos) out[id]={x:Math.round(rec.pos.x),y:Math.round(rec.pos.y)}; }); return out; }
function getRenderedTargets(){
  const out={}; getAllRings().forEach(el=>{
    const id=el.dataset.id; const left=parseFloat(el.style.left), top=parseFloat(el.style.top);
    const native=cssToUnit(left,top); const tol=currentSituation.targets?.[id]?.tol ?? DEFAULT_TOL;
    out[id]={x:Math.round(native.x),y:Math.round(native.y),tol:Math.round(tol)};
  }); return out;
}
function getHitForExport(sit){ return sit && sit.hit ? { x:Math.round(sit.hit.x), y:Math.round(sit.hit.y) } : undefined; }
function getStartsForExport(key){
  const src=(startsMap && startsMap[key]) ? startsMap[key] : DEFAULT_STARTS;
  const out={}; POS_IDS.forEach(id=>{ const p=src[id] || DEFAULT_STARTS[id]; out[id]={ x:Math.round(p.x), y:Math.round(p.y) }; });
  return out;
}
function composeSituationForExport(base,starts,targets,hit){
  const extra={...base}; delete extra.starts; delete extra.targets; delete extra.hit; delete extra.hitType; delete extra.batterAdvance;
  const payload={...extra, starts, targets}; if (hit) payload.hit=hit;
  if (base.hitType) payload.hitType=base.hitType;
  if (typeof base.batterAdvance==='number') payload.batterAdvance=clampInt(base.batterAdvance,0,4);
  return payload;
}
function buildCurrentSituationExport(){
  const s=currentSituation || SITUATIONS[0]; if(!s) return '[]';
  const one=composeSituationForExport(s, getOnscreenStarts(), getRenderedTargets(), getHitForExport(s));
  return JSON.stringify([one],null,2);
}
function buildAllSituationsExport(){
  const arr=(SITUATIONS||[]).map(s=>{
    const isCurrent=currentSituation && (s.key===currentSituation.key);
    const starts=isCurrent?getOnscreenStarts():getStartsForExport(s.key);
    let targets=isCurrent?getRenderedTargets():{};
    if (!isCurrent){ Object.entries(s.targets||{}).forEach(([id,pt])=>{ targets[id]={ x:Math.round(pt.x), y:Math.round(pt.y), tol:Math.round(pt.tol||DEFAULT_TOL)}; }); }
    const hit=getHitSaved(s.key) || getHitForExport(s);
    return composeSituationForExport(s,starts,targets,hit);
  });
  return JSON.stringify(arr,null,2);
}
function download(filename,content){
  const blob=new Blob([content], {type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=filename;
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href),2000);
}

/* ===============================================
   One-button refresh that updates/saves EVERYTHING
   under Coach Tools and rebuilds the UI view.
   =============================================== */
function refreshSituationAll(){
  if (!currentSituation) return;

  // 1) Title / Description
  if (newTitleInput){
    const t = newTitleInput.value.trim();
    if (t) currentSituation.title = t;
  }
  if (newDescInput){
    currentSituation.desc = newDescInput.value.trim();
  }

  // 2) Outs (HUD + dropdown sync)
  if (outsSelScenario){
    setOuts(outsSelScenario.value, {quiet:true});
  } else {
    currentSituation.outs = clampInt(currentSituation.outs ?? 0, 0, 2);
  }

  // 3) Runners (model + HUD + markers)
  setRunnersOn(getRunnersFromCheckboxes(), {quiet:true});

  // 4) Starts: pull from chips and persist
  const starts = getOnscreenStarts();
  currentSituation.starts = Fcopy(starts);
  startsMap[currentSituation.key] = Fcopy(starts);
  saveStarts();

  // 5) Targets:
  //    - If visible rings exist, read them back (live tol & positions).
  //    - Otherwise seed from starts (ensures targets always exist).
  let targets = getRenderedTargets();
  if (!targets || Object.keys(targets).length === 0){
    targets = {};
    POS_IDS.forEach(id=>{
      const p = starts[id];
      if (p) targets[id] = { x:Math.round(p.x), y:Math.round(p.y), tol:DEFAULT_TOL };
    });
  }
  currentSituation.targets = {};
  Object.entries(targets).forEach(([id,pt])=>{
    currentSituation.targets[id] = {
      x:Math.round(pt.x),
      y:Math.round(pt.y),
      tol:Number(pt.tol)||DEFAULT_TOL
    };
  });

  // 6) Hit + meta (+ persist hit location only)
  ensureDefaultHit();
  currentSituation.hitType = (hitTypeSel && hitTypeSel.value) || currentSituation.hitType || 'line';
  currentSituation.batterAdvance = clampInt(
    (advanceSel && advanceSel.value) ?? currentSituation.batterAdvance ?? 1,
    0, 4
  );
  setHitSaved(currentSituation.key, currentSituation.hit);
  saveHits();

  // 7) Rebuild UI pieces to reflect the saved model
  populateSituations();
  sitSelect.value = currentSituation.key;

  const labelEl = document.getElementById('curSitLabel');
  if (labelEl) labelEl.textContent = currentSituation.title || '';
  if (curSitDesc) curSitDesc.textContent = currentSituation.desc || '';

  // Rebuild targets (applies new tolerance sizes), hit marker & ball
  buildTargets();
  placeHitMarker();
  syncBallToHit();
  renderBaseRunners();
  scaleMarkers();
  updateRunnersHudFromLive();

  // Keep tolerance inputs in sync with selected target
  if (tolTargetSel){
    const id = tolTargetSel.value || POS_IDS[0];
    if (id) syncTolInputsFromModel(id);
  }

  // 8) Toasty message
  if (scenarioMsg){
    scenarioMsg.textContent='Situation refreshed.';
    setTimeout(()=> scenarioMsg.textContent='', 1400);
  }
}

/* =======================
   Game flow
   ======================= */
function checkPositions(){
  if (!coachUnlocked && !gameActive) return;
  const t=currentSituation.targets||{}; let correct=0;
  const isFinalTry = (!coachUnlocked && gameActive && remainingTries===1);
  getAllRings().forEach(el=>{
    const id=el.dataset.id; const target=t[id]; if(!target) return;
    const cur=tokens.get(id).pos; const tol=Number(target.tol)||DEFAULT_TOL;
    const d=Math.hypot(cur.x-target.x, cur.y-target.y); const isCorrect=d<=tol;
    el.classList.toggle('good',isCorrect); el.classList.toggle('bad',!isCorrect); el.classList.add('show-label');
    if (coachUnlocked){ el.style.display='block'; } else { el.style.display = (isFinalTry || isCorrect) ? 'block' : 'none'; }
    if (isCorrect) correct++;
  });
  updateHud(correct);
  if (!coachUnlocked && gameActive){
    remainingTries = Math.max(0, remainingTries - 1);
    updateHud(correct);
    if (correct===9 || remainingTries===0){ checkBtn.disabled=true; setChipsLocked(true); }
  }
}
function resetBallAndRunnerForSituation(){
  if (animReq){ cancelAnimationFrame(animReq); animReq=null; }
  if (ballSvg) ballSvg.innerHTML='';
  if (ballEl) syncBallToHit();
  if (runnerAnimId){ cancelAnimationFrame(runnerAnimId); runnerAnimId=null; }
  hideRunner();
}
function resetPlayers(){
  POS_IDS.forEach(id=>{ const t=tokens.get(id); if(!t) return; t.pos=Fcopy(getStartFor(currentSituation.key,id)); placeToken(id); });
  getAllRings().forEach(el=> el.style.display=coachUnlocked ? 'block' : 'none');
  updateHud(0); gameActive=false; remainingTries=0;
  startBtn.disabled=false; resetBtn.disabled=true; checkBtn.disabled=true;
  setChipsLocked(!coachUnlocked);
  if (ballSvg) ballSvg.innerHTML=''; if (ballEl) syncBallToHit();
  hideRunner();
  liveRunners = normalizeRunnersOn(currentSituation.runnersOn);
  renderBaseRunners();
  scaleMarkers();
  updateRunnersHudFromLive();
}

/* =======================
   Init & events
   ======================= */
async function init(){
  try{
    sizeOverlays();
    await loadSituationsFromJson();
    loadStarts(); loadHits();
    if (!Array.isArray(SITUATIONS) || SITUATIONS.length===0){
      SITUATIONS=[{ key:'S1', title:'Default', desc:'', starts:Fcopy(DEFAULT_STARTS), targets:{},
        hit:{x:1500,y:900}, hitType:'line', batterAdvance:1, outs:0, runnersOn:{first:false,second:false,third:false} }];
    }
    populateSituations();
    const firstKey = (sitSelect && sitSelect.value) || (SITUATIONS[0] && SITUATIONS[0].key);
    buildTokens(); updateChipScale(); setSituation(firstKey); setCoachMode(false);
    observeWrap(); scheduleLayout();
  } catch (err){
    console.error('[Init] fatal error:', err && (err.stack||err.message||err));
    alert('There was an error starting the app. Open the console for details.');
  }
}

/* Wiring */
if (sitSelect) sitSelect.addEventListener('change', e=> setSituation(e.target.value));
if (resetBtn)  resetBtn.addEventListener('click', resetPlayers);
if (checkBtn)  checkBtn.addEventListener('click', checkPositions);
if (startBtn)  startBtn.addEventListener('click', ()=>{
  if (!currentSituation) return;

  gameActive=true; remainingTries=MAX_TRIES; updateHud(0);
  if (!coachUnlocked) getAllRings().forEach(el=> el.style.display='none');
  startBtn.disabled=true; if (resetBtn) resetBtn.disabled=false; if (checkBtn) checkBtn.disabled=false;
  setChipsLocked(false); syncBallToHit();

  // Ball animation (slowed like before)
  const ht = (currentSituation.hitType) || (hitTypeSel && hitTypeSel.value) || 'line';
  animateHit(ht);

  // Bases batter will advance
  const advFromSit=(typeof currentSituation.batterAdvance==='number') ? currentSituation.batterAdvance : null;
  const advFromUI = advanceSel ? clampInt(advanceSel.value,0,4) : null;
  const advance   = (advFromSit ?? advFromUI ?? mapHitTypeToAdvance(ht));

  // 1) Start positions from the template (don’t compute final yet)
  liveRunners = normalizeRunnersOn(currentSituation.runnersOn);

  // 2) Animate existing runners in parallel (first/second/third)
  let existingDone = false, batterDone = false;
  let finalExisting = null;
  let batterDest = null;

  animateExistingRunnersAdvance(advance, (finalState)=>{
    finalExisting = finalState;
    existingDone = true;
    maybeFinish();
  });

  // 3) Animate batter (don’t place static until done)
  animateBatterAdvance(advance, (destBase)=>{
    batterDest = destBase; // remember where he ended
    batterDone = true;
    maybeFinish();
  });

  // 4) When both animations finish, commit final state and render
  function maybeFinish(){
    if (!existingDone || !batterDone) return;
    // start from existing runners’ final positions
    liveRunners = normalizeRunnersOn(finalExisting || liveRunners);

    // add batter if he stopped on a base (home == scored, no marker)
    if (batterDest === 'first')   liveRunners.first  = true;
    else if (batterDest === 'second') liveRunners.second = true;
    else if (batterDest === 'third')  liveRunners.third  = true;

    renderBaseRunners();
    updateRunnersHudFromLive();
  }
});
coachBtn.addEventListener('click', ()=>{ coachUnlocked ? (setCoachMode(false), coachCard.classList.add('hidden'), setChipsLocked(!gameActive||remainingTries===0), getAllRings().forEach(el=>el.style.display='none'), syncBallToHit()) : openPwModal(); });
pwCancel.addEventListener('click', closePwModal);
pwOk.addEventListener('click', tryUnlock);
pwInput.addEventListener('keydown', e=>{ if(e.key==='Enter') tryUnlock(); });

hitTypeSel.addEventListener('change', ()=>{
  if (!currentSituation) return;
  currentSituation.hitType = hitTypeSel.value || 'line';
  if (currentSituation.batterAdvance == null) advanceSel.value = String(mapHitTypeToAdvance(currentSituation.hitType));
});
advanceSel.addEventListener('change', ()=>{ if(currentSituation) currentSituation.batterAdvance=clampInt(advanceSel.value,0,4); });
testHitBtn.addEventListener('click', ()=> animateHit());

if (run1B) run1B.addEventListener('change', ()=> setRunnersOn(null, {quiet:false}));
if (run2B) run2B.addEventListener('change', ()=> setRunnersOn(null, {quiet:false}));
if (run3B) run3B.addEventListener('change', ()=> setRunnersOn(null, {quiet:false}));

function syncTolInputsFromModel(id){
  const tol = Number(getTargetFor(currentSituation.key,id)?.tol) || DEFAULT_TOL;
  tolNum.value = tolRange.value = String(tol);
}
tolTargetSel.addEventListener('change', ()=> syncTolInputsFromModel(tolTargetSel.value));
function setTolLive(id,tol){
  tol = clamp(Number(tol)||DEFAULT_TOL,5,400);
  let tgt = getTargetFor(currentSituation.key,id);
  if (!tgt){
    const pt = tokens.get(id)?.pos || getStartFor(currentSituation.key,id);
    setTargetFor(currentSituation.key,id,pt,tol);
    buildTargets();
  } else { tgt.tol = tol; }
  const ring = getRingEl(id);
  if (ring){
    const d=tolToCssDiameter(tol, coachUnlocked);
    ring.style.width=d+'px'; ring.style.height=d+'px';
    if (coachUnlocked) { ring.style.display='block'; ring.classList.add('show-label'); }
  }
  tolNum.value = tolRange.value = String(tol);
}
tolNum.addEventListener('input', ()=> setTolLive(tolTargetSel.value,tolNum.value));
tolRange.addEventListener('input', ()=> setTolLive(tolTargetSel.value,tolRange.value));

if (newScenarioBtn)  newScenarioBtn.addEventListener('click', addNewScenario);
if (seedTargetsBtn)  seedTargetsBtn.addEventListener('click', seedTargetsFromStarts);
if (saveScenarioBtn) saveScenarioBtn.addEventListener('click', refreshSituationAll);

if (outsSelScenario) outsSelScenario.addEventListener('change', e=> setOuts(e.target.value, {quiet:false}));

downloadCurrentBtn.addEventListener('click', ()=> download('situation-current.json', buildCurrentSituationExport()));
downloadAllBtn.addEventListener('click', ()=> download('situations-all.json', buildAllSituationsExport()));
copyAllBtn.addEventListener('click', async ()=>{ try{ await navigator.clipboard.writeText(buildAllSituationsExport()); }catch{} });

/* Kickoff */
if (img && img.complete) init();
else if (img){ img.addEventListener('load', init, { once:true }); window.addEventListener('load', ()=>{ if (!SITUATIONS.length) init(); }, { once:true }); }
else { window.addEventListener('load', init, { once:true }); }
</script>

</body>
</html>
