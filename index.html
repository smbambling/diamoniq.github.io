<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Diamond IQ — Chips + Targets + Coach Tools (JSON situations)</title>
<style>
  /* --- Base UI --- */
  body{
    margin:0;
    font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    background:#f6f7fb;color:#1f2937;
  }

  /* ---- Header (DOM-order driven) ---- */
  header{
    display:flex;
    align-items:center;
    gap:8px;
    padding:12px;
    background:#fff;
    border-bottom:1px solid #e5e7eb;
    position:sticky; top:0; z-index:10;
  }
  header h1{
    margin:0 8px 0 0;
    font-size:16px;
    font-weight:800;
  }

  /* Everything except <h1> lives inside .header-actions in the desired DOM order:
     Random → Select → Description → Runners → Outs → Start → Reset → Check → HUD → Coach */
  header .header-actions{
    display:flex;
    flex-wrap:wrap;              /* wrap nicely on smaller screens */
    align-items:center;
    gap:8px;
    flex:1;                      /* allow actions row to stretch */
  }

  /* Situation dropdown auto-sizes to its text */
  #sitSelect{
    width:auto;
    min-width:140px;
    border-color:#cbd5e1;
    box-shadow:inset 0 1px 2px rgba(0,0,0,.04);
  }
  #sitSelect:focus{
    outline:none;
    border-color:#94a3b8;
    box-shadow:0 0 0 3px rgba(148,163,184,.35);
  }

  /* Description pill — auto-size with graceful truncation on wide screens */
  #descHud{
    display:inline-flex;align-items:center;gap:6px;
    padding:6px 10px;border-radius:999px;font-weight:900;font-size:13px;
    border:1px solid rgba(0,0,0,.08); box-shadow:0 1px 2px rgba(0,0,0,.06);
    background:#f8fafc;color:#0b1321;

    max-width:50%;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  @media (max-width:720px){ #descHud{ font-size:12px } }

  /* Keep Score & Tries together, pinned at right before Coach */
  #hud{
    margin-left:auto;            /* pushes HUD to the right edge */
    display:flex;
    align-items:center;
    gap:8px;
  }

  /* Inputs / buttons */
  select,button,input[type="number"],input[type="range"]{
    padding:6px 10px;font-weight:700;border:1px solid #e5e7eb;border-radius:8px;background:#fff;
  }
  button{ cursor:pointer }
  .btn-green{background:#16a34a;color:#fff;border-color:#15803d}
  .btn-orange{background:#f97316;color:#fff;border-color:#ea580c}
  .btn-slate{background:#fff;color:#334155;border:1px solid #cbd5e1}
  .btn-small{padding:4px 8px;font-size:12px;line-height:1.2}

  #startBtn:disabled,#resetBtn:disabled{
    background:#f1f5f9;color:#94a3b8;border-color:#cbd5e1;cursor:not-allowed;
  }
  #checkBtn:disabled{
    background:#e5e7eb !important;color:#94a3b8 !important;border-color:#cbd5e1 !important;cursor:not-allowed;
  }

  /* HUD badges */
  .badge{
    display:inline-flex;align-items:center;gap:6px;
    padding:6px 10px;border-radius:999px;font-weight:900;font-size:13px;
    border:1px solid rgba(0,0,0,.08); box-shadow:0 1px 2px rgba(0,0,0,.06);
    background:#f8fafc;color:#0b1321;
  }
  .badge-score{background:#ecfeff;border-color:#a5f3fc}
  .badge-tries{background:#eef2ff;border-color:#c7d2fe}
  .tries-green{background:#dcfce7;border-color:#86efac}
  .tries-yellow{background:#fef9c3;border-color:#fde68a}
  .tries-red{background:#fee2e2;border-color:#fecaca}
  .score-green{background:#dcfce7;border-color:#86efac}
  .score-yellow{background:#fef9c3;border-color:#fde68a}
  .score-red{background:#fee2e2;border-color:#fecaca}
  .badge .dot{width:10px;height:10px;border-radius:50%;box-shadow:inset 0 0 0 1px rgba(0,0,0,.08)}
  .dot-score{background:#06b6d4}
  .dot-tries{background:#6366f1}

  /* App shell */
  .app{display:grid;grid-template-columns:1fr 340px;gap:14px;padding:14px;max-width:min(1600px,96vw);margin:0 auto}
  header .header-row{width:100%;max-width:min(1600px,96vw);margin:0 auto}
  @media (max-width:1100px){
    .app{grid-template-columns:1fr;gap:12px;padding:10px;max-width:98vw}
    header .header-row{max-width:100vw}
  }
  @media (max-width:900px){
    .app{max-width:100vw;padding-left:8px;padding-right:8px}
  }
  @media (max-width:600px){ .card{padding:8px} }
  .card{background:#fff;border:1px solid #e5e7eb;border-radius:10px;padding:10px}
  .sideCol{display:flex;flex-direction:column;gap:12px}

  /* Field + overlays */
  #wrap{position:relative}
  #fieldImg{display:block;width:100%;height:auto;border-radius:10px;background:#fff}
  .overlay{position:absolute;inset:0;pointer-events:none}
  #targetsLayer{pointer-events:none;z-index:2}
  #ballLayer{pointer-events:none;z-index:3}

  .badge-timer{background:#fff7ed;border-color:#fed7aa}
  .badge-timer.low{background:#fee2e2;border-color:#fecaca}

  /* Chips */
  :root { --chip-size: 36px; --chip-font: 14px; }
  .chip{
    position:absolute;transform:translate(-50%,-50%);
    width:var(--chip-size);height:var(--chip-size);
    border-radius:50%;display:flex;align-items:center;justify-content:center;
    font-weight:700;font-size:var(--chip-font);color:#fff;cursor:grab;
    box-shadow:0 1px 3px rgba(0,0,0,.35);user-select:none;touch-action:none;pointer-events:auto;z-index:1;
  }
  .chip:active{transform:translate(-50%,-50%) scale(1.045)}
  .chip.Battery{background:#f59e0b}
  .chip.Infield{background:#2563eb}
  .chip.Outfield{background:#dc2626}
  .chip.locked{cursor:not-allowed;opacity:.7}

  /* Phase 2 visuals */
  .chip.selectableChip{ outline:2px solid rgba(2,132,199,.75); outline-offset:2px }
  .chip.correctPulse{ animation:chipPulse .28s ease-in-out }
  .chip.wrongShake{  animation:chipShake .22s ease-in-out }
  @keyframes chipPulse{ 0%{transform:translate(-50%,-50%) scale(1)} 50%{transform:translate(-50%,-50%) scale(1.10)} 100%{transform:translate(-50%,-50%) scale(1)} }
  @keyframes chipShake{ 0%,100%{transform:translate(-50%,-50%)} 25%{transform:translate(calc(-50% - 4px),-50%)} 75%{transform:translate(calc(-50% + 4px),-50%)} }

  /* Locked-correct chip highlight for Phase 2 */
  .chip.seq-locked{
    outline: 3px solid rgba(22,163,74,.9);
    outline-offset: 2px;
    box-shadow: 0 0 0 2px rgba(0,0,0,.25), 0 0 0 6px rgba(22,163,74,.2);
    cursor: default !important;
  }


  /* Targets */
  .tgt{
    position:absolute;transform:translate(-50%,-50%);
    border:3px solid rgba(255,255,255,.98);border-radius:999px;display:none;
    box-shadow:0 0 0 3px rgba(0,0,0,.28),0 0 0 10px rgba(255,255,255,.18);
    background:rgba(0,0,0,0.05);touch-action:none;z-index:2;
  }
  .tgt.draggable{cursor:grab;pointer-events:auto}
  .tgt.good{background:rgba(22,163,74,.25)}
  .tgt.bad{background:rgba(239,68,68,.25)}
  .tgt .tgt-label{
    position:absolute;top:calc(100% + 6px);left:50%;transform:translateX(-50%);
    padding:2px 7px;border-radius:6px;font-weight:900;font-size:12px;
    color:#0b1321;background:rgba(255,255,255,.95);border:1px solid rgba(0,0,0,.2);white-space:nowrap;display:none;
  }
  .tgt.show-label .tgt-label{display:block}
  .tgt.locked{cursor:not-allowed}

  /* Clickable after last try */
  .tgt.selectable{ pointer-events:auto; cursor:pointer; }
  .tgt.selected{ box-shadow:0 0 0 3px rgba(2,132,199,.45), 0 0 0 10px rgba(2,132,199,.15) }

  /* Target Notes textarea */
  #tolNotes{ font:13px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }

  /* Ball path + ball */
  #ballLayer svg{width:100%;height:100%;display:block}
  .ball{
    position:absolute;transform:translate(-50%,-50%);width:14px;height:14px;border-radius:50%;
    background:#fff;box-shadow:0 0 0 2px #000, 0 1px 3px rgba(0,0,0,.35);
    z-index:10; /* ⬅️ higher than chips (1), runners (3), trails (3), seqBall (4) */
    pointer-events:auto;cursor:grab;
  }
  .ball.locked{pointer-events:none;cursor:default;opacity:.95}

  /* Runner + base runners */
  .runner,.baseRunner{
    position:absolute;transform:translate(-50%,-50%) rotate(45deg);width:14px;height:14px;background:#0b0b0b;
    box-shadow:0 0 0 2px #ffffff,0 1px 2px rgba(0,0,0,.30);border-radius:4px;z-index:3;pointer-events:none;
  }
  .runner .rlabel,.baseRunner .rlabel{
    position:absolute;inset:0;display:flex;align-items:center;justify-content:center;transform:rotate(-45deg);
    color:#fff;font-weight:900;font-size:13px;text-shadow:0 1px 1px rgba(0,0,0,.35);user-select:none;
  }
  .movingRunner{width:14px;height:14px;background:#111;border-radius:2px;box-shadow:0 0 0 2px #fff}

  /* Coach hit target marker */
  .hitTarget{
    position:absolute;transform:translate(-50%,-50%);width:18px;height:18px;border-radius:50%;
    background:#f97316;box-shadow:0 0 0 2px #7c2d12 inset, 0 0 0 2px #ffffff;cursor:grab;touch-action:none;pointer-events:auto;z-index:4;
  }
  .hitTarget:active{transform:translate(-50%,-50%) scale(1.05)}

  /* Coach Tools UI */
  .coachGrid{display:grid;gap:8px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .subsec{border:1px dashed #e5e7eb;border-radius:10px;padding:8px;margin-top:6px}
  .subsec > .title{font-weight:800;color:#334155;margin-bottom:6px;font-size:13px}
  /* === Play Sequence Builder (Coach) === */
  .pos-grid{
    display:grid;
    grid-template-columns: repeat(5, minmax(44px, 1fr)); /* max 5 across */
    gap:6px;
  }
  .pos-btn{
    padding:6px 8px;border:1px solid #cbd5e1;border-radius:8px;background:#fff;cursor:pointer;font-weight:800;
    text-align:center; user-select:none; transition:transform .06s ease;
  }
  .pos-btn:active{ transform:scale(.98) }
  .pos-btn[data-group="Battery"]{ background:#fff7ed; border-color:#fed7aa }
  .pos-btn[data-group="Infield"]{ background:#eef2ff; border-color:#c7d2fe }
  .pos-btn[data-group="Outfield"]{ background:#fee2e2; border-color:#fecaca }

  .seq-list{
    display:flex; flex-direction:column; gap:6px; margin-top:6px;
    min-height:38px; background:#f8fafc; border:1px dashed #cbd5e1; border-radius:10px; padding:8px;
  }
  .seq-item{
    display:flex; align-items:center; gap:8px; background:#fff; border:1px solid #e5e7eb;
    border-radius:10px; padding:6px 8px; cursor:grab; user-select:none;
  }
  .seq-item.dragging{ opacity:.6 }
  .seq-num{
    width:22px;height:22px;border-radius:999px;background:#e0f2fe;border:1px solid #bae6fd;
    font-weight:900; display:flex;align-items:center;justify-content:center;color:#0b1321
  }
  .seq-tag{
    font-weight:800; padding:2px 6px; border-radius:6px; background:#f1f5f9; border:1px solid #e5e7eb;
  }
  .seq-remove{
    margin-left:auto;
    padding:4px 8px;font-size:12px;border:1px solid #fecaca;border-radius:8px;background:#fff;cursor:pointer;color:#dc2626;
  }
  .seq-ghost{
    height:34px; border:2px dashed #94a3b8; border-radius:10px; background:transparent;
  }
  .seq-toolbar{ display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap }

  .hint{font-size:12px;color:#64748b;font-weight:700}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}
  .hidden{display:none!important}

  /* Phase 2: throw animation ball + trail */
  .seqBall {
    position:absolute;
    width:14px;height:14px;border-radius:50%;
    background:#fff;
    box-shadow:0 0 0 2px #000, 0 1px 3px rgba(0,0,0,.35);
    transform:translate(-50%,-50%);
    z-index:4; /* above chips */
    pointer-events:none;
  }
  .throwTrail {
    position:absolute; inset:0; pointer-events:none; z-index:3;
  }
  .throwTrail svg path {
    stroke:#334155;            /* darker fallback if no color is set */
    fill:none;
    stroke-width:4;            /* thicker for visibility */
    stroke-linecap:round;
    stroke-linejoin:round;
    opacity:.95;
  }

  /* Collapsible description behavior (legacy support if used) */
  #sitDescBar.desc-collapsed{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  #sitDescBar.desc-expanded{white-space:pre-wrap}

  /* Coach password modal */
  #pwModal{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:1000}
  #pwModal .box{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:16px;min-width:280px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  #pwModal input[type="password"]{
    display:block;width:100% !important;box-sizing:border-box;
    margin-top:8px;padding:10px 12px;border:1px solid #cbd5e1 !important;border-radius:10px;background:#fff;
  }
  #pwModal input[type="password"]:focus{outline:none;box-shadow:0 0 0 3px rgba(59,130,246,.35)}
  #pwModal .row{justify-content:flex-end !important;gap:10px;margin-top:12px !important}

  /* How to play: expandable */
  #howToCard summary {
    list-style: none;
    display: flex;
    align-items: center;
    justify-content: space-between;
    cursor: pointer;
    user-select: none;
  }
  #howToCard summary::-webkit-details-marker { display: none; }

  #howToCard .htp-caret {
    transition: transform .18s ease, opacity .18s ease;
    margin-left: 8px;
    opacity: .7;
  }
  #howToCard details[open] .htp-caret {
    transform: rotate(90deg);
    opacity: 1;
  }
  #howToCard .howto-body { margin-top: 8px; }

  @media (max-width:420px){
    .pos-grid{
      grid-template-columns: repeat(3, minmax(44px, 1fr));
    }
  }

  /* ===== Responsive tweaks ===== */
  @media (max-width:900px){
    /* Let select + description use full width rows when needed */
    #sitSelect{
      flex:1 1 100%;
      max-width:100%;
    }
    #descHud{
      flex:1 1 100%;
      max-width:100%;
      white-space:pre-wrap;
      text-overflow:clip;
    }

    /* Make controls easier to tap; stack if needed */
    header .header-actions > button,
    header .header-actions > select{
      width:100%;
    }
  }
  @media (max-width:600px){
    #runnersBadge, #outsHud{ flex:1 1 48%; }
    #sitSelect{ min-width:160px; }
  }
  @media (max-width:520px){
    #sitSelect{ min-width:140px; }
  }
</style>

</head>
<body>

<header>
  <h1>Diamond IQ</h1>
    <button id="randomSitBtn" class="btn-slate btn-small" title="Pick a random situation">Random</button>
  <select id="sitSelect" aria-label="Situation" data-testid="sit-select"></select>
  <span id="descHud" class="badge"></span>
  <span id="runnersBadge" class="badge"><span style="background:#10b981"></span>Runners: <b><span id="runnersVal">—</span></b></span>
  <span id="outsHud" class="badge badge-tries" style="margin-left:2px">
    Outs: <b><span id="outsVal">0</span></b>
  </span>
  <div class="header-actions">
    <!-- @diq:begin control:startBtn -->
<button id="startBtn" class="btn-green">Start Situation</button>
    <button id="resetBtn" class="btn-orange">Reset</button>
    <!-- @diq:begin control:checkBtn -->
<button id="checkBtn" class="btn-green" disabled data-testid="check-btn">Check Positions</button>
    <!-- @diq:begin control:continueBtn -->
<button id="continueBtn" class="btn-green hidden" title="Continue to Phase 2">Continue ▶</button>
  </div>

  <div id="hud" class="hud">
    <span id="scoreBadge" class="badge badge-score" data-testid="score-badge">Score: <b><span id="scoreVal">0</span>/9</b></span>
    <span id="triesBadge" class="badge badge-tries">Tries: <b><span id="triesVal">0</span></b></span>
    <span id="timerBadge" class="badge badge-timer" title="Time left in this phase">
      ⏱️ <b><span id="timerVal">60</span>s</b>
    </span>
  </div>

  <button id="coachBtn" class="btn-slate">Coach Tools</button>
</header>

<main class="app">
  <section class="card">
    <div id="wrap">
      <img id="fieldImg" src="baseballfield.png" alt="Baseball Field">
      <!-- visual-only layers kept for z-ordering -->
      <div id="targetsLayer" class="overlay"></div>
      <div id="ballLayer" class="overlay"></div>
      <!-- chips, rings, and hit marker are appended directly to #wrap -->
    </div>
  </section>

  <aside class="sideCol">
    <div class="card" id="howToCard">
      <details id="howToDetails">
        <summary>
          <strong>How to play (click to expand)</strong>
          <span class="htp-caret" aria-hidden="true">▸</span>
        </summary>

        <div class="howto-body">
          <ol style="margin:6px 0 0 1.2em">
            <!-- Phase 1 -->
            <li>Select a situation from the dropdown (or click <em>Random</em>).</li>
            <li>Review the Description, Runners, and Outs shown in the header.</li>
            <li>Press <em>Start Situation</em> to begin Phase 1.</li>
            <li>Drag the 9 player chips into the correct defensive positions.</li>
            <li>Press <em>Check Positions</em> to verify. You have 3 tries to get them correct.</li>

            <!-- Transition -->
            <li>If you finish Phase 1 correctly (or use all tries), press <em>Continue</em> to start Phase 2 (if available for this situation).</li>

            <!-- Phase 2 -->
            <li>In Phase 2, the player chips move to their correct positions automatically.</li>
            <li>Select the players (chips) in the correct throw order to execute the play.</li>
            <li>Click chips to add them to your sequence; click again to unselect (unless a chip is already locked as correct).</li>
            <li>Press <em>Verify Sequence</em> to check your picks. You have 3 tries.</li>
            <li>Correct chips (in the proper order) will lock and remain highlighted. Phase 2 ends when all throws are correct or tries are used.</li>
          </ol>

          <div class="hint" style="margin-top:8px">
            Note: Phase 2 appears only if a Play Sequence is configured for the situation.
          </div>
        </div>
      </details>
    </div>

    <!-- Selected Target (appears after last try) -->
    <!-- @diq:begin panel:targetPanel -->
<div id="targetPanel" class="card hidden">
      <strong id="targetPanelTitle">Selected Target</strong>
      <div id="targetPanelBody" style="margin-top:6px; font-size:13px; line-height:1.45"></div>
    </div>

    <!-- Phase 2: Sequence panel -->
    <!-- @diq:begin panel:seqPanel -->
<div id="seqPanel" class="card hidden">
      <strong>Play Sequence</strong>
      <!-- @diq:begin panel:seqBody -->
<div id="seqBody" aria-live="polite" style="margin-top:6px; font-size:13px; line-height:1.45"></div>

    </div>


    <!-- Coach Tools (hidden until unlocked) -->
    <div id="coachCard" class="card hidden">
      <div class="coachGrid">
  <div class="row">
    <strong>Coach Tools</strong>
    <span id="coachStatus" class="mono" style="color:#64748b">locked</span>
    <span class="hint"> (drag chips, targets & hit marker while unlocked)</span>
  </div>

  <!-- Situation Builder -->
  <div class="subsec">
    <div class="title">Situation Builder</div>
    <div class="row">
      <button id="newSituationBtn" class="btn-slate">➕ New Situation</button>
    </div>
    <div class="row">
      <label class="hint">Title:</label>
      <input id="newTitleInput" type="text" style="flex:1;min-width:120px"/>
    </div>
    <div class="row">
      <label class="hint">Description:</label>
      <input id="newDescInput" type="text" style="flex:2;min-width:200px"/>
    </div>
    <div class="row">
      <label class="hint">Outs:</label>
      <select id="outsSelSituation">
        <option value="0">0 outs</option>
        <option value="1">1 out</option>
        <option value="2">2 outs</option>
      </select>
    </div>
    <div class="row">
      <button id="saveSituationBtn" class="btn-slate">🔄 Refresh Situation</button>
      <button id="deleteSituationBtn" class="btn-slate" title="Delete current situation" style="color:#ef4444;border-color:#fecaca">🗑️ Delete Situation</button>
      <button id="resetStartsBtn" class="btn-slate" title="Reset player chips to default locations">↺ Reset Player Starts</button>
      <span id="situationMsg" class="hint" style="margin-left:auto"></span>
    </div>
  </div>
</div>

        <!-- Runners on Base -->
        <div class="subsec">
          <div class="title">Runners on Base</div>
          <span class="hint" style="margin-left:auto">Updates HUD instantly</span>
          <div class="row" id="runnersRow">
            <label class="hint">Select base runners:</label>
            <label><input id="run1B" type="checkbox"> 1B</label>
            <label><input id="run2B" type="checkbox"> 2B</label>
            <label><input id="run3B" type="checkbox"> 3B</label>
          </div>
        </div>

        <!-- Targets & Tolerance -->
        <div class="subsec">
          <div class="title">Targets & Tolerance</div>
          <div class="row">
            <label class="hint">Target:</label>
            <select id="tolTargetSel"></select>
            <label class="hint">Tolerance:</label>
            <input id="tolNum" type="number" min="5" max="400" step="1" value="65"/>
            <input id="tolRange" type="range" min="5" max="400" step="1" value="65" style="flex:1"/>
          </div>
          <div class="row" style="flex-direction:column; align-items:stretch; gap:6px">
            <textarea id="tolNotes" rows="3"
              placeholder="Enter coaching notes for this target…"
              style="width:100%; min-height:72px; resize:vertical"></textarea>
            <span class="hint">Saved per target (based on the Target dropdown above).</span>
          </div>
        </div>

        <!-- Ball Hit (single) -->
        <div class="subsec">
          <div class="title">Ball Hit</div>
          <div class="hint">Drag the marker to set the ball’s landing spot and set batter advance for this situation.</div>
            <button id="testHitBtn" class="btn-green" style="margin-left:auto;padding:4px 8px;font-size:12px;line-height:1.2">▶ Test</button>
          <div class="row">
            <label class="hint">Hit type:</label>
            <select id="hitTypeSel">
              <option value="line">Line drive</option>
              <option value="popup">Pop up</option>
              <option value="grounder">Grounder</option>
            </select>
            <select id="advanceSel" title="Batter bases to advance (0–3)">
              <option value="0">0 (Out)</option>
              <option value="1">1 (Single)</option>
              <option value="2">2 (Double)</option>
              <option value="3">3 (Triple)</option>
            </select>
          </div>
        </div>

        <!-- Play Sequence (Phase 2) — Click + Drag Builder -->
        <div class="subsec" id="seqSubsec">
          <div class="title">Play Sequence</div>
          <span class="hint" style="color:#dc2626">Leave the sequence empty to disable Phase 2 for this situation.</span>
          <div class="hint">Click positions below to add; drag items to reorder; remove with the ❌ button.</div>

          <!-- Click-to-add grid -->
          <div id="seqPosGrid" class="pos-grid" style="margin-top:6px"></div>

          <!-- Sequence list (draggable items) -->
          <div id="seqList" class="seq-list" aria-live="polite"></div>

          <!-- Toolbar: templates / clear -->
          <div class="seq-toolbar">
            <select id="seqTemplateSel" title="Load a common relay">
              <option value="">Template…</option>
              <option value="LF,SS,2B,C">LF → SS → 2B → C (relay home)</option>
              <option value="CF,SS,3B">CF → SS → 3B (hold runner)</option>
              <option value="RF,1B">RF → 1B (hold at first)</option>
              <option value="SS,2B,1B">SS → 2B → 1B (6-4-3 DP)</option>
            </select>
            <button id="seqClearBtn" class="btn-slate btn-small">Clear sequence</button>
            <span class="hint">Total steps: <b id="seqCountHud">0</b></span>
          </div>

          <!-- Optional overall coach note (keeps the same id you already use) -->
          <div class="row" style="flex-direction:column; align-items:stretch; gap:6px; margin-top:6px">
            <textarea id="seqNoteInput" rows="3"
              placeholder="Optional coach note shown to players on the Play Sequence card…"
              class="mono" style="width:100%"></textarea>
          </div>
        </div>


        <!-- Export -->
        <div class="subsec">
          <div class="title">Export</div>
          <div class="row">
            <button id="downloadCurrentBtn" class="btn-slate">⬇️ Download Current JSON</button>
            <button id="downloadAllBtn" class="btn-slate">⬇️ Download ALL JSON</button>
            <button id="copyAllBtn" class="btn-slate">📋 Copy ALL JSON</button>
          </div>
        </div>
      </div>
    </div>
  </aside>
</main>

<!-- Password modal -->
<div id="pwModal">
  <div class="box">
    <div style="font-weight:800;margin-bottom:8px">Enter Coach Password</div>
    <input id="pwInput" type="password" style="width:100%;padding:8px;border:1px solid #e5e7eb;border-radius:8px"/>
    <div id="pwMsg" style="color:#ef4444;margin-top:6px;min-height:1.2em"></div>
    <div class="row" style="justify-content:flex-end;margin-top:10px">
      <button id="pwOk" class="btn-green">Unlock</button>
      <button id="pwCancel" class="btn-slate">Cancel</button>
    </div>
  </div>
</div>

<script>
/// @diq:begin [A0] Constants & pure helpers
/** @typedef {{ x:number, y:number }} Pt */
/** @typedef {{ [posId:string]: Pt }} Starts */
/** @typedef {{ [posId:string]: {x:number,y:number,tol:number} }} Targets */
/** @typedef {{ first:boolean, second:boolean, third:boolean }} RunnersOn */
/** @typedef {{
 *   key:string, title:string, desc:string,
 *   starts?:Starts, targets?:Targets,
 *   hit?:Pt, hitType?:'line'|'popup'|'grounder',
 *   batterAdvance?:number,
 *   outs?:0|1|2,
 *   runnersOn?:RunnersOn
 * }} Situation */

/** “enum” of position ids, frozen for safety */
const POS_IDS = Object.freeze(['P','C','1B','2B','SS','3B','LF','CF','RF']);

/** Don’t let defaults accidentally change at runtime */
const DEFAULT_STARTS = Object.freeze({
  P:{x:1500,y:1631},  C:{x:1503,y:2147},
  '1B':{x:1917,y:1461}, '2B':{x:1824,y:1158}, SS:{x:1149,y:1158}, '3B':{x:1119,y:1450},
  LF:{x:742,y:790},  CF:{x:1466,y:482}, RF:{x:2273,y:772}
});
Object.freeze(DEFAULT_STARTS.P); Object.freeze(DEFAULT_STARTS.C);
Object.freeze(DEFAULT_STARTS['1B']); Object.freeze(DEFAULT_STARTS['2B']);
Object.freeze(DEFAULT_STARTS.SS); Object.freeze(DEFAULT_STARTS['3B']);
Object.freeze(DEFAULT_STARTS.LF); Object.freeze(DEFAULT_STARTS.CF); Object.freeze(DEFAULT_STARTS.RF);

const IMG_W=3000, IMG_H=2487;
const DEFAULT_TOL=65;
const HOME_NATIVE = { x:1500, y:2147 };
const BASES_NATIVE = {
  home:{x:1501,y:2032}, first:{x:1903,y:1577}, second:{x:1465,y:1192}, third:{x:1101,y:1630}
};

const TIMER_START_SECS = 60;
let _timerId = null;
let _timerSecs = TIMER_START_SECS;

const Fcopy = o => JSON.parse(JSON.stringify(o));
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const clampInt=(v,min,max)=>{v=Math.floor(Number(v)); if(Number.isNaN(v)) v=min; return clamp(v,min,max);};
// --- Guard to ignore programmatic changes in input handlers
let _muteCoachInputs = false;
function withInputMute(fn){
  _muteCoachInputs = true;
  try { fn(); } finally { _muteCoachInputs = false; }
}

function safeSetText(el, text){ if (el) el.textContent = String(text ?? ''); }
function safeSetValue(el, val){ if (el) el.value = String(val ?? ''); }

const lerp=(a,b,t)=>a+(b-a)*t;
function quadBezier(p0,p1,p2,t){return {x:(1-t)*(1-t)*p0.x+2*(1-t)*t*p1.x+t*t*p2.x,y:(1-t)*(1-t)*p0.y+2*(1-t)*t*p1.y+t*t*p2.y};}

function getSituationByKey(key){ return (SITUATIONS || []).find(s => s.key === key) || null; }

function setTargetNotes(sKey, id, text){
  const s = SITUATIONS.find(x => x.key === sKey); if (!s) return;
  if (!s.targets) s.targets = {};
  const prev = s.targets[id] || {};
  s.targets[id] = { ...prev, notes: String(text || '') };
}

function getTargetNotes(sKey, id){
  const s = SITUATIONS.find(x => x.key === sKey);
  return s?.targets?.[id]?.notes || '';
}

// Add this helper near your other small helpers
function isPostRound(){
  // Only between Phase 1 end and Phase 2 start
  return (
    !coachUnlocked &&
    _roundHasStarted === true &&
    !phase2Active &&
    ( _allTargetsCorrect || (!gameActive && remainingTries === 0) )
  );
}


function snapChipsToTargets(){
  if (!currentSituation || !currentSituation.targets) return;
  POS_IDS.forEach(id=>{
    const t = currentSituation.targets[id];
    if (!t) return;
    const rec = tokens.get(id);
    if (!rec) return;
    rec.pos = { x: Math.round(t.x), y: Math.round(t.y) };
    placeToken(id);
  });
}

function getSeqForCurrent(){
  // Returns sanitized sequence array or empty if disabled
  const raw = (currentSituation && Array.isArray(currentSituation.playSeq))
    ? currentSituation.playSeq
    : [];
  return raw
    .map(s => String(s||'').toUpperCase().trim())
    .filter(s => POS_IDS.includes(s));
}

function showSeqPanel(textHTML){
  if (!seqPanel || !seqBody) return;

  // Build note (if any) from the current situation
  const note = (currentSituation && typeof currentSituation.seqNote === 'string' && currentSituation.seqNote.trim())
    ? `<div style="margin-top:10px;padding:8px;border:1px dashed #cbd5e1;border-radius:8px;background:#f8fafc">
         <div style="font-weight:800;color:#334155;margin-bottom:4px">Coach Note</div>
         <div style="white-space:pre-wrap">${currentSituation.seqNote.trim().replace(/[<>&]/g, s => ({'<':'&lt;','>':'&gt;','&':'&amp;'}[s]))}</div>
       </div>`
    : '';

  seqPanel.classList.remove('hidden');
  seqBody.innerHTML = (textHTML || '') + note;
}

function hideSeqPanel(){
  if (!seqPanel) return;
  seqPanel.classList.add('hidden');
  if (seqBody) seqBody.innerHTML = '';
}

function setChipsSelectable(on){
  tokens.forEach(({el}, id)=>{
    if (!el) return;
    if (on){
      el.classList.add('selectableChip');
      el.style.pointerEvents = 'auto';            // allow clicking chips in Phase 2
    } else {
      el.classList.remove('selectableChip','correctPulse','wrongShake');
      el.style.pointerEvents = '';                // ← remove any inline override
      // Dragging is still governed by canDrag() inside makeChipDraggable()
    }
  });
}

function phase2UpdateHud(){
  // Only show panel if Phase 2 is active AND we allow showing it
  if (!phase2Active || !allowSeqPanel){
    hideSeqPanel();
    return;
  }

  if (!seqOrder.length){
    hideSeqPanel(); // nothing to do if no sequence
    return;
  }

  const next  = seqOrder[seqIndex];
  const done  = seqIndex;
  const total = seqOrder.length;

  const path = seqOrder.map((p,i)=>
    i < done
      ? `<span style="opacity:.5;text-decoration:line-through">${p}</span>`
      : (i === done ? `<b>${p}</b>` : p)
  ).join(' → ');

  showSeqPanel(
    `<div>Step ${Math.min(done+1,total)} of ${total}: select <b>${next || '—'}</b></div>
     <div style="margin-top:6px">Sequence: ${path}</div>`
  );
}

/// @diq:begin Play Sequence Builder (Coach)
/** Ensures array is valid POS_IDS only, uppercased */
function sanitizeSeq(arr){
  return (arr || [])
    .map(s => String(s||'').toUpperCase().trim())
    .filter(s => POS_IDS.includes(s));
}

/** Write to model + repaint builder */
function setPlaySeq(next){
  if (!currentSituation) return;
  currentSituation.playSeq = sanitizeSeq(next);
  renderSeqBuilder();
}

/** Clickable grid for adding steps */
function buildSeqPosGrid(){
  if (!seqPosGrid) return;
  seqPosGrid.innerHTML = '';
  POS_IDS.forEach(id=>{
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'pos-btn';
    btn.textContent = id;
    const group = (['P','C'].includes(id) ? 'Battery' : (['1B','2B','SS','3B'].includes(id) ? 'Infield' : 'Outfield'));
    btn.dataset.group = group;
    btn.addEventListener('click', ()=>{
      const next = (currentSituation.playSeq || []).slice();
      next.push(id);
      setPlaySeq(next);
    });
    seqPosGrid.appendChild(btn);
  });
}

/** Draggable list item (no per-item dragover/drop — handled at list level) */
function makeSeqItem(id, index){
  const li = document.createElement('div');
  li.className = 'seq-item';
  li.draggable = true;
  li.dataset.index = String(index);

  const num = document.createElement('div');
  num.className = 'seq-num';
  num.textContent = String(index + 1);

  const tag = document.createElement('div');
  tag.className = 'seq-tag';
  tag.textContent = id;

  const del = document.createElement('button');
  del.type = 'button';
  del.className = 'seq-remove';
  del.textContent = '❌';
  del.title = 'Remove this step';
  del.addEventListener('click', ()=>{
    const next = (currentSituation.playSeq || []).slice();
    next.splice(index, 1);
    setPlaySeq(next);
  });

  li.appendChild(num);
  li.appendChild(tag);
  li.appendChild(del);

  // Only start/end here; list container handles positioning
  li.addEventListener('dragstart', ()=>{
    li.classList.add('dragging');
  });
  li.addEventListener('dragend', ()=>{
    li.classList.remove('dragging');
  });

  return li;
}

/** Re-render the sequence list and count */
function renderSeqBuilder(){
  if (!seqList || !currentSituation) return;
  const seq = sanitizeSeq(currentSituation.playSeq);
  seqList.innerHTML = '';
  seq.forEach((id, i)=> seqList.appendChild(makeSeqItem(id, i)));
  if (seqCountHud) seqCountHud.textContent = String(seq.length);

  // Keep Phase 2 HUD in sync
  if (typeof updateHud === 'function'){
    if (phase2Active){
      updateHud();
    } else {
      updateHud(Number(scoreVal?.textContent) || 0);
    }
  }
}

/** Enable drag-reorder at the LIST level (robust across browsers) */
function wireSeqListDnDOnce(){
  if (!seqList || seqList._dndWired) return;
  seqList._dndWired = true;

  let ghost = null;

  function ensureGhost(){
    if (!ghost){
      ghost = document.createElement('div');
      ghost.className = 'seq-ghost';
    }
    return ghost;
  }

  function getAfterElement(container, y){
    const items = [...container.querySelectorAll('.seq-item:not(.dragging)')];
    let closest = { offset: Number.NEGATIVE_INFINITY, element: null };
    for (const el of items){
      const rect = el.getBoundingClientRect();
      const offset = y - (rect.top + rect.height / 2);
      if (offset < 0 && offset > closest.offset){
        closest = { offset, element: el };
      }
    }
    return closest.element; // null means append at end
  }

  seqList.addEventListener('dragover', (e)=>{
    e.preventDefault();
    const g = ensureGhost();
    const after = getAfterElement(seqList, e.clientY);
    if (after) seqList.insertBefore(g, after);
    else seqList.appendChild(g);
  });

  seqList.addEventListener('drop', (e)=>{
    e.preventDefault();
    const dragging = seqList.querySelector('.seq-item.dragging');
    if (!dragging) return;

    // Compute new index from ghost position
    const children = [...seqList.children];
    const newIndex = children.indexOf(ghost);
    const oldIndex = Number(dragging.dataset.index);

    // Clean up early so renderSeqBuilder paints a clean list
    if (ghost && ghost.parentNode) ghost.remove();

    if (Number.isInteger(oldIndex) && newIndex >= 0 && oldIndex !== newIndex){
      const next = (currentSituation.playSeq || []).slice();
      const [moved] = next.splice(oldIndex, 1);
      next.splice(newIndex, 0, moved);
      setPlaySeq(next); // re-renders list and renumbers
    } else {
      // No change — just re-render to refresh indices
      renderSeqBuilder();
    }
  });

  seqList.addEventListener('dragend', ()=>{
    if (ghost && ghost.parentNode) ghost.remove();
  });
}


/** Templates */
function applySeqTemplate(val){
  if (!val) return;
  const arr = String(val).split(',').map(s=>s.trim());
  setPlaySeq(arr);
}

/** Wire up builder controls once */
function wireSeqBuilderOnce(){
  if (!seqSubsec) return;
  if (seqSubsec._wired) return;
  seqSubsec._wired = true;

  buildSeqPosGrid();
  renderSeqBuilder();
  wireSeqListDnDOnce();

  if (seqTemplateSel){
    seqTemplateSel.addEventListener('change', ()=>{
      applySeqTemplate(seqTemplateSel.value);
      // reset to placeholder
      seqTemplateSel.value = '';
    });
  }
  if (seqClearBtn){
    seqClearBtn.addEventListener('click', ()=>{
      setPlaySeq([]);
    });
  }

  // Keep the existing overall note behavior
  if (seqNoteInput){
    const syncSeqNote = () => {
      if (!currentSituation) return;
      currentSituation.seqNote = String(seqNoteInput.value || '');
    };
    seqNoteInput.addEventListener('input',  syncSeqNote);
    seqNoteInput.addEventListener('change', syncSeqNote);
  }
}

// Remove any in-progress Phase 2 sequence-throw visualization (ball + trail + RAF)
function cleanupSeqThrowViz(){
  try{ if (_seqAnimRaf){ cancelAnimationFrame(_seqAnimRaf); } }catch{}
  _seqAnimRaf = null;

  if (_seqTrail && _seqTrail.parentNode) _seqTrail.remove();
  _seqTrail = null;

  if (_seqBallEl && _seqBallEl.parentNode) _seqBallEl.remove();
  _seqBallEl = null;
}

function formatSecs(s){
  // Show mm:ss if you'd like; spec only asks for seconds, but this reads nicer.
  const m = Math.floor(s/60), sec = s%60;
  return `${m}:${String(sec).padStart(2,'0')}`;
}

function updateTimerHud(){
  if (!timerVal || !timerBadge) return;
  // Display as seconds with an "s" OR as mm:ss — choose one line below

  // Option A: plain seconds with trailing 's' (matches your HTML shell)
  timerVal.textContent = String(_timerSecs);

  // Option B: mm:ss (then also change the HTML shell to not append 's'):
  // timerVal.textContent = formatSecs(_timerSecs);

  // Visual warning under 10s
  if (_timerSecs <= 10) timerBadge.classList.add('low');
  else timerBadge.classList.remove('low');
}

function stopTimer(){
  if (_timerId){ clearInterval(_timerId); _timerId = null; }
}

function startTimer(seconds = TIMER_START_SECS){
  stopTimer();
  _timerSecs = Math.max(0, seconds|0);
  updateTimerHud();
  _timerId = setInterval(()=>{
    _timerSecs = Math.max(0, _timerSecs - 1);
    updateTimerHud();
    if (_timerSecs === 0){
      // Time's up → behave like tries are exhausted
      if (!coachUnlocked && _roundHasStarted){
        if (phase2Active){
          try{
            // Phase 2: out of time = out of tries → show fail card + animate sequence
            phase2TriesLeft = 0;
            endPhase2(false);
          }catch{}
        } else if (gameActive){
          try{
            // Phase 1: force a final check so rings reveal and round ends
            remainingTries = 1; // makes isFinalTry true inside checkPositions()
            checkPositions();   // will decrement to 0 and run end-of-round logic
          }catch{}
        }
      }
      stopTimer();
    }
  }, 1000);
}



function resetTimer(seconds = TIMER_START_SECS){
  startTimer(seconds);
}

/** Exact match: same length and each pick equals expected in order */
function isExactSequenceMatch(picks, order){
  if (!Array.isArray(picks) || !Array.isArray(order)) return false;
  if (picks.length !== order.length) return false;
  for (let i = 0; i < order.length; i++){
    if (picks[i] !== order[i]) return false;
  }
  return true;
}

function wipePhase2StateUI(){
  // model
  phase2Active    = false;
  allowSeqPanel   = false;
  seqIndex        = 0;
  phase2TriesLeft = PHASE2_MAX_TRIES;
  phase2Picks     = [];
  phase2Locked    = new Set();

  // UI (chips)
  tokens.forEach(({el})=>{
    if (!el) return;
    el.classList.remove('seq-locked','selectableChip','correctPulse','wrongShake');
    el.style.pointerEvents = '';        // restore default clickability
    // remove any pick/index badges and attrs, regardless of variant
    clearChipPickMarker?.(el);          // uses your consolidated remover
    // belt-and-suspenders if you keep older helpers around:
    el.removeAttribute('data-pick-index');
    el.removeAttribute('data-pick-idx');
  });

  // UI (controls/panels/animations)
  hideSeqPanel?.();
  verifySeqBtn?.classList.add('hidden');
  setChipsSelectable?.(false);
  cleanupSeqThrowViz?.();               // remove seq ball + trail, if present

  // HUD
  updateHud?.(0);
}

// NEW: count how many picks are correct in order, consecutively from the start
function getPhase2ConsecutiveCorrect(){
  if (!phase2Active || !Array.isArray(seqOrder) || !seqOrder.length) return 0;
  let i = 0;
  while (i < phase2Picks.length && i < seqOrder.length && phase2Picks[i] === seqOrder[i]) i++;
  return i; // number of correct-in-order picks from the beginning
}

// ----- Phase 2 hygiene: clear all UI + state -----
function phase2ClearAllUI(){
  // data
  phase2Picks = [];
  phase2Locked = new Set();

  // chip visuals (numbers + highlight)
  tokens.forEach(({el})=>{
    if (!el) return;
    clearChipPickMarker(el);     // remove any sequence badge/attr
    el.classList.remove('seq-locked','correctPulse','wrongShake');
  });

  // controls / panel
  if (verifySeqBtn) verifySeqBtn.classList.add('hidden');
  setChipsSelectable(false);
  hideSeqPanel();

  // state flags
  phase2Active = false;
  allowSeqPanel = false;

  // ensure HUD reflects non-phase-2 state (score visible again)
  updateHud(Number(scoreVal?.textContent) || 0);
}

// ===== Sequence marker helpers (consolidated – single source of truth) =====

/** Remove any/all visual sequence markers from one chip element. */
function clearChipPickMarker(el){
  if (!el) return;
  // Remove known attrs
  el.removeAttribute('data-pick');
  el.removeAttribute('data-pick-idx');
  el.removeAttribute('data-pick-index');
  el.removeAttribute('data-seq');
  // Remove known badge nodes
  el.querySelectorAll('.seq-badge, .seqBadge, .pick-badge, .chip-index, [data-role="seq-badge"]').forEach(n => n.remove());
}



/** Add/update a small numeric badge at top-right of chip (1-based). */
function setChipPickIndex(el, n){
  if (!el) return;
  // Start clean
  clearChipPickMarker(el);
  if (!Number.isFinite(n) || n <= 0) return;

  const badge = document.createElement('span');
  badge.className = 'seq-badge';
  badge.setAttribute('data-role', 'seq-badge');
  badge.textContent = String(n);
  Object.assign(badge.style, {
    position: 'absolute',
    right: '-6px',
    top: '-6px',
    minWidth: '16px',
    height: '16px',
    padding: '0 4px',
    borderRadius: '999px',
    fontWeight: '900',
    fontSize: '11px',
    lineHeight: '16px',
    textAlign: 'center',
    color: '#0b1321',
    background: '#f1f5f9',
    border: '1px solid rgba(0,0,0,.25)',
    boxShadow: '0 1px 2px rgba(0,0,0,.25)',
    pointerEvents: 'none',
    userSelect: 'none',
    zIndex: 2
  });

  el.appendChild(badge);
  el.setAttribute('data-pick-idx', String(n));
}




/** Full re-render: wipe all markers, then number 1..N from phase2Picks */
function rerenderPickMarkers(){
  tokens.forEach(({el}) => clearChipPickMarker(el));
  (phase2Picks || []).forEach((pid, i)=>{
    const rec = tokens.get(pid);
    if (rec?.el) setChipPickIndex(rec.el, i + 1);
  });
}




/** Clear the model & visuals of all picks. */
function clearAllPicks(){
  phase2Picks = [];
  tokens.forEach(({el})=>{
    if (!el) return;
    clearChipPickMarker(el);
    el.classList.remove('correctPulse','wrongShake');
  });
}




/// @diq:begin [Phase 2: End & Result Panels]
function endPhase2(success = true) {
  stopTimer();
  // If Phase 2 was never started, just clear & hide
  if (!phase2Active) {
    phase2Active = false;
    allowSeqPanel = false;
    hideSeqPanel();
    if (verifySeqBtn) verifySeqBtn.classList.add('hidden');
    setChipsSelectable(false);
    phase2Locked = new Set();
    phase2Picks  = [];
    tokens.forEach(({el})=>{
      if (!el) return;
      clearChipPickMarker(el);
      el.classList.remove('seq-locked','correctPulse','wrongShake');
      el.style.pointerEvents = '';
    });
    cleanupSeqThrowViz?.();
    return;
  }

  // Stop interaction
  phase2Active = false;
  setChipsSelectable(false);

  if (continueBtn) continueBtn.classList.add('hidden');
  if (verifySeqBtn) verifySeqBtn.classList.add('hidden');

  // Now allow the sequence panel to appear with result info
  allowSeqPanel = true;

  if (success) {
    showSeqSuccessPanel();
  } else {
    phase2TriesLeft = 0;
    showSeqFailPanel();
  }

  // Chips that were locked-in as correct remain highlighted & marked.
  // Everything else should not be clickable anymore.
  tokens.forEach(({el}, id)=>{
    if (!el) return;
    const locked = phase2Locked.has(id);
    if (!locked){
      // non-locked picks lose their marker
      clearChipPickMarker(el);
      el.classList.remove('seq-locked');
    }
  });

  // === NEW: After the panel shows, animate the intended relay path ===
  // We always animate the *intended* sequence (full playSeq), as a teaching moment.
  if (Array.isArray(seqOrder) && seqOrder.length >= 2) {
    setTimeout(() => {
      animateSequenceThrows(seqOrder);
    }, 350);
  }
}

// Treat any badge/attr as "marked"
function chipIsMarked(el){
  return !!(el && (el.hasAttribute('data-pick') || el.querySelector('.seq-badge')));
}

let _seqBallEl = null;
let _seqTrail = null;
let _seqAnimRaf = null;

/** Build (or reuse) the tiny ball used for throw animations */
function ensureSeqBall(){
  if (_seqBallEl && _seqBallEl.parentNode) return _seqBallEl;
  _seqBallEl = document.createElement('div');
  _seqBallEl.className = 'seqBall';
  wrap.appendChild(_seqBallEl);
  return _seqBallEl;
}

/** Build (or reuse) an SVG overlay to draw throw lines, with arrowhead marker */
/** Build (or reuse) an SVG overlay to draw throw lines, with a small arrowhead marker */
function ensureSeqTrail(){
  if (_seqTrail && _seqTrail.parentNode) return _seqTrail;
  _seqTrail = document.createElement('div');
  _seqTrail.className = 'throwTrail';
  const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS,'svg');
  svg.setAttribute('viewBox', `0 0 ${imgRect.width} ${imgRect.height}`);

  // Define a smaller arrowhead marker once (scaled by stroke width)
  const defs = document.createElementNS(svgNS, 'defs');
  const marker = document.createElementNS(svgNS, 'marker');
  marker.setAttribute('id', 'arrowHead');
  marker.setAttribute('markerUnits', 'strokeWidth'); // scale with stroke width
  marker.setAttribute('markerWidth', '4.5');         // smaller base
  marker.setAttribute('markerHeight', '4.5');
  marker.setAttribute('refX', '4.2');                // positions tip at end of path
  marker.setAttribute('refY', '2.25');
  marker.setAttribute('orient', 'auto');

  const arrowPath = document.createElementNS(svgNS, 'path');
  // small triangle; fill inherits line color via currentColor
  arrowPath.setAttribute('d', 'M0,0 L0,4.5 L4.5,2.25 z');
  arrowPath.setAttribute('fill', 'currentColor');
  arrowPath.setAttribute('stroke', 'none');
  marker.appendChild(arrowPath);

  defs.appendChild(marker);
  svg.appendChild(defs);

  _seqTrail.appendChild(svg);
  wrap.appendChild(_seqTrail);
  return _seqTrail;
}



/** Remove temporary ball + trail */
function sizeOverlays(){
  if (!wrap) return;

  // 1) Snapshot new container rect
  const r = wrap.getBoundingClientRect();
  imgRect = { width:r.width, height:r.height, left:r.left, top:r.top };

  // 2) Scale chip size + fonts and scale markers (ball/runner/hit marker)
  updateChipScale();

  // 3) Re-position all chips from native coords
  POS_IDS.forEach(id => placeToken(id));

  // 4) Reposition + resize target rings from model
  if (currentSituation && currentSituation.targets){
    getAllRings().forEach(el => {
      const id  = el.dataset.id;
      const tgt = currentSituation.targets[id];
      if (!tgt) return;
      const css = unitToCss(tgt);
      el.style.left = css.left + 'px';
      el.style.top  = css.top  + 'px';
      const dpx = tolToCssDiameter(Number(tgt.tol) || DEFAULT_TOL, /*allowTiny*/ coachUnlocked);
      el.style.width  = dpx + 'px';
      el.style.height = dpx + 'px';
    });
  }

  // 5) Ball graphics: reset and rebuild SVG to match new viewBox
  if (animReq){ cancelAnimationFrame(animReq); animReq = null; }
  if (ballSvg) ballSvg.innerHTML = '';
  buildBallGraphics(); // also calls syncBallToHit()

  // 6) Reposition coach hit marker (if visible)
  if (hitMarker && currentSituation && currentSituation.hit){
    const css = unitToCss(currentSituation.hit);
    hitMarker.style.left = css.left + 'px';
    hitMarker.style.top  = css.top  + 'px';
  }

  // 7) Repaint static base-runner dots and snap animated runner to base
  renderBaseRunners();
  if (runnerEl && runnerEl.style.display !== 'none'){
    placeRunnerAtBase(runnerLastBase);
  }

  scaleMarkers();

  // Clear any in-progress Phase 2 throw animation after a resize/layout change
  cleanupSeqThrowViz();

  if (phase2Active && ballEl){
    ballEl.style.display = 'block';
    ballEl.style.zIndex = '10';
  }

}


/** Get CSS-space point for a position id, using target (snap) locations */
/** Get CSS-space point for a position id, using the chip’s actual DOM left/top if present. */
function getCssPointForPosId(posId){
  const rec = tokens.get(posId);
  if (rec?.el){
    const x = parseFloat(rec.el.style.left)  || 0;
    const y = parseFloat(rec.el.style.top)   || 0;
    return { x, y };
  }
  // Fallback to target location if the chip isn't built yet
  const tgt = currentSituation?.targets?.[posId];
  return tgt ? nativeToCssPoint({ x: tgt.x, y: tgt.y }) : null;
}


/** Small chip pulse for feedback */
function pulseChip(id){
  const rec = tokens.get(id);
  if (!rec?.el) return;
  rec.el.classList.add('correctPulse');
  setTimeout(()=> rec.el?.classList?.remove('correctPulse'), 260);
}

/** Animate the REAL ball (ballEl) along a straight, optionally offset line from A to B.
 *  Leaves a colored path with a proper triangular arrowhead showing direction. */
function animateThrowLeg(fromPt, toPt, color, visualOffset){
  return new Promise(function(resolve){
    var trail = ensureSeqTrail();
    var svg = trail.querySelector('svg');
    var svgNS = 'http://www.w3.org/2000/svg';

    // ------- per-color arrowhead (inline styles beat the CSS rule) -------
    function getOrMakeMarker(colorStr){
      var safe = String(colorStr || '#111827').toLowerCase().replace(/[^a-z0-9]+/g,'_');
      var id = 'arrowHead_' + safe;
      var m = svg.querySelector('marker#' + id);
      if (m) return m;

      var defs = svg.querySelector('defs') || document.createElementNS(svgNS, 'defs');
      if (!svg.querySelector('defs')) svg.appendChild(defs);

      m = document.createElementNS(svgNS, 'marker');
      m.setAttribute('id', id);
      m.setAttribute('markerUnits', 'strokeWidth'); // scale with stroke
      m.setAttribute('markerWidth', '6');
      m.setAttribute('markerHeight', '6');
      m.setAttribute('refX', '6');                  // tip sits at end
      m.setAttribute('refY', '3');
      m.setAttribute('orient', 'auto');
      // triangle path
      var tri = document.createElementNS(svgNS, 'path');
      tri.setAttribute('d', 'M0,0 L6,3 L0,6 Z');
      tri.style.fill = colorStr;        // INLINE style defeats .throwTrail svg path { fill:none }
      tri.style.stroke = 'none';
      m.appendChild(tri);

      defs.appendChild(m);
      return m;
    }

    var c = color || '#111827';
    var marker = getOrMakeMarker(c);

    // ------- optional perpendicular offset -------
    var off = visualOffset || { x:0, y:0 };
    var A = { x: fromPt.x + off.x, y: fromPt.y + off.y };
    var B = { x: toPt.x   + off.x, y: toPt.y   + off.y };

    // ------- draw leg -------
    var path = document.createElementNS(svgNS, 'path');
    path.setAttribute('d', 'M ' + A.x + ',' + A.y + ' L ' + B.x + ',' + B.y);
    path.setAttribute('marker-end', 'url(#' + marker.id + ')');

    // Inline styles so global CSS can't override
    path.style.stroke = c;
    path.style.fill = 'none';
    path.style.strokeWidth = '3.5';
    path.style.strokeLinecap = 'butt';   // avoid a rounded cap covering the arrow tip
    path.style.strokeLinejoin = 'round';
    path.style.opacity = '.95';

    svg.appendChild(path);

    // ------- animate the ball along the leg -------
    if (ballEl){
      ballEl.style.display = 'block';
      ballEl.style.left = A.x + 'px';
      ballEl.style.top  = A.y + 'px';
      ballEl.style.zIndex = '10';
    }

    var dist = Math.hypot(B.x - A.x, B.y - A.y);
    var duration = clamp(420 + dist * 0.45, 380, 1100);

    var t0 = performance.now();
    function step(now){
      var t = clamp((now - t0) / duration, 0, 1);
      var e = 1 - Math.pow(1 - t, 3);
      if (t < 1){
        if (ballEl){
          ballEl.style.left = (A.x + (B.x - A.x) * e) + 'px';
          ballEl.style.top  = (A.y + (B.y - A.y) * e) + 'px';
        }
        _seqAnimRaf = requestAnimationFrame(step);
      } else {
        if (ballEl){
          ballEl.style.left = B.x + 'px';
          ballEl.style.top  = B.y + 'px';
        }
        resolve();
      }
    }
    _seqAnimRaf = requestAnimationFrame(step);
  });
}


/** Animate throws along the provided order of POS_IDS.
 *  Uses distinct colors and offsets duplicate legs to avoid stacking. */
async function animateSequenceThrows(order){
  try{ if (_seqAnimRaf){ cancelAnimationFrame(_seqAnimRaf); } }catch{}
  _seqAnimRaf = null;

  var pts = (order || [])
    .map(function(id){ return { id:id, pt:getCssPointForPosId(id) }; })
    .filter(function(x){ return !!x.pt; });
  if (pts.length < 2) return;

  var trail = ensureSeqTrail();
  var svg = trail.querySelector('svg');
  svg.setAttribute('viewBox', '0 0 ' + imgRect.width + ' ' + imgRect.height);

  if (ballEl){
    ballEl.style.display = 'block';
    ballEl.style.zIndex = '10';
    ballEl.style.left = pts[0].pt.x + 'px';
    ballEl.style.top  = pts[0].pt.y + 'px';
  }

  var COLORS = [
    '#FF3B30', // bright red
    '#FFCC00', // strong yellow
    '#AF52DE', // purple
    '#5856D6', // indigo
    '#FF2D55', // hot pink/magenta
    '#8E8E93',  // medium-light gray (neutral)
    '#FF9500' // vivid orange
  ];
  var seenPairs = {}; // track duplicates

  pulseChip(pts[0].id);

  var chain = Promise.resolve();
  for (var i = 0; i < pts.length - 1; i++){
    (function(i){
      var a = pts[i];
      var b = pts[i + 1];
      var color = COLORS[i % COLORS.length];

      // Key is undirected pair so A→B and B→A share
      var key = [a.id, b.id].sort().join('|');
      var count = seenPairs[key] || 0;
      seenPairs[key] = count + 1;

      // Compute perpendicular offset
      var dx = b.pt.x - a.pt.x;
      var dy = b.pt.y - a.pt.y;
      var len = Math.sqrt(dx*dx + dy*dy) || 1;
      var nx = -dy / len;
      var ny =  dx / len;
      var offsetPx = 8 * count; // 8px per duplicate
      var vOff = { x: nx * offsetPx, y: ny * offsetPx };

      chain = chain
        .then(function(){ pulseChip(a.id); return animateThrowLeg(a.pt, b.pt, color, vOff); })
        .then(function(){ pulseChip(b.id); return new Promise(r => setTimeout(r, 120)); });
    })(i);
  }

  chain.finally(function(){
    try{ if (_seqAnimRaf){ cancelAnimationFrame(_seqAnimRaf); } }catch{}
    _seqAnimRaf = null;
  });
}



/** Show a simple "success" message inside the Play Sequence card */
function showSeqSuccessPanel(){
  // Prefer the active order; fall back to the situation's playSeq
  const seqArr = (Array.isArray(seqOrder) && seqOrder.length)
    ? seqOrder
    : (currentSituation && Array.isArray(currentSituation.playSeq) ? currentSituation.playSeq : []);
  const seqStr = seqArr.length ? seqArr.join(' \u2192 ') : '—';

  showSeqPanel(`
    <div style="color:#16a34a;font-weight:700">✅ Correct sequence!</div>
    <div class="hint" style="margin-top:6px">Expected: <b>${seqStr}</b></div>
  `);
}



/** Show a "failure" message inside the Play Sequence card */
function showSeqFailPanel() {
  const seqStr = seqOrder.join(' → ') || '—';
  showSeqPanel(`
    <div style="color:#dc2626;font-weight:700">❌ Incorrect sequence</div>
    <div class="hint" style="margin-top:6px">Expected: <b>${seqStr}</b></div>
  `);
}


function wireOnce(){
  if (_wired) return;
  _wired = true;

  // --- everything from your “/* Wiring */” block goes here ---
  if (sitSelect) sitSelect.addEventListener('change', e=> setSituation(e.target.value));
  if (randomSitBtn) randomSitBtn.addEventListener('click', pickRandomSituation);

  if (resetBtn)  resetBtn.addEventListener('click', resetPlayers);
  if (checkBtn)  checkBtn.addEventListener('click', checkPositions);

  if (startBtn)  startBtn.addEventListener('click', ()=>{
    if (!currentSituation) return;

    _roundHasStarted = true;
    allowSeqPanel = false;

    // --- Set game state up front ---
    gameActive = true;
    resetTimer(TIMER_START_SECS);
    remainingTries = MAX_TRIES;
    updateHud(0);
    _allTargetsCorrect = false;

    wipePhase2StateUI();
    if (continueBtn) continueBtn.classList.add('hidden');

    // --- Reset round UI ---
    disableTargetSelection();
    hideTargetPanel();
    if (!coachUnlocked) getAllRings().forEach(el=> el.style.display='none');
    startBtn.disabled = true;
    if (resetBtn) resetBtn.disabled = false;
    if (checkBtn) checkBtn.disabled = false;
    if (checkBtn){ checkBtn.classList.remove('hidden'); }
    setChipsLocked(false);
    syncBallToHit();

    // --- Animate hit + runners ---
    const ht = (currentSituation.hitType) || (hitTypeSel && hitTypeSel.value) || 'line';
    animateHit(ht);

    const advFromSit = (typeof currentSituation.batterAdvance === 'number') ? currentSituation.batterAdvance : null;
    const advFromUI  = advanceSel ? clampInt(advanceSel.value,0,4) : null;
    const advance    = (advFromSit ?? advFromUI ?? mapHitTypeToAdvance(ht));

    liveRunners = normalizeRunnersOn(currentSituation.runnersOn);

    let existingDone = false, batterDone = false;
    let finalExisting = null;
    let batterDest = null;

    animateExistingRunnersAdvance(advance, (finalState)=>{
      finalExisting = finalState;
      existingDone = true;
      maybeFinish();
   });

    animateBatterAdvance(advance, (destBase)=>{
      batterDest = destBase;
      batterDone = true;
      maybeFinish();
    });

    function maybeFinish(){
      if (!existingDone || !batterDone) return;
      liveRunners = normalizeRunnersOn(finalExisting || liveRunners);

      if (batterDest === 'first')        liveRunners.first  = true;
      else if (batterDest === 'second')  liveRunners.second = true;
      else if (batterDest === 'third')   liveRunners.third  = true;

      renderBaseRunners();
      updateRunnersHudFromLive();
    }
  });

  // --- Create a Verify Sequence button in the header row (once) ---
  const actionsRow = document.querySelector('header .header-actions');
  if (!verifySeqBtn){
    verifySeqBtn = document.createElement('button');
    verifySeqBtn.id = 'verifySeqBtn';
    verifySeqBtn.className = 'btn-green hidden';
    verifySeqBtn.textContent = 'Verify Sequence';
    actionsRow.insertBefore(verifySeqBtn, document.getElementById('hud'));
  }

// ===== Small helpers (add once anywhere in <script>) =====
function getCorrectPrefixLen(picks, order){
  const n = Math.min(picks.length, order.length);
  let k = 0;
  for (; k < n; k++){
    if (picks[k] !== order[k]) break;
  }
  return k; // number of leading chips correct & in order
}

// Replace the old lockCorrectPrefix with this:
function lockCorrectPrefix(k){
  // Never reduce already-locked count
  const prev = phase2Locked.size || 0;
  const want = Math.max(prev, Math.max(0, Math.min(k, seqOrder.length)));

  const lockIds = seqOrder.slice(0, want);       // ← lock by the expected order only
  phase2Locked = new Set(lockIds);

  // Update visuals for ALL chips
  tokens.forEach(({el}, id)=>{
    if (!el) return;
    const locked = phase2Locked.has(id);
    clearChipPickMarker(el);
    el.classList.remove('seq-locked','correctPulse','wrongShake');

    if (locked){
      setChipPickIndex(el, lockIds.indexOf(id) + 1);
      el.classList.add('seq-locked');
      el.classList.remove('selectableChip');
      el.style.pointerEvents = 'none';
    } else {
      el.style.pointerEvents = ''; // keep them clickable
    }
  });

  // Keep the model picks trimmed to the locked prefix (helps re-numbering)
  phase2Picks = lockIds.slice();
  rerenderPickMarkers();

  wireSeqBuilderOnce();
}

  // --- Verify Sequence (Phase 2) ---
  verifySeqBtn.addEventListener('click', ()=>{
    if (!phase2Active || !seqOrder.length) return;

    const tooMany  = phase2Picks.length > seqOrder.length;
    const kAttempt = getCorrectPrefixLen(phase2Picks, seqOrder); // how many from the start were correct
    const kPrev    = phase2Locked.size || 0;

    // ✅ Always lock the longest correct prefix (never regress),
    // even if the player over-selected chips this attempt.
    const newK = Math.max(kPrev, kAttempt);
    lockCorrectPrefix(newK);

    // Visual feedback for any extra, unnecessary picks
    if (tooMany){
      phase2Picks.slice(seqOrder.length).forEach(id=>{
        const el = tokens.get(id)?.el;
        if (el){
          el.classList.add('wrongShake');
          setTimeout(()=> el.classList.remove('wrongShake'), 220);
        }
      });
    }

    // Success requires exact match: same length AND same ordered picks.
    const exact = !tooMany && isExactSequenceMatch(phase2Picks, seqOrder);
    if (exact){
      endPhase2(true);
      return;
    }

    // Not exact → consume a try (keep the panel hidden during attempts)
    phase2TriesLeft = Math.max(0, phase2TriesLeft - 1);
    updateHud();
    hideSeqPanel();

    if (phase2TriesLeft === 0){
      endPhase2(false);
    }
  });


  // --- CONTINUE button: start Phase 2, snap chips, hide rings/target panel, hide Check Positions ---
  if (continueBtn) continueBtn.addEventListener('click', ()=>{
    if (!isPostRound()) return;

    phase2Locked = new Set();
    phase2Picks  = [];
    tokens.forEach(({el})=>{
      if (!el) return;
      clearChipPickMarker(el);
      el.classList.remove('seq-locked','correctPulse','wrongShake','selectableChip');
      el.style.pointerEvents = '';
    });

    const seq = getSeqForCurrent();
    if (!seq.length){
      // No play sequence configured → never run Phase 2; hide the button and panel
      continueBtn.classList.add('hidden');
      hideSeqPanel();
      return;
    }

    // Phase 2 setup
    hideTargetPanel();             // hide Selected Target card immediately
    disableTargetSelection();      // stop ring selection in post-round view
    allowSeqPanel = false;         // keep the Play Sequence card hidden during attempts

    // Move chips to their correct targets, then hide the rings (non-coach)
    snapChipsToTargets();
    if (!coachUnlocked) getAllRings().forEach(el => el.style.display = 'none');

    // Hide "Check Positions" during Phase 2
    if (checkBtn){
      checkBtn.classList.add('hidden');
      checkBtn.disabled = true;
    }

    // Start Phase 2 state
    seqOrder = seq;
    seqIndex = 0; // not used in the new "pick then verify" flow, kept for compatibility
    phase2TriesLeft = PHASE2_MAX_TRIES;
    clearAllPicks();     // start fresh
    updateHud();         // show 0/<seq length> in the score HUD
    phase2Active = true;
    resetTimer(TIMER_START_SECS);

    // Always keep the regular ball visible in Phase 2
    if (ballEl){
      ballEl.style.display = 'block';
      ballEl.style.zIndex = '10';
    }

    setChipsSelectable(true);
    updateHud();

    // Show Verify button; keep Play Sequence panel hidden until success/exhaustion
    verifySeqBtn.classList.remove('hidden');
    hideSeqPanel();

    continueBtn.classList.add('hidden');
  });

  if (seqInput){
    const syncSeq = () => {
      if (!currentSituation) return;
      currentSituation.playSeq = String(seqInput.value || '')
        .split(',')
        .map(s => s.toUpperCase().trim())
        .filter(s => POS_IDS.includes(s));
    };
    seqInput.addEventListener('input',  syncSeq);
    seqInput.addEventListener('change', syncSeq);
  }

  if (seqNoteInput){
    const syncSeqNote = () => {
      if (!currentSituation) return;
      currentSituation.seqNote = String(seqNoteInput.value || '');
    };
    seqNoteInput.addEventListener('input',  syncSeqNote);
    seqNoteInput.addEventListener('change', syncSeqNote);
  }


  if (coachBtn) coachBtn.addEventListener('click', ()=>{
    // Always reset the situation when the Coach Tools button is clicked
    resetPlayers();

    if (coachUnlocked){
      setCoachMode(false);
      coachCard.classList.add('hidden');
      setChipsLocked(!gameActive||remainingTries===0);
      getAllRings().forEach(el=>el.style.display='none');
      syncBallToHit();
    } else {
      openPwModal();
    }
  });


  // When the target dropdown changes, sync tolerance + notes
  if (tolTargetSel) {
    tolTargetSel.addEventListener('change', () => {
      syncTolInputsFromModel(tolTargetSel.value);      // existing
      syncTolNotesFromModel(tolTargetSel.value);       // NEW
    });
  }

  // Notes typing -> save to model and re-render if same target is displayed
  if (tolNotes) {
    tolNotes.addEventListener('input', () => {
      if (!currentSituation || _muteCoachInputs) return;
      const id = tolTargetSel?.value || POS_IDS[0];
      setTargetNotes(currentSituation.key, id, tolNotes.value);
      if (_currentSelectedTargetId === id) renderTargetPanel(id);
    });
  }

  if (pwCancel) pwCancel.addEventListener('click', closePwModal);
  if (pwOk)     pwOk.addEventListener('click', tryUnlock);
  if (pwInput)  pwInput.addEventListener('keydown', e=>{ if(e.key==='Enter') tryUnlock(); });

  if (hitTypeSel)  hitTypeSel.addEventListener('change', ()=>{
    if (!currentSituation) return;
    currentSituation.hitType = hitTypeSel.value || 'line';
    if (currentSituation.batterAdvance == null) advanceSel.value = String(mapHitTypeToAdvance(currentSituation.hitType));
  });
  if (advanceSel)  advanceSel.addEventListener('change', ()=>{ if(currentSituation) currentSituation.batterAdvance=clampInt(advanceSel.value,0,4); });
  if (testHitBtn)  testHitBtn.addEventListener('click', ()=> animateHit());

  if (run1B) run1B.addEventListener('change', ()=> setRunnersOn(null, {quiet:false}));
  if (run2B) run2B.addEventListener('change', ()=> setRunnersOn(null, {quiet:false}));
  if (run3B) run3B.addEventListener('change', ()=> setRunnersOn(null, {quiet:false}));

  if (tolNum)        tolNum.addEventListener('input',   () => setTolLive(tolTargetSel.value, tolNum.value));
  if (tolRange)      tolRange.addEventListener('input', () => setTolLive(tolTargetSel.value, tolRange.value));

  if (newSituationBtn)  newSituationBtn.addEventListener('click', addNewSituation);
  if (saveSituationBtn) saveSituationBtn.addEventListener('click', refreshSituationAll);
  if (deleteSituationBtn && typeof deleteCurrentSituation === 'function') deleteSituationBtn.addEventListener('click', deleteCurrentSituation);
  if (resetStartsBtn)   resetStartsBtn.addEventListener('click', resetStartsToDefaults);

  if (outsSelSituation) outsSelSituation.addEventListener('change', e=> setOuts(e.target.value, {quiet:false}));

  if (newTitleInput) {
    newTitleInput.addEventListener('input', () => {
      if (_muteCoachInputs || !currentSituation) return;
      currentSituation.title = newTitleInput.value.trim();
      updateCurrentOptionLabel();
    });
  }

  if (newDescInput) {
    newDescInput.addEventListener('input', () => {
      if (_muteCoachInputs || !currentSituation) return;
      currentSituation.desc = newDescInput.value;
      if (descHud) descHud.textContent = currentSituation.desc || '';
      if (typeof updateDescriptionHudText === 'function') updateDescriptionHudText();
    });
  }

  if (downloadCurrentBtn) downloadCurrentBtn.addEventListener('click', ()=>{
    refreshSituationAll(); // ensure UI → model before exporting
    download('situation-current.json', buildCurrentSituationExport());
  });
  if (downloadAllBtn)     downloadAllBtn.addEventListener('click', ()=>{
    refreshSituationAll();
    download('situations-all.json', buildAllSituationsExport());
  });
  if (copyAllBtn)         copyAllBtn.addEventListener('click', async ()=>{
    refreshSituationAll();
    try{ await navigator.clipboard.writeText(buildAllSituationsExport()); }catch{}
  });

  wireSeqBuilderOnce();
}

/// @diq:begin [A0.1] App state (mutable)
let SITUATIONS = [];
const SITUATIONS_FALLBACK = [];
let currentSituation = null;

let startsMap = {};
let hitsMap   = {};

let gameActive = false;
let remainingTries = 0;
const MAX_TRIES = 3;

let _allTargetsCorrect = false;

let coachUnlocked = false;

let runnerEl = null;
let runnerAnimId = null;
let runnerLastBase = 'home';

let imgRect={width:1,height:1,left:0,top:0};
let CHIP_PX = 36;

let ballSvg=null, ballPath=null, ballEl=null, hitMarker=null;
let animReq=null;

let liveRunners = { first:false, second:false, third:false };
let _animSuppressedBases = new Set();

let _wired = false;

let _roundHasStarted = false;

let phase2Active = false;
let seqOrder = [];     // array of POS_IDS e.g. ['LF','SS','2B','C']
let seqIndex = 0;      // current expected index

const PHASE2_MAX_TRIES = 3;
let phase2TriesLeft = 0;
let allowSeqPanel = false;
let phase2Picks = [];         // array of POS_IDS in the order the user picked
let verifySeqBtn = null;      // created in wireOnce
let phase2Locked = new Set(); // chips locked as correct prefix (GLOBAL)

const Bus = (() => {
  /** @type {Record<string, Set<Function>>} */ const map = {};
  return {
    on(evt, fn){ (map[evt] ||= new Set()).add(fn); return () => map[evt].delete(fn); },
    off(evt, fn){ map[evt]?.delete(fn); },
    emit(evt, payload){ map[evt]?.forEach(fn => { try{ fn(payload); } catch{} }); }
  };
})();

let _currentSelectedTargetId = null;

/// @diq:begin [A0.2] DOM refs
const img=document.getElementById('fieldImg');
const wrap=document.getElementById('wrap');
const targetsLayer=document.getElementById('targetsLayer');
const ballLayer=document.getElementById('ballLayer');

const sitSelect=document.getElementById('sitSelect');
const randomSitBtn = document.getElementById('randomSitBtn');
const startBtn=document.getElementById('startBtn');
const resetBtn=document.getElementById('resetBtn');
const checkBtn=document.getElementById('checkBtn');
const scoreVal=document.getElementById('scoreVal');
const triesVal=document.getElementById('triesVal');
const triesBadge = document.getElementById('triesBadge');
const scoreBadge = document.getElementById('scoreBadge');
const descHud = document.getElementById('descHud');

const tolNotes = document.getElementById('tolNotes');

const targetPanel      = document.getElementById('targetPanel');
const targetPanelTitle = document.getElementById('targetPanelTitle');
const targetPanelBody  = document.getElementById('targetPanelBody');

const continueBtn = document.getElementById('continueBtn');
const seqPanel    = document.getElementById('seqPanel');
const seqBody     = document.getElementById('seqBody');
const seqInput    = document.getElementById('seqInput');
const seqNoteInput = document.getElementById('seqNoteInput');

/* Play Sequence Builder refs */
const seqSubsec      = document.getElementById('seqSubsec');
const seqPosGrid     = document.getElementById('seqPosGrid');
const seqList        = document.getElementById('seqList');
const seqTemplateSel = document.getElementById('seqTemplateSel');
const seqClearBtn    = document.getElementById('seqClearBtn');
const seqCountHud    = document.getElementById('seqCountHud');

const timerBadge = document.getElementById('timerBadge');
const timerVal   = document.getElementById('timerVal');

const coachBtn=document.getElementById('coachBtn');
// Ensure header groups exist and move elements into them for consistent layout

const ensureHeaderGrouping = () => {
  const header = document.querySelector('header');
  if (!header) return;

  // Ensure .header-actions exists to group start/reset/check/hud/coach
  let actions = header.querySelector('.header-actions');
  if (!actions) {
    actions = document.createElement('div');
    actions.className = 'header-actions';
    header.appendChild(actions);
  }

  // Explicit order inside the actions row
  const order = [
    document.getElementById('randomSitBtn'),
    document.getElementById('sitSelect'),
    document.getElementById('descHud'),
    document.getElementById('runnersBadge'),
    document.getElementById('outsHud'),
    document.getElementById('startBtn'),
    document.getElementById('resetBtn'),
    document.getElementById('checkBtn'),
    document.getElementById('continueBtn'),
    document.getElementById('hud'),
    document.getElementById('coachBtn'),
  ];

  order.forEach(el => { if (el) actions.appendChild(el); });

  // Keep <h1> at the very front
  const h1 = header.querySelector('h1');
  if (h1) header.insertBefore(h1, header.firstChild);
};



const coachCard=document.getElementById('coachCard');
const coachStatus=document.getElementById('coachStatus');

const tolTargetSel=document.getElementById('tolTargetSel');
const tolNum=document.getElementById('tolNum');
const tolRange=document.getElementById('tolRange');

const hitTypeSel=document.getElementById('hitTypeSel');
const testHitBtn=document.getElementById('testHitBtn');
const advanceSel=document.getElementById('advanceSel');

const downloadCurrentBtn=document.getElementById('downloadCurrentBtn');
const downloadAllBtn=document.getElementById('downloadAllBtn');
const copyAllBtn=document.getElementById('copyAllBtn');

const pwModal=document.getElementById('pwModal');
const pwInput=document.getElementById('pwInput');
const pwOk=document.getElementById('pwOk');
const pwCancel=document.getElementById('pwCancel');
const pwMsg=document.getElementById('pwMsg');

const newTitleInput   = document.getElementById('newTitleInput');
const newDescInput    = document.getElementById('newDescInput');
const newSituationBtn  = document.getElementById('newSituationBtn');
const saveSituationBtn = document.getElementById('saveSituationBtn');
const deleteSituationBtn = document.getElementById('deleteSituationBtn');
const resetStartsBtn = document.getElementById('resetStartsBtn');
const situationMsg     = document.getElementById('situationMsg');

const outsValHud      = document.getElementById('outsVal');
const outsSelSituation = document.getElementById('outsSelSituation');
const runnersValHud   = document.getElementById('runnersVal');

const run1B = document.getElementById('run1B');
const run2B = document.getElementById('run2B');
const run3B = document.getElementById('run3B');

/// @diq:begin [A0.3] Geometry & scaling (deduped)
function unitToCss(native){ return { left:native.x*(imgRect.width/IMG_W), top:native.y*(imgRect.height/IMG_H) }; }
function cssToUnit(left,top){ return { x:left*(IMG_W/imgRect.width), y:top*(IMG_H/imgRect.height) }; }
function nativeToCssPoint(pt){ const css=unitToCss(pt); return { x:css.left, y:css.top }; }

function updateChipScale(){
  const base = Math.min(imgRect.width, imgRect.height);
  const size = clamp(Math.round(base * 0.056), 10, 36);
  CHIP_PX = size;
  const fz = clamp(Math.round(size * 0.42), 8, 14);
  wrap.style.setProperty('--chip-size', size + 'px');
  wrap.style.setProperty('--chip-font', fz + 'px');
}

function tolToCssDiameter(tol, allowTiny=false){
  const s = Math.min(imgRect.width / IMG_W, imgRect.height / IMG_H);
  const dCss = 2 * tol * s;
  if (allowTiny) return Math.max(6, Math.round(dCss));
  const minByChip = CHIP_PX * 1.8;
  return Math.round(Math.max(dCss, minByChip));
}

/// @diq:begin [A1] Resize & Layout (single source of truth)
/* schedule layout on next frame (avoid resize jank) */
let _resizeRaf = null;
function scheduleLayout(){
  if (_resizeRaf) cancelAnimationFrame(_resizeRaf);
  _resizeRaf = requestAnimationFrame(() => {
    _resizeRaf = null;
    sizeOverlays();
  });
}

/* observe #wrap — reacts to container changes, not just window resize */
let _wrapResizeObserver = null;
function observeWrap(){
  if (!window.ResizeObserver || !wrap) return;
  try{
    if (_wrapResizeObserver) _wrapResizeObserver.disconnect();
    _wrapResizeObserver = new ResizeObserver(() => scheduleLayout());
    _wrapResizeObserver.observe(wrap);
  }catch{}
}

/* global listeners */
window.addEventListener('resize', scheduleLayout);
window.addEventListener('orientationchange', scheduleLayout);

window.addEventListener('resize', updateDescriptionHudText);
window.addEventListener('orientationchange', updateDescriptionHudText);


/// @diq:begin [A2] Marker Scaling (single copy)
// Increased starting sizes; still scale down/up responsively
const BASE_MARKER_SIZES = {
  ball:40,
  runner:50,      // animated batter
  baseRunner:50,  // static on-base runners
  hit:40
};

function uiScale(){
  return Math.min(imgRect.width / IMG_W, imgRect.height / IMG_H);
}

function getBallStrokeWidth(){
  const s = uiScale();
  return clamp(Math.round(3 * s * 1.1), 2, 6);
}

function scaleMarkers(){
  const s = uiScale();
  const sizePx = (base, min=8, max=28) => clamp(Math.round(base * s), min, max);

  wrap.querySelectorAll('.runner .rlabel, .baseRunner .rlabel').forEach(el=>{
    const s = uiScale();
    el.style.fontSize = clamp(Math.round(13 * s * 1.05), 11, 18) + 'px';
  });

  // Ball
  if (ballEl){
    const d = sizePx(BASE_MARKER_SIZES.ball, 8, 26);
    ballEl.style.width  = d + 'px';
    ballEl.style.height = d + 'px';
    const outline = clamp(Math.round(2 * s), 1, 3);
    const drop    = clamp(Math.round(3 * s), 1, 4);
    ballEl.style.boxShadow = `0 0 0 ${outline}px #000, 0 1px ${drop}px rgba(0,0,0,.35)`;
  }

  // Animated batter
  if (runnerEl){
    const d = sizePx(BASE_MARKER_SIZES.runner, 8, 24);
    runnerEl.style.width  = d + 'px';
    runnerEl.style.height = d + 'px';
  }

  // Static + moving base runners
  if (wrap){
    wrap.querySelectorAll('.baseRunner, .movingRunner').forEach(el=>{
      const d = sizePx(BASE_MARKER_SIZES.baseRunner, 12, 48);
      el.style.width  = d + 'px';
      el.style.height = d + 'px';
    });
  }

  if (hitMarker){
    const d = sizePx(BASE_MARKER_SIZES.hit, 10, 28);
    hitMarker.style.width  = d + 'px';
    hitMarker.style.height = d + 'px';
  }
}

/// @diq:begin [A3] Chips (tokens) — core drag/drop
/* Token registry: id -> { el, pos:{x,y} } */
const tokens = new Map();

/* Remove any existing chips */
function clearChips(){
  if (!wrap) return;
  wrap.querySelectorAll('.chip').forEach(n=>n.remove());
  tokens.clear();
}

/* Build 9 draggable chips and place them at the current situation starts */
function buildTokens(){
  clearChips();

  const sKey = (currentSituation && currentSituation.key) || (SITUATIONS[0] && SITUATIONS[0].key);

  POS_IDS.forEach(id=>{
    const el=document.createElement('div');

    const group = (['P','C'].includes(id) ? 'Battery'
                 : (['1B','2B','SS','3B'].includes(id) ? 'Infield' : 'Outfield'));

    el.className = `chip ${group}`;
    el.textContent = id;
    wrap.appendChild(el);

    // pick a start from saved map (if any), else DEFAULT_STARTS
    const start = sKey ? getStartFor(sKey,id) : DEFAULT_STARTS[id];

    tokens.set(id, { el, pos: Fcopy(start) });
    placeToken(id);
    makeChipDraggable(el,id);
  });
}

/* Position a single chip according to its native pos -> CSS px */
function placeToken(id){
  const rec = tokens.get(id);
  if (!rec || !rec.pos || !rec.el) return;   // safe if buildTokens hasn't run yet
  const css = unitToCss(rec.pos);
  rec.el.style.left = css.left + 'px';
  rec.el.style.top  = css.top  + 'px';
}

/* Can the user drag chips right now? */
function canDrag(){
  return coachUnlocked || (gameActive && remainingTries > 0);
}

/* Basic pointer-driven dragging (writes native coords back to tokens map) */
function makeChipDraggable(el,id){
  let drag=null;

  // --- drag for Phase 1 / coach ---
  el.addEventListener('pointerdown', e=>{
    if (!canDrag()) return;
    e.preventDefault();
    el.setPointerCapture(e.pointerId);

    const rec = tokens.get(id);
    const css = unitToCss(rec.pos);

    drag = { cx:e.clientX, cy:e.clientY, left:css.left, top:css.top };

    const onMove = (e2)=>{
      if (!drag) return;
      const left = drag.left + (e2.clientX - drag.cx);
      const top  = drag.top  + (e2.clientY - drag.cy);
      el.style.left = left + 'px';
      el.style.top  = top  + 'px';
      const native = cssToUnit(left, top);
      tokens.get(id).pos = { x: native.x, y: native.y };
    };

    const onUp = ()=>{
      window.removeEventListener('pointermove', onMove);
      drag = null;
    };

    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp, { once:true });
  });

  el.addEventListener('click', ()=>{
    if (!phase2Active) return;
    if (!seqOrder || !seqOrder.length) return;

    // Don’t allow toggling locked (already-correct) chips
    if (phase2Locked.has(id)) return;

    const idx = phase2Picks.indexOf(id);

    if (idx === -1){
      // ✅ Allow selecting beyond required count; verification will fail if length mismatches
      phase2Picks.push(id);
      setChipPickIndex(el, phase2Picks.length);
    } else {
      // Deselect this chip and renumber visible badges
      phase2Picks.splice(idx, 1);
      clearChipPickMarker(el);
      rerenderPickMarkers();
    }

    // Keep the Play Sequence panel hidden until success/exhaustion
    hideSeqPanel();
  });


}

/// @diq:begin [A4] Targets (rings)
function getRingEl(id){ return wrap.querySelector(`.tgt[data-id="${id}"]`); }
function getAllRings(){ return Array.from(wrap.querySelectorAll('.tgt')); }
function buildTargets(){
  getAllRings().forEach(n=>n.remove());
  const t=currentSituation.targets||{};
  Object.entries(t).forEach(([id,pt])=>{
    const ring=document.createElement('div');
    ring.className='tgt'; ring.dataset.id = id;
    const css=unitToCss(pt);
    ring.style.left=css.left+'px'; ring.style.top =css.top +'px';
    const label=document.createElement('span');
    label.className='tgt-label'; label.textContent=id;
    ring.appendChild(label);
    const tol = Number(pt.tol) || DEFAULT_TOL;
    const dpx = tolToCssDiameter(tol, coachUnlocked);
    ring.style.width  = dpx + 'px';
    ring.style.height = dpx + 'px';
    if (coachUnlocked){
      ring.style.display='block';
      ring.classList.add('show-label','draggable'); ring.classList.remove('locked');
      makeTargetDraggable(ring,id);
    } else {
      ring.style.display='none';
      ring.classList.remove('show-label','draggable'); ring.classList.add('locked');
    }
    wrap.appendChild(ring);
  });
}
function makeTargetDraggable(el,id){
  let drag=null;
  el.addEventListener('pointerdown',e=>{
    if(!coachUnlocked) return;
    e.preventDefault();
    el.setPointerCapture(e.pointerId);
    drag={cx:e.clientX,cy:e.clientY,left:parseFloat(el.style.left),top:parseFloat(el.style.top)};
    window.addEventListener('pointermove',onMove);
    window.addEventListener('pointerup',onUp,{once:true});
  });
  function onMove(e){
    if(!drag) return;
    const left=drag.left+(e.clientX-drag.cx);
    const top =drag.top +(e.clientY-drag.cy);
    el.style.left=left+'px'; el.style.top=top+'px';
    const pt=cssToUnit(left,top);
    setTargetFor(currentSituation.key,id,pt,currentSituation.targets?.[id]?.tol ?? DEFAULT_TOL);
  }
  function onUp(){ window.removeEventListener('pointermove',onMove); drag=null; }
}

function renderTargetPanel(id){
  if (!targetPanel || !targetPanelTitle || !targetPanelBody) return;
  _currentSelectedTargetId = id;

  targetPanel.classList.remove('hidden');
  targetPanelTitle.textContent = `Selected Target: ${id}`;

  const notes = getTargetNotes(currentSituation.key, id);
  targetPanelBody.innerHTML = notes
    ? `<div>${String(notes).replace(/\n/g, '<br>')}</div>`
    : `<div class="hint">No notes for ${id}</div>`;
}

function showTargetInstruction(){
  if (!targetPanel || !targetPanelTitle || !targetPanelBody) return;
  _currentSelectedTargetId = null;

  targetPanel.classList.remove('hidden');
  targetPanelTitle.textContent = `Selected Target`;
  targetPanelBody.innerHTML = `<div class="hint">Select a target ring on the field to view its notes.</div>`;
  targetPanelBody.classList.add('show-instruction');
}

/** Enable click-to-select for rings (used only after last try) */
function enableTargetSelection(){
  getAllRings().forEach(ring=>{
    ring.classList.add('selectable');           // visual affordance
    ring.addEventListener('click', onRingClick);
  });

  // Always show the instruction card when selection turns on (non-coach)
  if (isPostRound()) {
    if (typeof showTargetInstruction === 'function') {
      showTargetInstruction();                  // ← ensures "Select a target ring..." is visible now
    } else if (typeof showTargetPanel === 'function') {
      showTargetPanel();
    }
  }
}


/** Disable click-to-select for rings and forget the current selection */
function disableTargetSelection(){
  getAllRings().forEach(ring=>{
    ring.classList.remove('selectable');
    ring.removeEventListener('click', onRingClick);
  });
  _currentSelectedTargetId = null;
}

/** Click handler for a ring; shows panel only when game is over (non-coach mode) */
function onRingClick(e){
  if (isPostRound()){
    const id = e.currentTarget?.dataset?.id;
    if (id) {
      renderTargetPanel(id);
      targetPanelBody.classList.remove('show-instruction');
    }
  }
}


/** Panel visibility helpers */
function showTargetPanel(){ if (targetPanel) targetPanel.classList.remove('hidden'); }
function hideTargetPanel(){ if (targetPanel) targetPanel.classList.add('hidden'); }

/// @diq:begin [A5] Runners & Outs
function normalizeRunnersOn(obj){ const src=obj||{}; return { first:!!src.first, second:!!src.second, third:!!src.third }; }
function runnersStateToArray(r){ const out=[]; if(r.first)out.push('1B'); if(r.second)out.push('2B'); if(r.third)out.push('3B'); return out; }
function getRunnersFromCheckboxes(){ return { first:!!(run1B&&run1B.checked), second:!!(run2B&&run2B.checked), third:!!(run3B&&run3B.checked) }; }
function updateRunnersHudFromLive(){
  if (!runnersValHud) return;
  // Show the runners defined by the situation (static), not the live/animated state
  const baseSource = (currentSituation && currentSituation.runnersOn)
    ? normalizeRunnersOn(currentSituation.runnersOn)
    : normalizeRunnersOn(liveRunners);
  const arr = runnersStateToArray(baseSource);
  runnersValHud.textContent = arr.length ? arr.join(',') : '—';
}
function setRunnersOn(next,{quiet=true}={}){
  if (!currentSituation) return;
  const newState = next ? normalizeRunnersOn(next) : normalizeRunnersOn(getRunnersFromCheckboxes());
  currentSituation.runnersOn = { ...newState };
  if (!gameActive) liveRunners = { ...newState };
  if (run1B&&run2B&&run3B){ run1B.checked=!!newState.first; run2B.checked=!!newState.second; run3B.checked=!!newState.third; }
  updateRunnersHudFromLive();
  renderBaseRunners();
  scaleMarkers();
  if (!quiet && situationMsg){ situationMsg.textContent='Runners updated'; setTimeout(()=>situationMsg.textContent='',900); }
}
function setOuts(value,{quiet=true}={}){
  if (!currentSituation) return;
  const v = clampInt(value,0,2);
  currentSituation.outs = v;
  if (outsValHud) outsValHud.textContent = String(v);
  if (outsSelSituation && outsSelSituation.value !== String(v)) outsSelSituation.value = String(v);
  if (!quiet && situationMsg){ situationMsg.textContent='Outs updated'; setTimeout(()=>{situationMsg.textContent='';},900); }
}
/* draw/remove base runners  */
function renderBaseRunners(state, exclude = new Set()){
  // Merge explicit excludes + global suppression
  const blocked = new Set([...exclude, ..._animSuppressedBases]);

  // Only remove static dots; keep animated movers alive
  if (wrap) wrap.querySelectorAll('.baseRunner:not(.movingRunner)').forEach(n=>n.remove());

  const r = state ? normalizeRunnersOn(state) : normalizeRunnersOn(liveRunners);

  const add=(baseName)=>{
    if (blocked.has(baseName)) return; // skip bases we’re animating
    const pos=BASES_NATIVE[baseName]; if(!pos||!wrap) return;
    const m=document.createElement('div');
    m.className='baseRunner';
    m.dataset.base = baseName;
    const css=unitToCss(pos);
    m.style.left=css.left+'px';
    m.style.top =css.top +'px';
    wrap.appendChild(m);
  };

  if (r.first)  add('first');
  if (r.second) add('second');
  if (r.third)  add('third');

  if (typeof scaleMarkers === 'function') scaleMarkers();
}
function advanceRunnersState(state,bases){
  bases = clampInt(bases,0,3);
  const r = normalizeRunnersOn(state);
  if (bases<=0) return {...r};
  const occ=[]; if(r.first)occ.push(1); if(r.second)occ.push(2); if(r.third)occ.push(3);
  occ.sort((a,b)=>b-a);
  const dest={1:false,2:false,3:false};
  for(const b of occ){ const nb=b+bases; if (nb<4) dest[nb]=true; }
  return { first:!!dest[1], second:!!dest[2], third:!!dest[3] };
}

/// @diq:begin [A6] Ball & Hit
function buildBallGraphics(){
  ballLayer.innerHTML = '';
  const svgNS='http://www.w3.org/2000/svg';
  const svg=document.createElementNS(svgNS,'svg');
  svg.setAttribute('viewBox',`0 0 ${imgRect.width} ${imgRect.height}`);
  ballSvg=svg; ballLayer.appendChild(svg);
  if (!ballEl){
    ballEl=document.createElement('div');
    ballEl.className='ball'; ballEl.style.display='none';
    wrap.appendChild(ballEl);
    makeBallDraggable(ballEl);
  }
  syncBallToHit();
}
function ensureDefaultHit(){
  if (!currentSituation) return;
  if (!currentSituation.hit || isNaN(currentSituation.hit.x) || isNaN(currentSituation.hit.y)){
    currentSituation.hit = { x:1500, y:900 };
  }
}
function syncBallToHit(){
  if (!ballEl || !currentSituation) return;
  ensureDefaultHit();
  const css=unitToCss(currentSituation.hit);
  ballEl.style.left=css.left+'px'; ballEl.style.top=css.top+'px';
  ballEl.style.display = (coachUnlocked || gameActive || phase2Active) ? 'block' : 'none';
  ballEl.classList.toggle('locked', !coachUnlocked);
}
function makeBallDraggable(el){
  let drag=null;
  el.addEventListener('pointerdown',e=>{
    if (!coachUnlocked) return;
    e.preventDefault(); el.setPointerCapture(e.pointerId);
    drag={cx:e.clientX,cy:e.clientY,left:parseFloat(el.style.left)||0, top:parseFloat(el.style.top)||0};
    window.addEventListener('pointermove',onMove);
    window.addEventListener('pointerup',onUp,{once:true});
  });
  function onMove(e){
    if(!drag) return;
    const left=drag.left+(e.clientX-drag.cx), top=drag.top+(e.clientY-drag.cy);
    el.style.left=left+'px'; el.style.top=top+'px';
    const pt=cssToUnit(left,top);
    if(currentSituation) currentSituation.hit={ x:Math.round(pt.x), y:Math.round(pt.y) };
  }
  function onUp(){ window.removeEventListener('pointermove',onMove); drag=null; }
}
function placeHitMarker(){
  if (hitMarker){ hitMarker.remove(); hitMarker=null; }
  if (!coachUnlocked) return;
  ensureDefaultHit();
  const css=unitToCss(currentSituation.hit);
  hitMarker=document.createElement('div');
  hitMarker.className='hitTarget'; hitMarker.style.left=css.left+'px'; hitMarker.style.top=css.top+'px';
  wrap.appendChild(hitMarker); makeHitMarkerDraggable(hitMarker);
}
function makeHitMarkerDraggable(el){
  let drag=null;
  el.addEventListener('pointerdown',e=>{
    if (!coachUnlocked) return;
    e.preventDefault(); el.setPointerCapture(e.pointerId);
    drag={cx:e.clientX,cy:e.clientY,left:parseFloat(el.style.left),top:parseFloat(el.style.top)};
    window.addEventListener('pointermove',onMove);
    window.addEventListener('pointerup',onUp,{once:true});
  });
  function onMove(e){
    if(!drag) return;
    const left=drag.left+(e.clientX-drag.cx), top=drag.top+(e.clientY-drag.cy);
    el.style.left=left+'px'; el.style.top=top+'px';
    const pt=cssToUnit(left,top);
    currentSituation.hit={ x:Math.round(pt.x), y:Math.round(pt.y) };
    syncBallToHit();
  }
  function onUp(){ window.removeEventListener('pointermove',onMove); drag=null; }
}
function mapHitTypeToAdvance(hitType){
  switch((hitType||'').toLowerCase()){
    case 'grounder': return 1;
    case 'line':     return 2;
    case 'popup':    return 0;
    default:         return 1;
  }
}
function animateHit(style){
  const sit=currentSituation; if(!sit) return;
  ensureDefaultHit(); style = style || sit.hitType || 'line';
  if (ballSvg) ballSvg.innerHTML='';
  const startCss=nativeToCssPoint(HOME_NATIVE), endCss=nativeToCssPoint(sit.hit);
  const svgNS='http://www.w3.org/2000/svg';
  if (style==='line' || style==='grounder'){
    ballPath=document.createElementNS(svgNS,'line');
    Object.entries({x1:startCss.x,y1:startCss.y,x2:endCss.x,y2:endCss.y}).forEach(([k,v])=>ballPath.setAttribute(k,v));
    ballPath.setAttribute('stroke','#0ea5e9');
    ballPath.setAttribute('stroke-width', String(getBallStrokeWidth()));
    if (style==='grounder') ballPath.setAttribute('stroke-dasharray','8 8');
    ballSvg.appendChild(ballPath);
  } else {
    const midX=(startCss.x+endCss.x)/2, midY=(startCss.y+endCss.y)/2;
    const curveUp = Math.max(90, Math.hypot(endCss.x - startCss.x, endCss.y - startCss.y) * 0.36); // higher arc
    const ctrl={x:midX,y:midY-curveUp};
    const d=`M ${startCss.x},${startCss.y} Q ${ctrl.x},${ctrl.y} ${endCss.x},${endCss.y}`;
    ballPath=document.createElementNS(svgNS,'path');
    ballPath.setAttribute('d',d); ballPath.setAttribute('fill','none');
    ballPath.setAttribute('stroke','#0ea5e9');
    ballPath.setAttribute('stroke-width', String(getBallStrokeWidth()));
    ballSvg.appendChild(ballPath);
  }
  ballEl.style.left=`${startCss.x}px`; ballEl.style.top=`${startCss.y}px`; ballEl.style.display='block';
  const dist=Math.hypot(endCss.x-startCss.x,endCss.y-startCss.y);
  const duration = clamp(1200 + dist * 0.90, 1500, 3200); // slower + smoother
  let t0=performance.now(); if (animReq) cancelAnimationFrame(animReq);
  const p0={x:startCss.x,y:startCss.y}, p2={x:endCss.x,y:endCss.y};
  const popupCtrl=(()=>{const midX=(startCss.x+endCss.x)/2, midY=(startCss.y+endCss.y)/2;
    const curveUp = Math.max(90, Math.hypot(endCss.x - startCss.x, endCss.y - startCss.y) * 0.36); // higher arc
    return {x:midX,y:midY-curveUp};})();
  function step(now){
    const t=clamp((now-t0)/duration,0,1);
    const pos=(style==='popup')?quadBezier(p0,popupCtrl,p2,t):{x:lerp(p0.x,p2.x,t),y:lerp(p0.y,p2.y,t)};
    ballEl.style.left=`${pos.x}px`; ballEl.style.top=`${pos.y}px`;
    if (t<1) animReq=requestAnimationFrame(step);
    else { if (ballSvg) ballSvg.innerHTML=''; animReq=null; if (ballEl) ballEl.style.display='block'; }
  }
  animReq=requestAnimationFrame(step);
}
function ensureRunner(){
  if (!runnerEl){
    runnerEl = document.createElement('div');
    runnerEl.className = 'runner';
    runnerEl.style.display = 'none';

    // Add label element inside (counter-rotated via CSS)
    const lab = document.createElement('span');
    lab.className = 'rlabel';
    lab.textContent = 'B'; // Batter when moving
    runnerEl.appendChild(lab);

    wrap.appendChild(runnerEl);
  }
}
function placeRunnerAtBase(base){
  ensureRunner();
  runnerLastBase = base;

  const pt = BASES_NATIVE[base] || BASES_NATIVE.home;
  const css = unitToCss(pt);

  runnerEl.style.left = css.left + 'px';
  runnerEl.style.top  = css.top  + 'px';
  runnerEl.style.display = 'block';

  // Label B1/B2/B3 on base; hide on home
  const lab = runnerEl.querySelector('.rlabel');
  if (lab){
    lab.textContent =
      base === 'first'  ? 'B1' :
      base === 'second' ? 'B2' :
      base === 'third'  ? 'B3' : 'B';
  }
}
function hideRunner(){ if (runnerEl) runnerEl.style.display='none'; runnerLastBase='home'; }
function animateBatterAdvance(basesAdvanced, onDone){
  ensureRunner();
  if (runnerAnimId){ cancelAnimationFrame(runnerAnimId); runnerAnimId=null; }

  // Normalize + clamp
  basesAdvanced = clampInt(basesAdvanced, 0, 4);

  // If OUT (0 bases), show a short run toward 1B and stop (to visualize the throw-out)
  if (basesAdvanced === 0){
    const fromCss = nativeToCssPoint(BASES_NATIVE['home']);
    const toCss   = nativeToCssPoint(BASES_NATIVE['first']);

    // Place runner at home to start
    runnerEl.style.left = fromCss.x + 'px';
    runnerEl.style.top  = fromCss.y + 'px';
    runnerEl.style.display = 'block';
    runnerLastBase = 'home';

    // Stop ~80% of the way to 1B (tweak if you want)
    const stopT = 0.80;
    const midX  = lerp(fromCss.x, toCss.x, stopT);
    const midY  = lerp(fromCss.y, toCss.y, stopT);

    const dist = Math.hypot(toCss.x - fromCss.x, toCss.y - fromCss.y) * stopT;
    const duration = clamp(700 + dist * 0.55, 600, 1400);

    let t0 = performance.now();
    const step = (now) => {
      const t = clamp((now - t0) / duration, 0, 1);
      const e = 1 - Math.pow(1 - t, 3); // ease-out
      runnerEl.style.left = lerp(fromCss.x, midX, e) + 'px';
      runnerEl.style.top  = lerp(fromCss.y, midY, e) + 'px';
      runnerEl.style.display = 'block';
      if (t < 1){
        runnerAnimId = requestAnimationFrame(step);
      } else {
        // Stays visible short of 1B; not credited as reaching first
        runnerLastBase = 'home'; // keep model as not-on-base
        if (typeof onDone === 'function') onDone('home');
      }
    };
    runnerAnimId = requestAnimationFrame(step);
    return;
  }

  // Path of bases (index is "bases moved")
  const path=['home','first','second','third','home'];
  const legs=path.slice(0, Math.min(4,basesAdvanced)+1);

  placeRunnerAtBase(legs[0]);
  let legIdx=0;

  const runLeg=()=>{
    if (legIdx>=legs.length-1){
      // Finished
      const destBase = legs[legs.length-1];      // first/second/third/home
      runnerLastBase = destBase;
      if (typeof onDone === 'function') onDone(destBase);
      return;
    }
    const fromName=legs[legIdx], toName=legs[legIdx+1];
    const fromCss=nativeToCssPoint(BASES_NATIVE[fromName]);
    const toCss  =nativeToCssPoint(BASES_NATIVE[toName]);
    const dist=Math.hypot(toCss.x-fromCss.x,toCss.y-fromCss.y);
    const duration=clamp(700+dist*0.55, 800, 1600);

    let t0=performance.now();
    const step=(now)=>{
      const t=clamp((now-t0)/duration,0,1);
      const e=1-Math.pow(1-t,3);
      runnerEl.style.left=lerp(fromCss.x,toCss.x,e)+'px';
      runnerEl.style.top =lerp(fromCss.y,toCss.y,e)+'px';
      runnerEl.style.display='block';
      if (t<1) runnerAnimId=requestAnimationFrame(step);
      else { runnerLastBase=toName; legIdx++; runLeg(); }
    };
    runnerAnimId=requestAnimationFrame(step);
  };
  runLeg();
}


const BASE_ORDER = ['first', 'second', 'third', 'home'];

/**
 * Animate a runner that starts on a base (first/second/third) forward `advance` bases.
 * Returns a Promise that resolves when this runner's animation finishes.
 */
function animateExistingRunnerFrom(baseName, advance){
  return new Promise(resolve=>{
    // Nothing to do
    const startIdx = BASE_ORDER.indexOf(baseName);
    if (startIdx < 0 || advance <= 0) return resolve();

    // Remove the static dot for this base so we don't double-draw
    const toRemove = wrap.querySelector(`.baseRunner[data-base="${baseName}"]`);
    if (toRemove) toRemove.remove();

    // Create a moving element (reuse .baseRunner styling)
    const mover = document.createElement('div');
    mover.className = 'movingRunner';
    mover.style.position = 'absolute';
    mover.style.transform = 'translate(-50%,-50%)';
    wrap.appendChild(mover);

    // Let it scale like other markers
    if (typeof scaleMarkers === 'function') scaleMarkers();

    // Build its path across legs
    const destIdx = Math.min(startIdx + advance, BASE_ORDER.length - 1); // up to "home"
    const legs = BASE_ORDER.slice(startIdx, destIdx + 1); // e.g. ['first','second','third'] (or 'home')

    // Place at starting base
    const startCss = nativeToCssPoint(BASES_NATIVE[legs[0]]);
    mover.style.left = startCss.x + 'px';
    mover.style.top  = startCss.y + 'px';
    mover.style.display = 'block';

    let leg = 0, animId=null;

    const runLeg = ()=>{
      if (leg >= legs.length - 1){
        // If finished on "home", remove; otherwise we’ll later redraw statically via renderBaseRunners
        if (mover && mover.parentNode) mover.remove();
        return resolve();
      }
      const fromName = legs[leg];
      const toName   = legs[leg + 1];
      const fromCss  = nativeToCssPoint(BASES_NATIVE[fromName]);
      const toCss    = nativeToCssPoint(BASES_NATIVE[toName]);
      const dist     = Math.hypot(toCss.x - fromCss.x, toCss.y - fromCss.y);

      // Match your slower, smooth feel
      const duration = clamp(700 + dist * 0.55, 800, 1600);

      let t0 = performance.now();
      const step = (now)=>{
        const t = clamp((now - t0) / duration, 0, 1);
        const e = 1 - Math.pow(1 - t, 3); // smooth ease-out
        mover.style.left = lerp(fromCss.x, toCss.x, e) + 'px';
        mover.style.top  = lerp(fromCss.y, toCss.y, e) + 'px';
        if (t < 1) animId = requestAnimationFrame(step);
        else { leg++; runLeg(); }
      };
      animId = requestAnimationFrame(step);
    };

    runLeg();
  });
}

/**
 * Animate all existing runners (first/second/third) forward `advance` bases in parallel.
 * Calls onDone(finalState) when all have finished (finalState excludes batter).
 */
function animateExistingRunnersAdvance(advance, onDone){
  const start = normalizeRunnersOn(liveRunners);

  const movers = [];
  if (start.first)  movers.push('first');
  if (start.second) movers.push('second');
  if (start.third)  movers.push('third');

  if (movers.length === 0){
    const finalState = advanceRunnersState(start, advance);
    if (typeof onDone === 'function') onDone(finalState);
    return;
  }

  // Suppress the starting bases for movers (no static dot while they run)
  movers.forEach(b => _animSuppressedBases.add(b));

  // Initial paint while suppressed (so their start dots disappear immediately)
  renderBaseRunners(start);

  // Animate all movers
  Promise.all(movers.map(b => animateExistingRunnerFrom(b, advance)))
    .then(()=>{
      // Compute final state and clear suppression
      const finalState = advanceRunnersState(start, advance);
      movers.forEach(b => _animSuppressedBases.delete(b));

      // Repaint final positions (no ghosts)
      renderBaseRunners(finalState);

      if (typeof onDone === 'function') onDone(finalState);
    });
}

/// @diq:begin [A7] Coach tools & visibility
const CALIB_PASSWORD='coach';
function applyCoachVisibility(){
  coachCard.classList.toggle('hidden', !coachUnlocked);
  getAllRings().forEach(el=> el.style.display = coachUnlocked ? 'block' : 'none');

  // Single-ball model in coach mode: remove the orange hit marker if present
  if (hitMarker){ hitMarker.remove(); hitMarker = null; }

  // Always show the white ball; draggable when coach is unlocked
  if (ballEl){
    ballEl.style.display = (coachUnlocked || gameActive) ? 'block' : 'none';
    ballEl.classList.toggle('locked', !coachUnlocked);  // unlocked in coach mode
    ballEl.style.zIndex = '10';                         // keep on top of runners/chips
  }

  syncBallToHit();
}

function setChipsLocked(locked){ tokens.forEach(({el})=> el.classList.toggle('locked', locked && !coachUnlocked)); }
function updateHud(scoreCount){
  // --- helper: "Score: <b><span id='scoreVal'>n</span>/<den></b>" ---
  function setScoreDisplay(n, den){
    if (scoreVal) scoreVal.textContent = String(n);
    if (scoreBadge){
      const b = scoreBadge.querySelector('b');
      if (!b) return;
      const sv = b.querySelector('#scoreVal');
      if (!sv) return;

      // ensure the text node immediately after #scoreVal is "/<den>"
      let node = sv.nextSibling;
      if (!node || node.nodeType !== Node.TEXT_NODE){
        while (node){ const next = node.nextSibling; b.removeChild(node); node = next; }
        b.appendChild(document.createTextNode('/' + den));
      } else {
        node.textContent = '/' + den;
      }
    }
  }

  // --- Phase 2 visibility rule for SCORE (hide for players) ---
  const hideScoreForPhase2 = (phase2Active && !coachUnlocked);
  if (scoreBadge) scoreBadge.style.display = hideScoreForPhase2 ? 'none' : '';

  if (!hideScoreForPhase2){
    // Show score in Phase 1 (9 positions) OR in Coach mode during Phase 2
    if (phase2Active){
      // Coach can see Phase 2 progress (consecutive-correct prefix)
      const total = Array.isArray(seqOrder) ? seqOrder.length : 0;
      const good  = (typeof getPhase2ConsecutiveCorrect === 'function')
        ? getPhase2ConsecutiveCorrect()
        : 0;
      setScoreDisplay(good, total);

      if (scoreBadge){
        const pct = total ? (good / total) : 0;
        const state = pct >= 2/3 ? 'green' : (pct >= 1/3 ? 'yellow' : 'red');
        setBadgeState(scoreBadge, state, 'score');
      }
    } else {
      // Phase 1 score (0..9)
      const n = (typeof scoreCount === 'number') ? scoreCount : (Number(scoreVal?.textContent) || 0);
      setScoreDisplay(n, 9);
      if (scoreBadge){
        const pct = n / 9;
        const state = pct >= 2/3 ? 'green' : (pct >= 1/3 ? 'yellow' : 'red');
        setBadgeState(scoreBadge, state, 'score');
      }
    }
  }

  // --- Tries HUD (unchanged semantics) ---
  let triesLabel = '';
  let triesState = 'green';

  if (coachUnlocked) {
    triesLabel = '∞';
  } else if (phase2Active) {
    const t = Math.max(0, phase2TriesLeft);
    triesLabel = `${t}/${PHASE2_MAX_TRIES}`;
    triesState = (t >= 2) ? 'green' : (t === 1 ? 'yellow' : 'red');
  } else {
    const t = gameActive ? remainingTries : MAX_TRIES;
    triesLabel = `${t}/${MAX_TRIES}`;
    triesState = (t >= 2) ? 'green' : (t === 1 ? 'yellow' : 'red');
  }

  if (triesVal) triesVal.textContent = triesLabel;
  if (triesBadge) setBadgeState(triesBadge, triesState, 'tries');
}


function setBadgeState(el, state /* 'green'|'yellow'|'red' */, base){
  if (!el) return;
  el.classList.remove(`${base}-green`, `${base}-yellow`, `${base}-red`);
  el.classList.add(`${base}-${state}`);
}

function setCoachMode(enabled){
  coachUnlocked = !!enabled;
  coachStatus.textContent = coachUnlocked ? 'unlocked' : 'locked';
  coachStatus.style.color = coachUnlocked ? '#16a34a' : '#64748b';
  if (coachUnlocked) setChipsLocked(false); else setChipsLocked(!gameActive || remainingTries===0);
  buildTargets(); applyCoachVisibility(); updateHud(Number(scoreVal.textContent)||0);
  disableTargetSelection();
  hideTargetPanel();
  endPhase2(false);
  if (continueBtn) continueBtn.classList.add('hidden');
}
function openPwModal(){ pwModal.style.display='flex'; pwMsg.textContent=''; pwInput.value=''; pwInput.focus(); }
function closePwModal(){ pwModal.style.display='none'; }
function tryUnlock(){ if(pwInput.value===CALIB_PASSWORD){ closePwModal(); setCoachMode(true); } else { pwMsg.textContent='Incorrect password.'; } }

/// @diq:begin [A8] Situations I/O & helpers
const STORAGE_VERSION = 1;
const STORAGE_STARTS = `bb_iq_starts_v${STORAGE_VERSION}`;
const STORAGE_HITS   = `bb_iq_hits_v${STORAGE_VERSION}`;

/** @param {any} sRaw @param {number} i @returns {Situation} */
function normalizeSituation(sRaw, i){
  const safe = { ...(sRaw||{}) };
  safe.key   = String(safe.key||'').trim() || `S${i+1}`;
  safe.title = safe.title || safe.key;
  safe.desc  = safe.desc  || '';

  // geometry
  safe.targets = normalizeTargets(safe.targets)||{};
  safe.starts  = normalizeStarts(safe.starts);

  // hit + meta
  safe.hit     = normalizeHit(safe.hit);
  safe.hitType = mapHitType(safe.hitType);
  const advJSON = (typeof safe.batterAdvance==='number') ? clampInt(safe.batterAdvance,0,4) : null;
  safe.batterAdvance = (advJSON!=null) ? advJSON : mapHitTypeToAdvance(safe.hitType);

  // countables
  safe.outs = clampInt((safe.outs ?? 0), 0, 2);

  // runners
  safe.runnersOn = normalizeRunnersOn(safe.runnersOn);

  // Phase 2: sequence + note
  const rawSeq = Array.isArray(safe.playSeq) ? safe.playSeq : String(safe.playSeq || '')
                    .split(',')
                    .map(s => s.toUpperCase().trim())
                    .filter(Boolean);
  safe.playSeq = rawSeq.filter(s => POS_IDS.includes(s));
  safe.seqNote = (typeof safe.seqNote === 'string') ? safe.seqNote : '';

  return /** @type {Situation} */ (safe);
}


function defaultStartsMap(){
  const map = {};
  (SITUATIONS||[]).forEach(s=>{ map[s.key] = s.starts ? Fcopy(s.starts) : Fcopy(DEFAULT_STARTS); });
  return map;
}
function migrateLocalStorage(){
  // Example: from v1 -> v2 in the future
  // keep as placeholder; do nothing today
  return;
}
migrateLocalStorage();
loadStarts(); loadHits();
function loadStarts(){
  startsMap = defaultStartsMap();
  try{
    const raw = localStorage.getItem(STORAGE_STARTS); if (!raw) return;
    const saved = JSON.parse(raw);
    Object.keys(saved||{}).forEach(k=>{
      const dst = startsMap[k] || (startsMap[k]=Fcopy(DEFAULT_STARTS));
      POS_IDS.forEach(id=>{
        const v = saved[k]?.[id];
        if (v && !isNaN(v.x) && !isNaN(v.y)) dst[id] = { x:Math.round(Number(v.x)), y:Math.round(Number(v.y)) };
      });
    });
  }catch(e){ console.warn('[Starts] localStorage merge error:', e); }
}
function saveStarts(){ try{ localStorage.setItem(STORAGE_STARTS, JSON.stringify(startsMap)); }catch{} }
function getStartFor(sKey,id){ const s = startsMap[sKey] || DEFAULT_STARTS; return s[id] || DEFAULT_STARTS[id]; }
function setStartFor(sKey,id,pt){ if(!startsMap[sKey]) startsMap[sKey]=Fcopy(DEFAULT_STARTS); startsMap[sKey][id]={x:pt.x,y:pt.y}; }

function loadHits(){ try{ const raw=localStorage.getItem(STORAGE_HITS); hitsMap = raw ? JSON.parse(raw) : {}; }catch{ hitsMap={}; } }
function saveHits(){ try{ localStorage.setItem(STORAGE_HITS, JSON.stringify(hitsMap)); }catch{} }
function getHitSaved(sKey){ const v=hitsMap[sKey]; return (v && !isNaN(v.x) && !isNaN(v.y)) ? { x:Math.round(v.x), y:Math.round(v.y) } : null; }
function setHitSaved(sKey, pt){ if (!pt || isNaN(pt.x) || isNaN(pt.y)) return; hitsMap[sKey] = { x:Math.round(pt.x), y:Math.round(pt.y) }; }

function setTargetFor(sKey,id,pt,tol=DEFAULT_TOL){
  const s = SITUATIONS.find(x=>x.key===sKey); if(!s) return;
  if(!s.targets) s.targets={};
  const prevTol = s.targets[id]?.tol;
  s.targets[id] = { x:Math.round(pt.x), y:Math.round(pt.y), tol:Number(tol||prevTol||DEFAULT_TOL) };
}
function getTargetFor(sKey,id){
  const s = SITUATIONS.find(x=>x.key===sKey);
  return (s && s.targets && s.targets[id]) ? s.targets[id] : null;
}

function normPoint(px){
  if (!px || isNaN(px.x) || isNaN(px.y)) return null;
  let x=Number(px.x), y=Number(px.y);
  if (x>=0 && x<=1 && y>=0 && y<=1){ x=Math.round(x*IMG_W); y=Math.round(y*IMG_H); } else { x=Math.round(x); y=Math.round(y); }
  return {x,y};
}
function normalizeStarts(obj){
  if (!obj || typeof obj !== 'object') return null;
  const out={}; POS_IDS.forEach(id=>{ if (obj[id]){ const p=normPoint(obj[id]); if(p) out[id]=p; }});
  return Object.keys(out).length ? out : null;
}
function normalizeTargets(obj){
  const out={}; if (!obj || typeof obj !== 'object') return out;
  POS_IDS.forEach(id=>{
    const raw = obj[id];
    if (raw){
      const p = normPoint(raw);
      if (p){
        out[id] = {
          x:p.x, y:p.y,
          tol: Number(raw.tol) || DEFAULT_TOL,
          notes: typeof raw.notes === 'string' ? raw.notes : ''
        };
      }
    }
  });
  return out;
}
function normalizeHit(obj){ if (!obj || typeof obj !== 'object') return {}; const p=normPoint(obj); return p ? {x:p.x,y:p.y} : {}; }
function mapHitType(v){ const t=String(v||'').toLowerCase(); return (t==='line'||t==='popup'||t==='grounder')?t:'line'; }

async function loadSituationsFromJson(){
  try{
    const res = await fetch('./situations.json?ts=' + Date.now(), { cache:'no-store' });
    if(!res.ok) throw new Error('HTTP '+res.status);
    const arr = await res.json();
    if (!Array.isArray(arr)) throw new Error('situations.json must be an array');

    SITUATIONS = arr.map((raw,i)=> normalizeSituation(raw,i));
    console.info('[Situations] Loaded', SITUATIONS.length);

  }catch(err){
    console.warn('[Situations] JSON load failed, using fallback:', err?.message||err);
    SITUATIONS = (SITUATIONS_FALLBACK||[]).map((raw,i)=> normalizeSituation(raw,i));
  }
}

/* ===== [A8.1] Description HUD helpers (mobile-friendly) ===== */
function updateDescriptionHudText(){
  const el = document.getElementById('descHud');
  if (!el || !currentSituation) return;
  const txt = currentSituation.desc || '';
  el.textContent = txt;
  el.title = txt || '';
}

document.addEventListener('click', (e)=>{
  if (!targetPanel || coachUnlocked) return;
  const clickedRing = e.target.closest('.tgt');
  // Only re-show the instruction if we're truly in post-round state
  if (!clickedRing &&
      targetPanelBody.classList.contains('show-instruction') === false &&
      isPostRound()) {
    showTargetInstruction();
  }
});

/// @diq:begin [A9] Situation lifecycle
function updateCurrentOptionLabel(){
  if (!sitSelect || !currentSituation) return;
  const opt = sitSelect.querySelector(`option[value="${currentSituation.key}"]`);
  if (opt) opt.textContent = currentSituation.title || currentSituation.key;
}

function syncSituationInputsFromCurrent(){
  if (!currentSituation) return;

  withInputMute(() => {
    if (newTitleInput) newTitleInput.value = currentSituation.title || currentSituation.key || '';
    if (newDescInput)  newDescInput.value  = currentSituation.desc  || '';
  });

  if (descHud)     descHud.textContent     = currentSituation.desc  || '';

  const o = clampInt((currentSituation.outs ?? 0), 0, 2);
  setOuts(o, { quiet: true });
}


function startsToTargets(starts, tol=DEFAULT_TOL){
  const out={}; POS_IDS.forEach(id=>{ const p=starts[id]; if(p) out[id]={ x:Math.round(p.x), y:Math.round(p.y), tol:Number(tol)||DEFAULT_TOL }; });
  return out;
}

// Generates a unique, title-independent key. Keys never change when you edit titles.
let __NEW_KEY_SEQ = 0;
function genUniqueKey(_title){
  const has = key => (SITUATIONS || []).some(s => s.key === key);
  let key;
  do {
    // S-<base36 timestamp>-<base36 counter>, all uppercase for consistency
    key = `S-${Date.now().toString(36)}-${(__NEW_KEY_SEQ++).toString(36)}`.toUpperCase();
  } while (has(key));
  return key;
}

function nextNewSituationTitle(){
  const base = 'New Situation';

  // Collect numbers from titles that match:
  // "New Situation"  -> 1
  // "New Situation N" -> N
  const nums = (SITUATIONS || [])
    .map(s => String(s.title || ''))
    .map(t => {
      const m = t.match(/^New Situation(?: (\d+))?$/);
      return m ? Number(m[1] || 1) : null;
    })
    .filter(n => n != null);

  if (nums.length === 0) return base;

  const next = Math.max(...nums) + 1;
  return `${base} ${next}`;
}


function makeBlankSituation(){
  const title = nextNewSituationTitle();            // UI label only; can be edited later
  const desc  = '';
  const key   = genUniqueKey(title);                // Stable key (not tied to title)

  const outsInit = outsSelSituation
    ? clampInt(outsSelSituation.value, 0, 2)
    : clampInt(currentSituation?.outs ?? 0, 0, 2);

  const runnersInit = getRunnersFromCheckboxes();

  return {
    key,
    title,
    desc,
    starts: Fcopy(DEFAULT_STARTS),
    targets: (() => {
      const t = {};
      POS_IDS.forEach(id => { const p = DEFAULT_STARTS[id]; if (p) t[id] = { x:p.x, y:p.y, tol:DEFAULT_TOL }; });
      return t;
    })(),
    hit: { x:1500, y:900 },
    hitType: 'line',
    batterAdvance: 1,
    outs: outsInit,
    runnersOn: normalizeRunnersOn(runnersInit)
  };
}

function addNewSituation(){
  const s = makeBlankSituation();

  // Add to model + persist default starts for this key
  SITUATIONS.push(s);
  startsMap[s.key] = Fcopy(s.starts);
  saveStarts();

  // Rebuild the dropdown (includes the new option) and switch to it immediately
  populateSituations(s.key);
  setSituation(s.key);                 // currentSituation now points to the newly created situation
  if (sitSelect) sitSelect.value = s.key;

  // Seed inputs without triggering 'input' listeners
  withInputMute(() => {
    if (newTitleInput) newTitleInput.value = s.title || '';
    if (newDescInput)  newDescInput.value  = s.desc  || '';
  });

  // Put caret in Title for convenience
  setTimeout(() => { try { newTitleInput?.focus(); } catch{} }, 0);

  if (typeof updateDescriptionHudText === 'function') updateDescriptionHudText();

  if (situationMsg){
    situationMsg.textContent = 'New situation created.';
    setTimeout(() => situationMsg.textContent = '', 1400);
  }
}


function deleteCurrentSituation(){
  if (!currentSituation) return;
  const key = currentSituation.key;
  const idx = (SITUATIONS||[]).findIndex(s=>s.key===key);
  if (idx < 0) return;
  const ok = confirm(`Delete situation "${currentSituation.title||key}"? This cannot be undone.`);
  if (!ok) return;

  // Remove from arrays/maps + persist
  SITUATIONS.splice(idx,1);
  if (startsMap && startsMap[key]){ delete startsMap[key]; saveStarts(); }
  if (hitsMap && hitsMap[key]){ delete hitsMap[key]; saveHits(); }

  // Ensure at least one situation remains
  if (!SITUATIONS.length){
    const s = makeBlankSituation();
    SITUATIONS.push(s);
    startsMap[s.key] = Fcopy(s.starts||DEFAULT_STARTS);
    saveStarts();
  }

  // Pick next selection (prefer previous index)
  const nextIdx = Math.max(0, Math.min(idx, SITUATIONS.length - 1));
  const nextKey = SITUATIONS[nextIdx].key;

  // Rebuild UI
  populateSituations(nextKey);
  setSituation(nextKey);

  if (situationMsg){
    situationMsg.textContent = 'Situation deleted.';
    setTimeout(()=> situationMsg.textContent = '', 1400);
  }
}

function resetStartsToDefaults(){
  if (!currentSituation) return;
  POS_IDS.forEach(id=>{
    const p = DEFAULT_STARTS[id];
    const rec = tokens.get(id);
    if (rec){ rec.pos = { x:p.x, y:p.y }; placeToken(id); }
  });
  currentSituation.starts = Fcopy(DEFAULT_STARTS);
  if (currentSituation.key){
    startsMap[currentSituation.key] = Fcopy(DEFAULT_STARTS);
    saveStarts();
  }
  if (situationMsg){
    situationMsg.textContent = 'Player starts reset to defaults.';
    setTimeout(()=> situationMsg.textContent = '', 1400);
  }
}
function pickRandomSituation(){
  if (!Array.isArray(SITUATIONS) || SITUATIONS.length === 0) return;
  const cur = sitSelect && sitSelect.value || (currentSituation && currentSituation.key);
  let keys = SITUATIONS.map(s=>s.key);
  if (cur && keys.length > 1) keys = keys.filter(k=>k !== cur);
  const key = keys[Math.floor(Math.random() * keys.length)];
  if (sitSelect) sitSelect.value = key;
  setSituation(key);
}

function populateSituations(selectedKey){
  const prev = sitSelect ? sitSelect.value : '';
  if (sitSelect) sitSelect.innerHTML = '';

  (SITUATIONS||[]).forEach(s=>{
    const o = document.createElement('option');
    o.value = s.key;
    o.textContent = s.title || s.key;
    sitSelect.appendChild(o);
  });

  const keyExists = k => (SITUATIONS||[]).some(s => s.key === k);
  const want =
    (selectedKey && keyExists(selectedKey)) ? selectedKey :
    (keyExists(prev) ? prev :
     (SITUATIONS[0] && SITUATIONS[0].key));

  if (want && sitSelect) sitSelect.value = want;
}

function setSituation(key){
  currentSituation = getSituationByKey(key) || SITUATIONS[0];
  if (!currentSituation) return;

  renderSeqBuilder();

  wipePhase2StateUI();
  stopTimer();
  _timerSecs = TIMER_START_SECS;
  updateTimerHud();

  // Any time we switch situations, selection mode should be off
  disableTargetSelection();
  hideTargetPanel();
  _allTargetsCorrect = false;
  _roundHasStarted = false;

  if (!tokens || tokens.size===0) buildTokens();
  resetBallAndRunnerForSituation();

  // Title + Description UI
  if (descHud)  descHud.textContent  = currentSituation.desc  || '';

  const savedHit = getHitSaved(currentSituation.key); if (savedHit) currentSituation.hit = savedHit;

  // Tolerance dropdown
  tolTargetSel.innerHTML='';
  POS_IDS.forEach(id=>{
    const opt=document.createElement('option'); opt.value=id; opt.textContent=id;
    tolTargetSel.appendChild(opt);
  });

  // Move chips to starts
  POS_IDS.forEach(id=>{
    const t=tokens.get(id); if(!t) return;
    t.pos = Fcopy(getStartFor(currentSituation.key,id));
    placeToken(id);
  });

  // If this situation has no targets yet, seed them from the current chip starts
  if (!currentSituation.targets || Object.keys(currentSituation.targets).length === 0) {
    currentSituation.targets = startsToTargets(getOnscreenStarts(), DEFAULT_TOL);
  }

  // Targets & coach visibility
  buildTargets();
  if (!coachUnlocked) getAllRings().forEach(el=> el.style.display='none');

  // HUD / controls
  updateHud(0); gameActive=false; remainingTries=0;
  startBtn.disabled=false; resetBtn.disabled=true; checkBtn.disabled=true;
  setChipsLocked(!coachUnlocked);

  // Tolerance inputs
  const firstId=POS_IDS[0];
  tolTargetSel.value=firstId;
  syncTolInputsFromModel(firstId);

  // >>> sync the Notes textarea with the selected target <<<
  if (tolTargetSel){
    const id = tolTargetSel.value || POS_IDS[0];
    syncTolNotesFromModel(id);
  }

  // Hit + ball (single-ball model: no orange marker in coach mode)
  if (hitMarker){ hitMarker.remove(); hitMarker = null; }
  syncBallToHit();
  if (ballEl){
    ballEl.style.display = (coachUnlocked || gameActive) ? 'block' : 'none';
    ballEl.classList.toggle('locked', !coachUnlocked);
    ballEl.style.zIndex = '10';
  }

  // Hit meta
  if (typeof currentSituation.hitType==='string') hitTypeSel.value=currentSituation.hitType;
  else currentSituation.hitType = hitTypeSel.value || 'line';

  if (typeof currentSituation.batterAdvance==='number') {
    advanceSel.value = String(clampInt(currentSituation.batterAdvance,0,4));
  } else {
    advanceSel.value = String(mapHitTypeToAdvance(currentSituation.hitType));
    currentSituation.batterAdvance = clampInt(advanceSel.value,0,4);
  }

  // Outs and runners
  const outsInit=clampInt((currentSituation.outs ?? 0),0,2);
  setOuts(outsInit,{quiet:true});
  setRunnersOn(normalizeRunnersOn(currentSituation.runnersOn), {quiet:true});

  // Sync Coach Tool inputs
  syncSituationInputsFromCurrent();
  applyCoachVisibility();

  renderBaseRunners();
  scaleMarkers();
  updateRunnersHudFromLive();

  if (continueBtn) continueBtn.classList.add('hidden');
  endPhase2(false); // ensure phase state is cleared
  phase2ClearAllUI();

  if (seqInput){
    const seq = (currentSituation.playSeq || []).join(', ');
    withInputMute(()=> { seqInput.value = seq; });
  }
}

/// @diq:begin [A10] Export helpers
function getOnscreenStarts(){ const out={}; POS_IDS.forEach(id=>{ const rec=tokens.get(id); if(rec&&rec.pos) out[id]={x:Math.round(rec.pos.x),y:Math.round(rec.pos.y)}; }); return out; }
function getRenderedTargets(){
  const out = {};
  getAllRings().forEach(el=>{
    const id   = el.dataset.id;
    const left = parseFloat(el.style.left), top = parseFloat(el.style.top);
    const native = cssToUnit(left, top);
    const modelT = currentSituation.targets?.[id];
    out[id] = {
      x: Math.round(native.x),
      y: Math.round(native.y),
      tol: Math.round(modelT?.tol ?? DEFAULT_TOL),
      notes: modelT?.notes || ''
    };
  });
  return out;
}

function getHitForExport(sit){ return sit && sit.hit ? { x:Math.round(sit.hit.x), y:Math.round(sit.hit.y) } : undefined; }
function getStartsForExport(key){
  const src=(startsMap && startsMap[key]) ? startsMap[key] : DEFAULT_STARTS;
  const out={}; POS_IDS.forEach(id=>{ const p=src[id] || DEFAULT_STARTS[id]; out[id]={ x:Math.round(p.x), y:Math.round(p.y) }; });
  return out;
}
function composeSituationForExport(base, starts, targets, hit){
  const extra = { ...base };
  delete extra.starts;
  delete extra.targets;
  delete extra.hit;

  const payload = { ...extra, starts, targets };
  if (hit) payload.hit = hit;

  if (base.hitType) payload.hitType = base.hitType;
  if (typeof base.batterAdvance === 'number') {
    payload.batterAdvance = clampInt(base.batterAdvance, 0, 4);
  }

  if (Array.isArray(base.playSeq) && base.playSeq.length) {
    payload.playSeq = base.playSeq.slice();
  }
  if (typeof base.seqNote === 'string' && base.seqNote.trim()) {
    payload.seqNote = base.seqNote;
  }

  return payload;
}


function buildCurrentSituationExport(){
  const s=currentSituation || SITUATIONS[0]; if(!s) return '[]';
  const one=composeSituationForExport(s, getOnscreenStarts(), getRenderedTargets(), getHitForExport(s));
  return JSON.stringify([one],null,2);
}
function buildAllSituationsExport(){
  const arr=(SITUATIONS||[]).map(s=>{
    const isCurrent=currentSituation && (s.key===currentSituation.key);
    const starts=isCurrent?getOnscreenStarts():getStartsForExport(s.key);
    let targets=isCurrent?getRenderedTargets():{};
    if (!isCurrent){
      Object.entries(s.targets||{}).forEach(([id,pt])=>{
        targets[id] = {
          x: Math.round(pt.x),
          y: Math.round(pt.y),
          tol: Math.round(pt.tol || DEFAULT_TOL),
          notes: pt.notes || ''
        };
      });
    }
    const hit=getHitSaved(s.key) || getHitForExport(s);
    return composeSituationForExport(s,starts,targets,hit);
  });
  return JSON.stringify(arr,null,2);
}
function download(filename,content){
  const blob=new Blob([content], {type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=filename;
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href),2000);
}

/// @diq:begin [A10.1] One-button refresh (saves Coach Tools + rebuilds UI)
function refreshSituationAll(){
  if (!currentSituation) return;

  // 1) Title / Description
  if (newTitleInput){
    const t = newTitleInput.value.trim();
    if (t) currentSituation.title = t;
  }
  if (newDescInput){
    currentSituation.desc = newDescInput.value.trim();
  }

  // 2) Outs (HUD + dropdown sync)
  if (outsSelSituation){
    setOuts(outsSelSituation.value, {quiet:true});
  } else {
    currentSituation.outs = clampInt(currentSituation.outs ?? 0, 0, 2);
  }

  // 3) Runners (model + HUD + markers)
  setRunnersOn(getRunnersFromCheckboxes(), {quiet:true});

  // 4) Starts: pull from chips and persist
  const starts = getOnscreenStarts();
  currentSituation.starts = Fcopy(starts);
  startsMap[currentSituation.key] = Fcopy(starts);
  saveStarts();

  // 5) Targets:
  //    - If visible rings exist, read them back (live tol & positions).
  //    - Otherwise seed from starts (ensures targets always exist).
  let targets = getRenderedTargets();
  if (!targets || Object.keys(targets).length === 0){
    targets = {};
    POS_IDS.forEach(id=>{
      const p = starts[id];
      if (p) targets[id] = { x:Math.round(p.x), y:Math.round(p.y), tol:DEFAULT_TOL };
    });
  }
  currentSituation.targets = {};
  Object.entries(targets).forEach(([id,pt])=>{
    currentSituation.targets[id] = {
      x:Math.round(pt.x),
      y:Math.round(pt.y),
      tol:Number(pt.tol)||DEFAULT_TOL
    };
  });

  // 6) Hit + meta (+ persist hit location only)
  ensureDefaultHit();
  currentSituation.hitType = (hitTypeSel && hitTypeSel.value) || currentSituation.hitType || 'line';
  currentSituation.batterAdvance = clampInt(
    (advanceSel && advanceSel.value) ?? currentSituation.batterAdvance ?? 1,
    0, 4
  );
  setHitSaved(currentSituation.key, currentSituation.hit);
  saveHits();

  // 7) Rebuild UI pieces to reflect the saved model
  populateSituations(currentSituation.key);

  if (descHud) descHud.textContent = currentSituation.desc || '';
  if (typeof updateDescriptionHudText === 'function') updateDescriptionHudText();

  // Rebuild targets (applies new tolerance sizes), hit marker & ball
  buildTargets();
  placeHitMarker();
  syncBallToHit();
  renderBaseRunners();
  scaleMarkers();
  updateRunnersHudFromLive();

  // Keep tolerance inputs in sync with selected target
  if (tolTargetSel){
    const id = tolTargetSel.value || POS_IDS[0];
    if (id) syncTolInputsFromModel(id);
  }

  // 8) Toasty message
  if (situationMsg){
    situationMsg.textContent='Situation refreshed.';
    setTimeout(()=> situationMsg.textContent='', 1400);
  }

  if (seqInput){
    const parts = String(seqInput.value || '')
      .split(',')
      .map(s => s.toUpperCase().trim())
      .filter(s => POS_IDS.includes(s));
    currentSituation.playSeq = parts; // [] disables Phase 2
  }

  if (seqNoteInput){
    currentSituation.seqNote = String(seqNoteInput.value || '');
  }

}

// Use one canonical saver; keep alias for any internal callers.
const saveCurrentSituation = refreshSituationAll;

/// @diq:begin [A11] Game flow
function checkPositions(){
  if (!coachUnlocked && !gameActive) return;

  const t = currentSituation.targets || {};
  let correct = 0;

  // Determine if this is the last available try BEFORE decrementing
  const isFinalTry = (!coachUnlocked && gameActive && remainingTries === 1);

  // Evaluate each position vs target
  getAllRings().forEach(el => {
    const id = el.dataset.id;
    const target = t[id];
    if (!target) return;

    const cur = tokens.get(id).pos;
    const tol = Number(target.tol) || DEFAULT_TOL;
    const d = Math.hypot(cur.x - target.x, cur.y - target.y);
    const isCorrect = d <= tol;

    el.classList.toggle('good', isCorrect);
    el.classList.toggle('bad', !isCorrect);
    el.classList.add('show-label');

    if (coachUnlocked) {
      el.style.display = 'block';
    } else {
      // Before the final try, reveal only correct rings; on the final try reveal all
      el.style.display = (isFinalTry || isCorrect) ? 'block' : 'none';
    }

    if (isCorrect) correct++;
  });

  // Update numeric score + colorize
  updateHud(correct);
  if (scoreBadge){
    const pct = correct / 9;
    const state = pct >= 2/3 ? 'green' : (pct >= 1/3 ? 'yellow' : 'red');
    setBadgeState(scoreBadge, state, 'score');
  }

  // Non-coach: handle tries and end-of-round behavior
  if (!coachUnlocked){
    const allCorrectNow = (correct === POS_IDS.length);
    _allTargetsCorrect = allCorrectNow;

    if (gameActive){
      remainingTries = Math.max(0, remainingTries - 1);
      updateHud(correct);
    }

    const outOfTries = (remainingTries === 0);
    const shouldEndRound = allCorrectNow || outOfTries;

    if (shouldEndRound){
      // ⬅️ Stop/pause the timer when Phase 1 ends
      stopTimer();

      // HIDE instead of disable the Check button
      if (checkBtn) checkBtn.classList.add('hidden');

      setChipsLocked(true);
      gameActive = false;                 // freeze game state for inspection

      // Enable selecting rings to view notes (always allowed at round end)
      enableTargetSelection();

      // Show the instruction card ONLY if a round had actually started
      if (_roundHasStarted){
        if (typeof showTargetInstruction === 'function') {
          showTargetInstruction();
        } else if (typeof showTargetPanel === 'function') {
          showTargetPanel();
        }
      }

      // Gate Phase 2 availability (button shows only if a sequence exists)
      if (_roundHasStarted && continueBtn){
        const hasSeq = getSeqForCurrent().length > 0;
        if (hasSeq) {
          continueBtn.classList.remove('hidden');
        } else {
          continueBtn.classList.add('hidden');
        }
      }
    }
  }
}

function resetBallAndRunnerForSituation(){
  if (animReq){ cancelAnimationFrame(animReq); animReq=null; }
  if (ballSvg) ballSvg.innerHTML='';
  if (ballEl) syncBallToHit();
  if (runnerAnimId){ cancelAnimationFrame(runnerAnimId); runnerAnimId=null; }
  hideRunner();
}

function resetPlayers(){
  wipePhase2StateUI();
  stopTimer();
  _timerSecs = TIMER_START_SECS;
  updateTimerHud();

  if (continueBtn) continueBtn.classList.add('hidden');

  // existing reset logic
  allowSeqPanel = false;
  disableTargetSelection();
  hideTargetPanel();
  _allTargetsCorrect = false;
  _roundHasStarted = false;

  POS_IDS.forEach(id=>{
    const t=tokens.get(id);
    if(!t) return;
    t.pos=Fcopy(getStartFor(currentSituation.key,id));
    placeToken(id);
  });

  getAllRings().forEach(el=> el.style.display=coachUnlocked ? 'block' : 'none');
  updateHud(0);
  gameActive=false;
  remainingTries=0;

  // Re-enable Start / Reset buttons
  startBtn.disabled=false;
  resetBtn.disabled=true;

  // ⬅️ Make sure Check Positions is visible and reset to its initial state
  if (checkBtn){
    checkBtn.classList.remove('hidden');
    checkBtn.disabled = true;   // start disabled until "Start Situation" is pressed
  }

  setChipsLocked(!coachUnlocked);

  if (ballSvg) ballSvg.innerHTML='';
  if (ballEl) syncBallToHit();

  hideRunner();

  liveRunners = normalizeRunnersOn(currentSituation.runnersOn);
  renderBaseRunners();
  scaleMarkers();
  updateRunnersHudFromLive();
}

/// @diq:begin [A12] Init & events
async function init(){
  try{
    sizeOverlays();

    // Ensure header metrics/actions are grouped before first paint
    ensureHeaderGrouping();

    await loadSituationsFromJson();
    loadStarts(); loadHits();
    if (!Array.isArray(SITUATIONS) || SITUATIONS.length===0){
      SITUATIONS=[{ key:'S1', title:'Default', desc:'', starts:Fcopy(DEFAULT_STARTS), targets:{},
        hit:{x:1500,y:900}, hitType:'line', batterAdvance:1, outs:0, runnersOn:{first:false,second:false,third:false} }];
    }
    populateSituations();
    const firstKey = (sitSelect && sitSelect.value) || (SITUATIONS[0] && SITUATIONS[0].key);
    buildTokens(); updateChipScale(); setSituation(firstKey); setCoachMode(false);
    observeWrap(); scheduleLayout();

    updateDescriptionHudText();
    wireOnce();

  } catch (err){
    console.error('[Init] fatal error:', err && (err.stack||err.message||err));
    alert('There was an error starting the app. Open the console for details.');
  }
}

function syncTolInputsFromModel(id){
  const t = getTargetFor(currentSituation.key, id);
  const tol = Number(t?.tol) || DEFAULT_TOL;
  if (tolNum)   tolNum.value   = String(tol);
  if (tolRange) tolRange.value = String(tol);
  // keep the ring sized live if it's on-screen
  const ring = getRingEl(id);
  if (ring){
    const d = tolToCssDiameter(tol, coachUnlocked);
    ring.style.width = d+'px';
    ring.style.height = d+'px';
  }
  // ALSO: sync notes
  syncTolNotesFromModel(id);
}

function syncTolNotesFromModel(id){
  const notes = getTargetNotes(currentSituation.key, id) || '';
  if (tolNotes) tolNotes.value = notes;
}

function setTolLive(id,tol){
  tol = clamp(Number(tol)||DEFAULT_TOL,5,400);
  let tgt = getTargetFor(currentSituation.key,id);
  if (!tgt){
    const pt = tokens.get(id)?.pos || getStartFor(currentSituation.key,id);
    setTargetFor(currentSituation.key,id,pt,tol);
    buildTargets();
  } else { tgt.tol = tol; }
  const ring = getRingEl(id);
  if (ring){
    const d=tolToCssDiameter(tol, coachUnlocked);
    ring.style.width=d+'px'; ring.style.height=d+'px';
    if (coachUnlocked) { ring.style.display='block'; ring.classList.add('show-label'); }
  }
  tolNum.value = tolRange.value = String(tol);
}

/* Kickoff */
if (img && img.complete) init();
else if (img){ img.addEventListener('load', init, { once:true }); window.addEventListener('load', ()=>{ if (!SITUATIONS.length) init(); }, { once:true }); }
/// @diq:end [A12] Init & events
else { window.addEventListener('load', init, { once:true }); }
</script>

</body>
</html>
