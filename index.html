<html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Diamond IQ ‚Äî Chips + Targets + Coach Tools (JSON situations)</title>
<style>
  /* --- Base UI --- */
  body{
    margin:0;
    font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    background:#f6f7fb;color:#1f2937;
  }

  /* ---- Header (DOM-order driven) ---- */
  header{
    display:flex;
    align-items:center;
    gap:8px;
    padding:12px;
    background:#fff;
    border-bottom:1px solid #e5e7eb;
    position:sticky; top:0; z-index:10;
  }
  header h1{
    margin:0 8px 0 0;
    font-size:16px;
    font-weight:800;
  }

  /* Everything except <h1> lives inside .header-actions in the desired DOM order:
     Random ‚Üí Select ‚Üí Description ‚Üí Runners ‚Üí Outs ‚Üí Start ‚Üí Reset ‚Üí Check ‚Üí HUD ‚Üí Coach */
  header .header-actions{
    display:flex;
    flex-wrap:wrap;              /* wrap nicely on smaller screens */
    align-items:center;
    gap:8px;
    flex:1;                      /* allow actions row to stretch */
  }

  /* Right-aligned header buttons: Help / Coach Tools / Admin Tools */
  header .header-right{
    margin-left:auto;
    display:flex;
    align-items:center;
    gap:8px;
    flex-wrap:wrap;
  }

  /* Situation dropdown auto-sizes to its text */
  #sitSelect{
    width:auto;
    min-width:140px;
    border-color:#cbd5e1;
    box-shadow:inset 0 1px 2px rgba(0,0,0,.04);
  }
  #sitSelect:focus{
    outline:none;
    border-color:#94a3b8;
    box-shadow:0 0 0 3px rgba(148,163,184,.35);
  }

  /* Description pill ‚Äî auto-size with graceful truncation on wide screens */
  #descHud{
    display:inline-flex;align-items:center;gap:6px;
    padding:6px 10px;border-radius:999px;font-weight:900;font-size:13px;
    border:1px solid rgba(0,0,0,.08); box-shadow:0 1px 2px rgba(0,0,0,.06);
    background:#f8fafc;color:#0b1321;

    max-width:50%;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  @media (max-width:720px){ #descHud{ font-size:12px } }

  /* Keep Score & Tries together, pinned at right before Coach */
  #hud{
    margin-left:auto;            /* pushes HUD to the right edge */
    display:flex;
    align-items:center;
    gap:8px;
  }

  /* Inputs / buttons */
  select,button,input[type="number"],input[type="range"]{
    padding:6px 10px;font-weight:700;border:1px solid #e5e7eb;border-radius:8px;background:#fff;
  }
  button{ cursor:pointer }
  .btn-green{background:#16a34a;color:#fff;border-color:#15803d}
  .btn-yellow{background:#facc15;color:#111827;border:1px solid #eab308;}
  .btn-yellow:hover{filter:brightness(.97)}

  .btn-orange{background:#f97316;color:#fff;border-color:#ea580c}
  .btn-slate{background:#fff;color:#334155;border:1px solid #cbd5e1}
  .btn-small{padding:4px 8px;font-size:12px;line-height:1.2}

  /* Player info modal */
  .modal-overlay{
    position:fixed; inset:0;
    background:rgba(2,6,23,.55);
    display:none;
    align-items:center;
    justify-content:center;
    padding:16px;
    z-index:9999;
  }
  .modal{
    width:min(520px, 96vw);
    background:#fff;
    border:1px solid #e5e7eb;
    border-radius:16px;
    box-shadow:0 20px 60px rgba(0,0,0,.22);
    overflow:hidden;
  }
  .modal-header{padding:14px 16px;border-bottom:1px solid #e5e7eb;font-weight:900}
  .modal-body{padding:14px 16px;display:grid;gap:10px}
  .modal-body label{font-weight:800;font-size:12px;color:#334155}
  .modal-body input{width:100%}
  .modal-actions{padding:14px 16px;border-top:1px solid #e5e7eb;display:flex;justify-content:flex-end;gap:10px}
  .help-muted{color:#64748b;font-size:12px}

#startBtn:disabled,#resetBtn:disabled{
    background:#f1f5f9;color:#94a3b8;border-color:#cbd5e1;cursor:not-allowed;
  }
  #checkBtn:disabled{
    background:#e5e7eb !important;color:#94a3b8 !important;border-color:#cbd5e1 !important;cursor:not-allowed;
  }

  /* HUD badges */
  .badge{
    display:inline-flex;align-items:center;gap:6px;
    padding:6px 10px;border-radius:999px;font-weight:900;font-size:13px;
    border:1px solid rgba(0,0,0,.08); box-shadow:0 1px 2px rgba(0,0,0,.06);
    background:#f8fafc;color:#0b1321;
  }


  .badge-green{background:#16a34a;color:#fff;border-color:#15803d}
  .badge-orange{background:#f97316;color:#fff;border-color:#ea580c}

  .badge-mini{padding:3px 8px;font-size:12px;font-weight:900;}
  .badge-score{background:#ecfeff;border-color:#a5f3fc}
  .badge-tries{background:#eef2ff;border-color:#c7d2fe}
  .tries-green{background:#dcfce7;border-color:#86efac}
  .tries-yellow{background:#fef9c3;border-color:#fde68a}
  .tries-red{background:#fee2e2;border-color:#fecaca}
  .score-green{background:#dcfce7;border-color:#86efac}
  .score-yellow{background:#fef9c3;border-color:#fde68a}
  .score-red{background:#fee2e2;border-color:#fecaca}
  .badge .dot{width:10px;height:10px;border-radius:50%;box-shadow:inset 0 0 0 1px rgba(0,0,0,.08)}
  .dot-score{background:#06b6d4}
  .dot-tries{background:#6366f1}

  /* App shell */
  /* Left column slightly narrower so the field/play area on the right is larger */
  .app{display:grid;grid-template-columns:290px minmax(0,1fr);gap:14px;padding:14px;max-width:min(1600px,96vw);margin:0 auto}
  header .header-row{width:100%;max-width:min(1600px,96vw);margin:0 auto}
  @media (max-width:1100px){
    .app{grid-template-columns:1fr;gap:12px;padding:10px;max-width:98vw}
    header .header-row{max-width:100vw}
  }
  @media (max-width:900px){
    .app{max-width:100vw;padding-left:8px;padding-right:8px}
  }
  @media (max-width:600px){ .card{padding:8px} }
  .card{background:#fff;border:1px solid #e5e7eb;border-radius:10px;padding:10px}
  .sideCol{display:flex;flex-direction:column;gap:12px}

  /* Field + overlays */
  /* The play stage centers the field and ensures the field never grows beyond the viewport. */
  #playCard{display:flex;flex-direction:column}
  #playStage{flex:1;min-height:0;display:flex;justify-content:center;align-items:center;position:relative}
  /* Wrap should size to the rendered image so chip coordinates stay aligned even when the image is height-constrained. */
  #wrap{position:relative;display:inline-block}
  #fieldImg{
    display:block;
    width:auto;
    height:auto;
    max-width:100%;
    /* keep the entire field visible within the browser window (account for header + card chrome) */
    max-height:calc(100vh - 220px);
    border-radius:10px;
    background:#fff;
  }
  .overlay{position:absolute;inset:0;pointer-events:none}
  #targetsLayer{pointer-events:none;z-index:2}
  #ballLayer{pointer-events:none;z-index:3}

  .badge-timer{background:#fff7ed;border-color:#fed7aa}
  .badge-timer.low{background:#fee2e2;border-color:#fecaca}

  /* Chips */
  :root { --chip-size: 36px; --chip-font: 14px; }
  .chip{
    position:absolute;transform:translate(-50%,-50%);
    width:var(--chip-size);height:var(--chip-size);
    border-radius:50%;display:flex;align-items:center;justify-content:center;
    font-weight:700;font-size:var(--chip-font);color:#fff;cursor:grab;
    box-shadow:0 1px 3px rgba(0,0,0,.35);user-select:none;touch-action:none;pointer-events:auto;z-index:1;
  }
  .chip:active{transform:translate(-50%,-50%) scale(1.045)}
  .chip.Battery{background:#f59e0b}
  .chip.Infield{background:#2563eb}
  .chip.Outfield{background:#dc2626}
  .chip.locked{cursor:not-allowed;opacity:.7}

  /* Phase 2 visuals */
  .chip.selectableChip{ outline:2px solid rgba(2,132,199,.75); outline-offset:2px }
  .chip.correctPulse{ animation:chipPulse .28s ease-in-out }
  .chip.wrongShake{  animation:chipShake .22s ease-in-out }
  @keyframes chipPulse{ 0%{transform:translate(-50%,-50%) scale(1)} 50%{transform:translate(-50%,-50%) scale(1.10)} 100%{transform:translate(-50%,-50%) scale(1)} }
  @keyframes chipShake{ 0%,100%{transform:translate(-50%,-50%)} 25%{transform:translate(calc(-50% - 4px),-50%)} 75%{transform:translate(calc(-50% + 4px),-50%)} }

  /* Locked-correct chip highlight for Phase 2 */
  .chip.seq-locked{
    outline: 3px solid rgba(22,163,74,.9);
    outline-offset: 2px;
    box-shadow: 0 0 0 2px rgba(0,0,0,.25), 0 0 0 6px rgba(22,163,74,.2);
    cursor: default !important;
  }

  /* Targets */
  .tgt{
    position:absolute;transform:translate(-50%,-50%);
    border:3px solid rgba(255,255,255,.98);border-radius:999px;display:none;
    box-shadow:0 0 0 3px rgba(0,0,0,.28),0 0 0 10px rgba(255,255,255,.18);
    background:rgba(0,0,0,0.05);touch-action:none;z-index:2;
  }
  .tgt.draggable{cursor:grab;pointer-events:auto}
  .tgt.good{background:rgba(22,163,74,.25)}
  .tgt.bad{background:rgba(239,68,68,.25)}
  .tgt .tgt-label{
    position:absolute;top:calc(100% + 6px);left:50%;transform:translateX(-50%);
    padding:2px 7px;border-radius:6px;font-weight:900;font-size:12px;
    color:#0b1321;background:rgba(255,255,255,.95);border:1px solid rgba(0,0,0,.2);white-space:nowrap;display:none;
  }
  .tgt.show-label .tgt-label{display:block}
  .tgt.locked{cursor:not-allowed}

  /* Clickable after last try */
  .tgt.selectable{ pointer-events:auto; cursor:pointer; }
  .tgt.selected{ box-shadow:0 0 0 3px rgba(2,132,199,.45), 0 0 0 10px rgba(2,132,199,.15) }

  /* Target Notes textarea */
  #tolNotes{ font:13px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }

  /* Ball path + ball */
  #ballLayer svg{width:100%;height:100%;display:block}
  .ball{
    position:absolute;transform:translate(-50%,-50%);width:14px;height:14px;border-radius:50%;
    background:#fff;box-shadow:0 0 0 2px #000, 0 1px 3px rgba(0,0,0,.35);
    z-index:10; /* ‚¨ÖÔ∏è higher than chips (1), runners (3), trails (3), seqBall (4) */
    pointer-events:auto;cursor:grab;
  }
  .ball.locked{pointer-events:none;cursor:default;opacity:.95}

  /* Runner + base runners */
  .runner,.baseRunner{
    position:absolute;transform:translate(-50%,-50%) rotate(45deg);width:14px;height:14px;background:#0b0b0b;
    box-shadow:0 0 0 2px #ffffff,0 1px 2px rgba(0,0,0,.30);border-radius:4px;z-index:3;pointer-events:none;
  }
  .runner .rlabel,.baseRunner .rlabel{
    position:absolute;inset:0;display:flex;align-items:center;justify-content:center;transform:rotate(-45deg);
    color:#fff;font-weight:900;font-size:13px;text-shadow:0 1px 1px rgba(0,0,0,.35);user-select:none;
  }
  .movingRunner{width:14px;height:14px;background:#111;border-radius:2px;box-shadow:0 0 0 2px #fff}

  /* Coach hit target marker */
  .hitTarget{
    position:absolute;transform:translate(-50%,-50%);width:18px;height:18px;border-radius:50%;
    background:#f97316;box-shadow:0 0 0 2px #7c2d12 inset, 0 0 0 2px #ffffff;cursor:grab;touch-action:none;pointer-events:auto;z-index:4;
  }
  .hitTarget:active{transform:translate(-50%,-50%) scale(1.05)}

  /* Coach Tools UI */
  .coachGrid{display:grid;gap:8px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .subsec{border:1px dashed #e5e7eb;border-radius:10px;padding:8px;margin-top:6px}
  .subsec > .title{font-weight:800;color:#334155;margin-bottom:6px;font-size:13px}
  /* === Play Sequence Builder (Coach) === */
  .pos-grid{
    display:grid;
    grid-template-columns: repeat(5, minmax(44px, 1fr)); /* max 5 across */
    gap:6px;
  }
  .pos-btn{
    padding:6px 8px;border:1px solid #cbd5e1;border-radius:8px;background:#fff;cursor:pointer;font-weight:800;
    text-align:center; user-select:none; transition:transform .06s ease;
  }
  .pos-btn:active{ transform:scale(.98) }
  .pos-btn[data-group="Battery"]{ background:#fff7ed; border-color:#fed7aa }
  .pos-btn[data-group="Infield"]{ background:#eef2ff; border-color:#c7d2fe }
  .pos-btn[data-group="Outfield"]{ background:#fee2e2; border-color:#fecaca }

  .seq-list{
    display:flex; flex-direction:column; gap:6px; margin-top:6px;
    min-height:38px; background:#f8fafc; border:1px dashed #cbd5e1; border-radius:10px; padding:8px;
  }
  .seq-item{
    display:flex; align-items:center; gap:8px; background:#fff; border:1px solid #e5e7eb;
    border-radius:10px; padding:6px 8px; cursor:grab; user-select:none;
  }
  .seq-item.dragging{ opacity:.6 }
  .seq-num{
    width:22px;height:22px;border-radius:999px;background:#e0f2fe;border:1px solid #bae6fd;
    font-weight:900; display:flex;align-items:center;justify-content:center;color:#0b1321
  }
  .seq-tag{
    font-weight:800; padding:2px 6px; border-radius:6px; background:#f1f5f9; border:1px solid #e5e7eb;
  }
  .seq-remove{
    margin-left:auto;
    padding:4px 8px;font-size:12px;border:1px solid #fecaca;border-radius:8px;background:#fff;cursor:pointer;color:#dc2626;
  }
  .seq-ghost{
    height:34px; border:2px dashed #94a3b8; border-radius:10px; background:transparent;
  }
  .seq-toolbar{ display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap }

  .hint{font-size:12px;color:#64748b;font-weight:700}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}
  .hidden{display:none!important}

  /* Phase 2: throw animation ball + trail */
  .seqBall {
    position:absolute;
    width:14px;height:14px;border-radius:50%;
    background:#fff;
    box-shadow:0 0 0 2px #000, 0 1px 3px rgba(0,0,0,.35);
    transform:translate(-50%,-50%);
    z-index:4; /* above chips */
    pointer-events:none;
  }
  .throwTrail {
    position:absolute; inset:0; pointer-events:none; z-index:3;
  }
  .throwTrail svg path {
    stroke:#334155;            /* darker fallback if no color is set */
    fill:none;
    stroke-width:4;            /* thicker for visibility */
    stroke-linecap:round;
    stroke-linejoin:round;
    opacity:.95;
  }

  /* Collapsible description behavior (legacy support if used) */
  #sitDescBar.desc-collapsed{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  #sitDescBar.desc-expanded{white-space:pre-wrap}

  /* Coach password modal */
  #pwModal{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:1000}
  #pwModal .box{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:16px;min-width:280px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  #pwModal input[type="password"]{
    display:block;width:100% !important;box-sizing:border-box;
    margin-top:8px;padding:10px 12px;border:1px solid #cbd5e1 !important;border-radius:10px;background:#fff;
  }
  #pwModal input[type="password"]:focus{outline:none;box-shadow:0 0 0 3px rgba(59,130,246,.35)}
  #pwModal .row{justify-content:flex-end !important;gap:10px;margin-top:12px !important}

  /* How to play: expandable */
  #howToCard summary {
    list-style: none;
    display: flex;
    align-items: center;
    justify-content: space-between;
    cursor: pointer;
    user-select: none;
  }
  #howToCard summary::-webkit-details-marker { display: none; }

  #howToCard .htp-caret {
    transition: transform .18s ease, opacity .18s ease;
    margin-left: 8px;
    opacity: .7;
  }
  #howToCard details[open] .htp-caret {
    transform: rotate(90deg);
    opacity: 1;
  }
  #howToCard .howto-body { margin-top: 8px; }

  @media (max-width:420px){
    .pos-grid{
      grid-template-columns: repeat(3, minmax(44px, 1fr));
    }
  }

  /* ===== Responsive tweaks ===== */
  @media (max-width:900px){
    /* Let select + description use full width rows when needed */
    #sitSelect{
      flex:1 1 100%;
      max-width:100%;
    }
    #descHud{
      flex:1 1 100%;
      max-width:100%;
      white-space:pre-wrap;
      text-overflow:clip;
    }

    /* Make controls easier to tap; stack if needed */
    header .header-actions > button,
    header .header-actions > select{
      width:100%;
    }
  }
  @media (max-width:600px){
    #runnersBadge, #outsHud{ flex:1 1 48%; }
    #sitSelect{ min-width:160px; }
  }
  @media (max-width:520px){
    #sitSelect{ min-width:140px; }
  }


/* Coach Tools headings */
#coachCard .coachCardH1{
  margin:0;
  font-size:28px; /* h1-like */
  line-height:1.15;
  font-weight:800;
  letter-spacing:-0.02em;
}

#adminCard .adminTitleH3{
  margin:0;
  font-size:18px; /* h3-like */
  line-height:1.25;
  font-weight:800;
  color:#334155;
}
#adminCard .adminTitleH4{
  margin:10px 0 6px;
  font-size:15px; /* h4-like */
  line-height:1.2;
  font-weight:800;
  color:#334155;
}
#adminCard .fieldHline{
  display:flex;
  align-items:center;
  gap:10px;
}
#adminCard label.fieldHline{
  flex-direction:row;
}
#adminCard label.fieldHline > input,
#adminCard label.fieldHline > select,
#adminCard label.fieldHline > .adminPassRow{
  flex:1;
  min-width:0;
}
#adminCard .fieldHline > span{
  margin:0;
  min-width:110px;
  font-size:12px;
  font-weight:700;
  color:#64748b;
  line-height:1.1;
}
#adminCard .fieldHline > input,
#adminCard .fieldHline > select,
#adminCard .fieldHline > textarea,
#adminCard .fieldHline > .adminPassRow{
  flex:1 1 auto;
  min-width:0;
}
#adminCard .adminPassRow > input{flex:1 1 auto; min-width:0;}
#coachCard .subsec > .title{
  margin:0;
  font-size:18px; /* h3-like */
  line-height:1.25;
  font-weight:800;
}
/* Player sidebar header */
.cardTitleRow{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px}

/* Player Login form alignment (scoped) */
#playerSidebarCard .playerLoginGrid{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:10px;
  align-items:end;
}
#playerSidebarCard .field{
  display:flex;
  flex-direction:column;
  gap:4px;
}
#playerSidebarCard .field > span{
  font-size:12px;
  font-weight:700;
  color:#64748b;
  line-height:1.1;
}

  /* --- Coach TEAMS section tweaks --- */
  .sectionTitle{
    font-weight:900;
    color:#111827;
    letter-spacing:.02em;
  }
  #teamsSubsec .coachGrid{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:12px;
    align-items:end;
  }

  /* Stack Team / Team Name / Coach Email within TEAMS */
  #teamsSubsec .teamsTeamGrid{ grid-template-columns:1fr; }
  #teamsSubsec .teamsTeamGrid .span2{ grid-column:auto; }

  #teamsSubsec .coachGrid .span2{ grid-column:1 / span 2; }
  #teamsSubsec .coachGrid .field > span{
    font-size:12px;
    font-weight:700;
    color:#64748b;
    line-height:1.1;
  }

  /* --- Sidebar overflow safety (Coach Review + Teams) --- */
  #coachCard{overflow:hidden;}
  #coachCard .subsec, #coachCard .diq-body{max-width:100%; overflow-x:hidden;}
  #coachCard input, #coachCard select, #coachCard textarea{max-width:100%; box-sizing:border-box;}
  #coachCard textarea{width:100%;}
  #coachCard .row{flex-wrap:wrap;}

  /* Coach Tools form grid (matches Player panel alignment) */
  #coachCard .rowGrid{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:12px;
    align-items:end;
    max-width:100%;
  }
  @media (max-width:420px){
    #coachCard .rowGrid{ grid-template-columns:1fr; }
  }
  #coachCard .rowGrid > *{min-width:0;}
  #coachCard .rowGrid .field{
    display:flex;
    flex-direction:column;
    gap:4px;
    min-width:0;
  }
  #coachCard .rowGrid .field > span{
    font-size:12px;
    font-weight:700;
    color:#64748b;
    line-height:1.1;
  }
  #coachCard .rowGrid .input,
  #coachCard .rowGrid .select,
  #coachCard .rowGrid .inp{
    width:100%;
    max-width:100%;
    box-sizing:border-box;
  }
  /* Password row: keep Gen inside card */
  #teamsSubsec .rowGrid .field div{max-width:100%;}
  #teamsSubsec .rowGrid .field div input{flex:1 1 auto; min-width:0;}
  #teamsSubsec .rowGrid .field div button{flex:0 0 auto;}

/* Coach Tools collapsible sections */
#coachCard .subsec{position:relative;}
#coachCard .subsec.diq-collapsible .title,
#coachCard .subsec.diq-collapsible .sectionTitle{
  cursor:pointer;
  user-select:none;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
#coachCard .subsec.diq-collapsible .diq-chevron{
  width:18px;height:18px;
  display:inline-flex;align-items:center;justify-content:center;
  border:1px solid #e5e7eb;border-radius:8px;
  color:#64748b;background:#fff;
  font-size:12px;line-height:1;
}
#coachCard .subsec.diq-collapsible.diq-collapsed .diq-chevron{transform:rotate(-90deg);}
#coachCard .subsec.diq-collapsible .diq-body{margin-top:8px;}
#coachCard .subsec.diq-collapsible.diq-collapsed .diq-body{display:none;}

/* Coach Review modal + table */
.diq-modal{position:fixed; inset:0; z-index:60; display:flex; align-items:center; justify-content:center;}
.diq-modal.hidden{display:none;}
.diq-modal-backdrop{position:absolute; inset:0; background:rgba(15,23,42,.55);}
.diq-modal-panel{position:relative; width:min(980px, calc(100vw - 24px)); max-height:calc(100vh - 24px); overflow:auto;
  background:#fff; border:1px solid #e5e7eb; border-radius:16px; box-shadow:0 18px 40px rgba(2,6,23,.18); padding:14px 14px 18px;}
.diq-modal-head{display:flex; align-items:center; justify-content:space-between; gap:12px; padding-bottom:10px; border-bottom:1px solid #e5e7eb;}

.coachTblWrap{border:1px solid #e5e7eb; border-radius:14px; overflow:auto; background:#fff;}
.coachTbl{width:100%; border-collapse:separate; border-spacing:0; min-width:780px;}
.coachTbl thead th{position:sticky; top:0; background:#f3f4f6; z-index:1; font-size:12px; color:#334155; text-align:left; padding:10px 10px; border-bottom:1px solid #e5e7eb;}
.coachTbl tbody td{font-size:12px; padding:9px 10px; border-bottom:1px solid #eef2f7; vertical-align:top;}
.coachTbl .grp td{background:#fafafa; font-weight:800; color:#0f172a; border-bottom:1px solid #e5e7eb;}
.coachMono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
.tokenPill{display:inline-flex; align-items:center; padding:4px 8px; border-radius:999px; border:1px solid #e5e7eb; background:#fff; font-size:12px; font-weight:700; color:#0f172a;}
.tokenPill.active{background:rgba(16,185,129,.12); border-color:rgba(16,185,129,.45); color:#065f46;}



/* --- Sidebar overflow hardening (Coach Review / Teams) --- */
#rightPanel, #sidebar, .rightPanel { overflow-x:hidden; }
#coachCard, #coachCard * { box-sizing:border-box; }
#coachCard .subsec { overflow:hidden; }
#coachCard .coachGrid { grid-template-columns: 1fr; }
#coachCard .coachGrid > * { min-width:0; }
#coachCard input, #coachCard select, #coachCard textarea { max-width:100%; min-width:0; }
#coachCard .rowFlex { display:flex; gap:8px; align-items:center; min-width:0; }
#coachCard .rowFlex > * { min-width:0; }
#coachCard .rowFlex input { flex:1 1 auto; width:auto; }
#coachCard .rowFlex button { flex:0 0 auto; white-space:nowrap; }

/* --- Pitch-recognition inspired layout (Diamond IQ) --- */
body{background:#f6f7fb;}
header{position:sticky;top:0;z-index:50;background:rgba(246,247,251,.92);backdrop-filter:saturate(140%) blur(10px);border-bottom:1px solid rgba(0,0,0,.06);}
header h1{font-size:18px;margin:0;}
.header-actions{display:flex;align-items:center;gap:10px;}
.hiddenDock{display:none !important;}
main.app.prLayout{
  /* Allow the main Play pane to grow on wide screens while keeping the sidebar reasonable. */
  max-width: min(1800px, 96vw);
  margin: 18px auto 40px;
  padding: 0 14px;
  display: grid;
  grid-template-columns: clamp(280px, 22vw, 380px) 1fr;
  gap: 18px;
  align-items: start;
}
.sideCol{width:auto; margin:0;}
#playCard{min-height: 520px;}
.playTitleRow{margin-bottom:12px;}
.playHudMount{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;align-items:center;}
#situationCard #situationControlsMount{
  display:flex;
  flex-direction:column;
  gap:10px;
}
#situationCard .sitRow{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:10px;
}
#situationCard .sitRow2{
  gap:8px;
}
#situationCard .sitRow3{
  gap:8px;
}
#situationCard select, #situationCard button{margin:0;}
.subcard{
  margin-top:12px;
  border:1px solid rgba(0,0,0,.08);
  border-radius:14px;
  padding:12px;
  background:#fff;
  box-shadow:none;
}
.subcardTitle{font-weight:800;font-size:13px;margin-bottom:8px;}
.subcardTitleH3{font-weight:900;font-size:16px;margin:0 0 8px;}
/* make the old standalone panels look normal when mounted as subcards */
#situationTargetMount #targetPanel,
#situationSeqMount #seqPanel{border:none;box-shadow:none;padding:0;margin:0;}
#situationTargetMount #targetPanel.hidden,
#situationSeqMount #seqPanel.hidden{display:none;}

/* Hide inner panel headings when used as subcards (we use the subcardTitle instead) */
#situationTargetMount #targetPanelTitle{display:none;}
#situationSeqMount #seqPanel > strong{display:none;}

/* Player card collapse (keeps header visible) */
#playerSidebarCard.collapsed #playerSidebarMount{ display:none !important; }
#playerSidebarCard.collapsed #playerPlayInfoBox{ display:none !important; }

/* Play Info main pane overlay */
#playInfoMainPane{ display:none; }
#playInfoMainPane.active{ display:block; }
#playInfoMainPane .pi-header{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px; }
#playInfoMainPane .pi-title{ font-weight:900; font-size:16px; }

/* @diq:begin [MODE-100] Mode toggle + Pitch Recognition styles */
header .modeToggle{
  margin-left:14px;
  display:inline-flex;
  border:1px solid var(--line);
  background:#fff;
  border-radius:999px;
  overflow:hidden;
  box-shadow: 0 1px 0 rgba(15,23,42,.04);
}
header .modeBtn{
  appearance:none;
  border:0;
  background:transparent;
  padding:8px 12px;
  font-weight:900;
  font-size:12px;
  color:#0b1222;
  cursor:pointer;
  user-select:none;
}
header .modeBtn:hover{ background: rgba(15,23,42,.03); }
header .modeBtn.active{
  background: rgba(246,95,22,.12);
  color: rgba(124,45,18,1);
}

.modePitchOnly{ display:none !important; }
body.mode-pitch .modePitchOnly{ display:block !important; }
body.mode-pitch .modeFieldingOnly{ display:none !important; }

/* Allow hiding Pitch-only cards (like Drill) even while in pitch mode */
body.mode-pitch #drillCard.prLocked{ display:none !important; }

/* Pitch Recognition play area (keeps your clean DIQ card style) */
.prPlayWrap{ display:grid; gap:12px; }
.prHudRow{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:flex-end; }
.prBadge{
  display:inline-flex; align-items:center; gap:6px;
  font-size:12px; font-weight:900;
  border-radius:999px; padding:6px 10px;
  border:1px solid rgba(226,232,240,.95);
  background:#fff;
}
.prBadge.good{ border-color:rgba(22,163,74,.35); background:rgba(22,163,74,.08); color:#16a34a; }
.prBadge.bad{ border-color:rgba(220,38,38,.35); background:rgba(220,38,38,.08); color:#dc2626; }
.prBadge.warn{ border-color:rgba(245,158,11,.35); background:rgba(245,158,11,.10); color:#a16207; }

.prCanvasWrap{
  width:100%;
  border-radius:18px;
  border:1px solid rgba(226,232,240,.95);
  background: radial-gradient(800px 400px at 50% 0%, #ffffff, #f8fafc);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.6);
  overflow:hidden;
  position:relative;
  aspect-ratio: 16 / 12;
  min-height: 320px;
}
#prCanvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }
.prOverlayCenter{ position:absolute; inset:0; display:grid; place-items:center; pointer-events:none; }
.prOverlayCard{
  pointer-events:none;
  background:rgba(255,255,255,.92);
  border:1px solid rgba(226,232,240,.85);
  border-radius:16px;
  padding:12px 14px;
  box-shadow:0 10px 30px rgba(15,23,42,.12);
  display:grid; gap:6px;
  max-width: 360px;
  text-align:center;
}
.loginGateCenter{ position:absolute; inset:0; display:grid; place-items:center; z-index:60; background:rgba(255,255,255,.55); backdrop-filter: blur(2px); }
.loginGateCard{
  pointer-events:auto;
  background:rgba(255,255,255,.94);
  border:1px solid rgba(226,232,240,.90);
  border-radius:16px;
  padding:12px 14px;
  box-shadow:0 10px 30px rgba(15,23,42,.12);
  display:grid; gap:6px;
  max-width: 420px;
  text-align:center;
}
#wrap.lockedNoLogin{ pointer-events:none; filter: saturate(.9) contrast(.98); }
.prAnsGrid{
  display:grid;
  grid-template-columns: repeat(4, 1fr);
  gap:10px;
}
@media (max-width: 520px){ .prAnsGrid{ grid-template-columns:repeat(2,1fr); } }
.prAns{
  border:1px solid rgba(226,232,240,.95);
  background:#fff;
  border-radius:14px;
  padding:12px 10px;
  cursor:pointer;
  font-weight:900;
  user-select:none;
  transition:transform .05s ease, box-shadow .2s ease, border-color .2s ease;
}
.prAns:hover{ border-color:#cbd5e1; box-shadow:0 10px 25px rgba(15,23,42,.06); }
.prAns:active{ transform:translateY(1px); }
.prAns.disabled{ opacity:.55; cursor:not-allowed; }
/* @diq:end [MODE-100] Mode toggle + Pitch Recognition styles */

</style>

</head>
<body>
<!--
  Diamond IQ patch anchors
  - HTML anchors: @diq:begin [H_*] ... @diq:end [H_*]
  - JS anchors:   @diq:begin [A*] ... @diq:end [A*]
  Keep these markers intact to enable reliable copy/paste patching.
-->

<header><h1>Diamond IQ</h1>
  <div class="modeToggle" aria-label="App Mode">
    <button id="btnModeFielding" class="modeBtn active" type="button">Fielding</button>
    <button id="btnModePitch" class="modeBtn" type="button">Pitch Recognition</button>
  </div>
  <div class="header-actions">
    <!-- @diq:begin control:startBtn -->

    <!-- @diq:end control:startBtn -->
    <!-- @diq:begin control:checkBtn -->

    <!-- @diq:end control:checkBtn -->
    <!-- @diq:begin control:continueBtn -->

    <div id="diqHeaderDock" class="hiddenDock" style="display:none !important">
<button id="randomSitBtn" class="btn-slate btn-small" title="Pick a random situation">Random</button><select id="sitSelect" aria-label="Situation" data-testid="sit-select"><option value="BD-01">Situation #1</option><option value="BD-02">Situation #2</option><option value="BD-03">Situation #3</option><option value="BD-04">Situation #4</option><option value="BD-05">Situation #5</option><option value="BD-06">Situation #6</option><option value="BD-07">Situation #7</option><option value="BD-08">Situation #8</option><option value="BD-09">Situation #9</option><option value="BD-10-1">Situation #10-1</option><option value="BD-10-2">Situation #10-2</option><option value="BD-10-3">Situation #10-3</option><option value="BD-11">Situation #11</option><option value="BD-12">Situation #12</option><option value="BD-13">Situation #13</option><option value="BD-14">Situation #14</option><option value="BD-15">Situation #15</option><option value="BD-16">Situation #16</option><option value="BD-17">Situation #17</option><option value="BD-18">Situation #18</option><option value="BD-19">Situation #19</option><option value="BD-20">Situation #20</option></select><span id="descHud" class="badge" title="Single to LF">Single to LF</span><span id="runnersBadge" class="badge"><span style="background:#10b981"></span>Runners: <b><span id="runnersVal">‚Äî</span></b></span><span id="outsHud" class="badge badge-tries" style="margin-left:2px">
    Outs: <b><span id="outsVal">0</span></b>
  </span><button id="startBtn" class="btn-green">Start Situation</button><button id="resetBtn" class="btn-orange" disabled="">Reset</button><button id="checkBtn" class="btn-green" disabled="" data-testid="check-btn">Check Positions</button><button id="continueBtn" class="btn-green hidden" title="Continue to Phase 2">Continue ‚ñ∂</button><button id="verifySeqBtn" class="btn-green hidden">Verify Sequence</button><div id="hud" class="hud">
    <span id="scoreBadge" class="badge badge-score score-red" data-testid="score-badge">Score: <b><span id="scoreVal">0</span>/9</b></span>
    <span id="triesBadge" class="badge badge-tries tries-green">Tries: <b><span id="triesVal">3/3</span></b></span>
    <span id="timerBadge" class="badge badge-timer" title="Time left in this phase">
      ‚è±Ô∏è <b><span id="timerVal">60</span>s</b>
    </span>
  </div>
</div>

    <div class="header-right">
      <!-- @diq:begin [H_PLAYINFO_BTN] Help button -->
      <button id="playInfoTopBtn" class="btn-small btn-slate" type="button" title="How it works">Help</button>
      <!-- @diq:end [H_PLAYINFO_BTN] -->
      <button id="coachBtn" class="btn-slate">Coach Tools</button>
      <button id="adminBtn" class="btn-slate">Admin Tools</button>
    </div>

    <!-- @diq:end control:continueBtn -->
  </div>
</header>

<main class="app prLayout">

  <aside class="sideCol">
    <!-- @diq:begin [H_SIT_CARD] Situation card host -->
    <div class="card modeFieldingOnly" id="situationCard" class="card modeFieldingOnly" style="display:none">
      <div class="cardTitleRow">
        <h1 class="cardTitle" style="margin:0">Situation</h1>
      </div>
      <div id="situationControlsMount"></div>

      <div class="subcard" id="situationTargetSubcard" style="display:none">
        <h3 class="subcardTitle subcardTitleH3">Target Notes</h3>
        <div id="situationTargetMount"></div>
      </div>

      <div class="subcard" id="situationSeqSubcard" style="display:none">
        <h3 class="subcardTitleH3">Play Sequence</h3>
        <div id="situationSeqMount"></div>
      </div>
    </div>
    <!-- @diq:end [H_SIT_CARD] -->

<!-- @diq:begin [H_DRILL_CARD] Drill card host (Pitch Recognition) -->
<div class="card modePitchOnly" id="drillCard" style="display:none">
  <div class="cardTitleRow">
    <h1 class="cardTitle" style="margin:0">Drill</h1>
  </div>

  <div class="fieldRow" style="display:flex; gap:10px; align-items:center; flex-wrap:wrap">
    <div class="fieldHline" style="flex:1; min-width:240px">
      <label for="prDrillSel">Drill</label>
      <select id="prDrillSel"></select>
    </div>
  </div>

  <div class="fieldGrid2" style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px">
    <div class="fieldHline">
      <label for="prRoundsInp">Pitches</label>
      <input id="prRoundsInp" type="number" min="5" max="100" step="1" />
    </div>
    <div class="fieldHline">
      <label for="prShowMsInp">Show (ms)</label>
      <input id="prShowMsInp" type="number" min="80" max="2500" step="10" />
    </div>
    <div class="fieldHline">
      <label for="prLockMsInp">Lock (ms)</label>
      <input id="prLockMsInp" type="number" min="0" max="1200" step="10" />
    </div>
    <div class="fieldHline">
      <label for="prInterMsInp">Between (ms)</label>
      <input id="prInterMsInp" type="number" min="0" max="2500" step="50" />
    </div>
  </div>

  <div class="btnRow" style="display:flex; gap:8px; flex-wrap:wrap; margin-top:10px">
    <button class="btn btn-primary" id="prBtnStart" type="button">Start Round</button>
    <button class="btn" id="prBtnResume" type="button">Resume</button>
    <button class="btn" id="prBtnReset" type="button">Reset</button>
  </div>
</div>
<!-- @diq:end [H_DRILL_CARD] -->



    <div class="card modeFieldingOnly" id="howToCard">
      <details id="howToDetails">
        <summary>
          <strong>How to play (click to expand)</strong>
          <span class="htp-caret" aria-hidden="true">‚ñ∏</span>
        </summary>

        <div class="howto-body">
  
  <div style="font-weight:900; margin:6px 0 2px">Fielding Positions</div>
  <ol style="margin:6px 0 0 1.2em">
    <li>Select a situation from the dropdown (or click <em>Random</em>).</li>
    <li>Review the Description, Runners, and Outs shown in the header.</li>
    <li>Press <em>Start Situation</em> to begin</li>
    <li>Drag the 9 player chips into the correct defensive positions.</li>
    <li>Press <em>Check Positions</em> to verify. You have 3 tries to get them correct.</li>
  </ol>
  <div class="hint" style="margin-top:8px">
    Note: Correct chips will display within a highlighted target ring
  </div>

</div>
      </details>
    </div>

    <!-- Selected Target (appears after last try) -->
    <!-- @diq:begin panel:targetPanel -->
<div id="targetPanel" class="card hidden">
      <strong id="targetPanelTitle">Selected Target</strong>
      <div id="targetPanelBody" style="margin-top:6px; font-size:13px; line-height:1.45"></div>
    </div>

    <!-- Phase 2: Sequence panel -->
    <!-- @diq:begin panel:seqPanel -->
<div id="seqPanel" class="card hidden">
      <strong>Play Sequence</strong>
      <!-- @diq:begin panel:seqBody -->
<div id="seqBody" aria-live="polite" style="margin-top:6px; font-size:13px; line-height:1.45"></div>

    </div>

    <!-- Coach Tools (hidden until unlocked) -->
    
    <div id="playerSidebarCard" class="card collapsed">
      <div class="cardTitleRow">
        <div style="display:flex;align-items:center;gap:10px">
          <h1 class="cardTitle" style="margin:0">Player</h1>
        </div>
        <span class="cardTitleActions" style="margin-left:auto;display:flex;align-items:center;gap:10px">
          <span id="playerStatusBadge" class="badge badge-mini badge-orange">No player logged in</span>
          <button id="playerSidebarCloseBtn" class="btn btn-ghost" type="button">Collapse</button></span>
      </div>
      <div id="playerSidebarMount">
        <div class="subsec">
          <div class="sectionTitle">Player Login</div>
          <div class="rowGrid playerLoginGrid">
            <label class="field fieldHline">
              <span>Team</span>
              <select id="playerTeamSelect" class="select"><option value="">‚Äî Select team ‚Äî</option><option value="13u-black">13U Black</option><option value="13u-orange">13U Orange</option></select>
            </label>

            <label class="field fieldHline">
              <span>Player</span>
              <select id="playerNameSelect" class="select"><option value="">‚Äî Select player ‚Äî</option><option value="13u-black-bob-smith-11">#11 Bob Smith</option><option value="13u-black-john-smith-12">#12 John Smith</option><option value="13u-black-kevin-smith-22">#22 Kevin Smith</option></select>
            </label>
          </div>

          <label class="field" style="margin-top:10px;">
            <span>Password</span>
            <input id="playerPass" class="input" type="password" autocomplete="current-password" placeholder="Password">
          </label>

          <div class="rowGrid" style="margin-top:10px;">
            <div class="pill" id="playerLoginStatus" style="justify-self:start;">Logged in: 13U Black ‚Ä¢ #12 John Smith</div>
            <div style="justify-self:end; display:flex; gap:10px; flex-wrap:wrap;">
              <button id="playerLoginBtn" class="btn btn-brand" type="button" style="display: none;">Login</button>
              <button id="playerLogoutBtn" class="btn btn-ghost" type="button" style="display: inline-flex;">Logout</button>
            </div>
          </div>

          <div id="playerIdLine" class="muted" style="margin-top: 8px; display: block;">
            Player ID: <span id="playerIdText" style="font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;">13u-black-john-smith-12</span>
          </div>
        </div>

        <div class="subsec" style="margin-top:14px;">
          <div class="sectionTitle">Results</div>
          <div class="muted" style="margin-bottom:8px;">
            Share sends a quick coach-friendly report to your coach‚Äôs email (configured for your team).
          </div>
          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <button id="playerShareResultsBtn" class="btn btn-brand" type="button">Share my results</button>
            <button id="playerCopyReviewCodeBtn" class="btn btn-white w-full">Copy Coach Review Code</button>
</div>
          <div class="muted" id="playerShareHint" style="margin-top:8px;">Coach email: coach@example.com</div>
        </div>
      </div>
    </div>

<div id="coachCard" class="card hidden">
      <div class="coachGrid">
  <div class="row">
    <h1 class="coachCardH1">Coach Tools</h1>
    <span id="coachStatus" class="mono" style="color:#64748b">locked</span>
    <span class="hint"> (drag chips, targets &amp; hit marker while unlocked)</span>
  
    <span style="margin-left:auto;display:flex;gap:8px;align-items:center">
      <button id="coachCollapseAllBtn" class="btn-slate" type="button" title="Collapse sections">Collapse all</button>
      <button id="coachExpandAllBtn" class="btn-slate" type="button" title="Expand sections">Expand all</button>
      <button id="coachCardCloseBtn" class="btn btn-ghost" type="button">Close</button>
    </span>
</div>

  <div class="subsec diq-collapsible" id="coachReviewSubsec" style="margin-top:14px;" data-diq-collapsible="1">
        <h3 class="title">Coach Review<span class="diq-chevron">‚ñæ</span></h3>

        
      <div class="diq-body"><div class="muted" style="margin-bottom:10px;">
          Paste a Coach Review Code from a player email to view a clean table + Phase 2 playback.
        </div><div class="grid" style="gap:10px;">
          <label class="field fieldHline">
            <span>Coach Review Code</span>
            <textarea id="coachReviewInput" class="textarea mono" rows="5" placeholder="DIQ1:..."></textarea>
          </label>

          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <button id="coachReviewLoadBtn" class="btn btn-brand" type="button">Load Review</button>
            <button id="coachReviewClearBtn" class="btn btn-ghost" type="button">Clear</button>
          </div>

          <div id="coachReviewMini" class="card" style="padding:10px; background:#fafafa; border:1px solid #e5e7eb; border-radius:12px; display:none;">
            <div class="tiny muted" style="margin-bottom:6px;">Loaded review</div>
            <div id="coachReviewMiniText" style="font-size:13px; line-height:1.35;"></div>
            <div style="margin-top:8px; display:flex; gap:10px; flex-wrap:wrap;">
              <button id="coachReviewOpenBtn" class="btn btn-brand" type="button">Open Report</button>
              <button id="coachReviewCopyCodeBtn" class="btn btn-ghost" type="button">Copy Code</button>
            </div>
          </div>
<div id="coachReviewOutput"></div>
          <div id="coachReviewPlayback"></div>
        </div></div></div>

    <div class="subsec diq-collapsible diq-collapsed" id="teamsSubsec" style="margin-top:14px;" data-diq-collapsible="1">
        <h3 class="title">Teams<span class="diq-chevron">‚ñæ</span></h3>

      <div class="diq-body">
        <div style="display:flex; flex-direction:column; gap:10px; max-width:460px;">
          <label class="field" style="display:flex; flex-direction:column; gap:4px;">
            <span style="font-size:12px; font-weight:700; color:#64748b; line-height:1.1;">Team</span>
            <select id="coachTeamSelect" class="select"></select>
          </label>

          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <button id="teamsCsvTemplateBtn" class="btn btn-white">Download Template</button>
            <button id="teamsCsvSelectedBtn" class="btn btn-white" type="button">Download Selected Team</button>
          </div>
        </div>
</div>
      </div>
    </div>

<div class="subsec diq-collapsible diq-collapsed" id="situationBuilderSubsec" data-diq-collapsible="1">
    <h3 class="title">Situation Builder<span class="diq-chevron">‚ñæ</span></h3>

    

  



      



  <div class="diq-body"><div class="row">
      <button id="newSituationBtn" class="btn-slate">‚ûï New Situation</button>
      <button id="deleteSituationBtn" class="btn-slate" title="Delete current situation" style="color:#ef4444;border-color:#fecaca">üóëÔ∏è Delete Situation</button>
      <button id="saveSituationBtn" class="btn-slate">üîÑ Refresh Situation</button>
    
      <button id="downloadCurrentBtn" class="btn-slate" type="button">‚¨áÔ∏è Download Situation</button>
    </div><div class="row">
      <label class="hint">Title:</label>
      <input id="newTitleInput" type="text" style="flex:1;min-width:120px">
    </div><div class="row">
      <label class="hint">Description:</label>
      <input id="newDescInput" type="text" style="flex:2;min-width:200px">
    </div><div class="row">
      <label class="hint">Outs:</label>
      <select id="outsSelSituation">
        <option value="0">0 outs</option>
        <option value="1">1 out</option>
        <option value="2">2 outs</option>
      </select>
    </div>
    <div class="subsec diq-collapsible diq-collapsed" id="sbRunnersSubsec" data-diq-collapsible="1">
          <div class="title">Runners on Base<span class="diq-chevron">‚ñæ</span></div>

        <div class="diq-body"><span class="hint" style="margin-left:auto">Updates HUD instantly</span><div class="row" id="runnersRow">
            <label class="hint">Select base runners:</label>
            <label><input id="run1B" type="checkbox"> 1B</label>
            <label><input id="run2B" type="checkbox"> 2B</label>
            <label><input id="run3B" type="checkbox"> 3B</label>
          </div></div></div><div class="subsec diq-collapsible diq-collapsed" id="sbTargetsSubsec" data-diq-collapsible="1">
          <div class="title">Targets &amp; Tolerance<span class="diq-chevron">‚ñæ</span></div>
          

          
        <div class="diq-body">
<div class="row" style="gap:10px; align-items:center; margin-top:6px">
            <button id="resetStartsBtn" class="btn-slate" title="Reset player chips to default locations">‚Ü∫ Reset Player Starts</button>
      <button id="sbUndoBtn" class="btn-slate" type="button" title="Undo last edit" disabled>‚Ü© Undo</button>
      <button id="sbRedoBtn" class="btn-slate" type="button" title="Redo" disabled>‚Ü™ Redo</button>
      <span id="situationMsg" class="hint" style="margin-left:auto"></span>
          </div>
<div class="row" style="flex-direction:column; align-items:stretch; gap:8px">
            <div class="row">
              <label class="hint">Target:</label>
              <select id="tolTargetSel"><option value="P">P</option><option value="C">C</option><option value="1B">1B</option><option value="2B">2B</option><option value="SS">SS</option><option value="3B">3B</option><option value="LF">LF</option><option value="CF">CF</option><option value="RF">RF</option></select>
            </div>
            <div class="row">
              <label class="hint">Tolerance:</label>
              <input id="tolNum" type="number" min="5" max="400" step="1" value="65">
              <input id="tolRange" type="range" min="5" max="400" step="1" value="65" style="flex:1">
            </div>
          </div><div class="row" style="flex-direction:column; align-items:stretch; gap:6px">
            <label class="hint" style="font-weight:800">Target Note <span style="font-weight:600; opacity:.8">(optional)</span></label>
            <textarea id="tolNotes" rows="3" placeholder="Enter coaching notes for this target‚Ä¶" style="width:100%; min-height:72px; resize:vertical"></textarea>
</div></div></div><div class="subsec diq-collapsible diq-collapsed" id="sbBallHitSubsec" data-diq-collapsible="1">
          <div class="title">Ball Hit<span class="diq-chevron">‚ñæ</span></div>

          
        <div class="diq-body"><div class="hint">Drag the marker to set the ball‚Äôs landing spot and set batter advance for this situation.</div><button id="testHitBtn" class="btn-green" style="margin-left:auto;padding:4px 8px;font-size:12px;line-height:1.2">‚ñ∂ Test</button><div class="row">
            <label class="hint">Hit type:</label>
            <select id="hitTypeSel">
              <option value="line">Line drive</option>
              <option value="popup">Pop up</option>
              <option value="grounder">Grounder</option>
            </select>
            <select id="advanceSel" title="Batter bases to advance (0‚Äì3)">
              <option value="0">0 (Out)</option>
              <option value="1">1 (Single)</option>
              <option value="2">2 (Double)</option>
              <option value="3">3 (Triple)</option>
            </select>
          </div></div></div><div class="subsec diq-collapsible diq-collapsed" id="seqSubsec" data-diq-collapsible="1">
          <div class="title">Play Sequence<span class="diq-chevron">‚ñæ</span></div>


          <!-- Click-to-add grid -->

          <!-- Sequence list (draggable items) -->

          <!-- Toolbar: templates / clear -->

          <!-- Optional overall coach note (keeps the same id you already use) -->
          
        <div class="diq-body"><span class="hint" style="color:#dc2626">Leave the sequence empty to disable Phase 2 for this situation.</span><div class="hint">Click positions below to add; drag items to reorder; remove with the ‚ùå button.</div><div id="seqPosGrid" class="pos-grid" style="margin-top:6px"><button type="button" class="pos-btn" data-group="Battery">P</button><button type="button" class="pos-btn" data-group="Battery">C</button><button type="button" class="pos-btn" data-group="Infield">1B</button><button type="button" class="pos-btn" data-group="Infield">2B</button><button type="button" class="pos-btn" data-group="Infield">SS</button><button type="button" class="pos-btn" data-group="Infield">3B</button><button type="button" class="pos-btn" data-group="Outfield">LF</button><button type="button" class="pos-btn" data-group="Outfield">CF</button><button type="button" class="pos-btn" data-group="Outfield">RF</button></div><div id="seqList" class="seq-list" aria-live="polite"><div class="seq-item" draggable="true" data-index="0"><div class="seq-num">1</div><div class="seq-tag">LF</div><button type="button" class="seq-remove" title="Remove this step">‚ùå</button></div><div class="seq-item" draggable="true" data-index="1"><div class="seq-num">2</div><div class="seq-tag">SS</div><button type="button" class="seq-remove" title="Remove this step">‚ùå</button></div><div class="seq-item" draggable="true" data-index="2"><div class="seq-num">3</div><div class="seq-tag">2B</div><button type="button" class="seq-remove" title="Remove this step">‚ùå</button></div></div><div class="seq-toolbar">
            <select id="seqTemplateSel" title="Load a common relay">
              <option value="">Template‚Ä¶</option>
              <option value="LF,SS,2B,C">LF ‚Üí SS ‚Üí 2B ‚Üí C (relay home)</option>
              <option value="CF,SS,3B">CF ‚Üí SS ‚Üí 3B (hold runner)</option>
              <option value="RF,1B">RF ‚Üí 1B (hold at first)</option>
              <option value="SS,2B,1B">SS ‚Üí 2B ‚Üí 1B (6-4-3 DP)</option>
            </select>
            <button id="seqClearBtn" class="btn-slate btn-small">Clear sequence</button>
            <span class="hint">Total steps: <b id="seqCountHud">3</b></span>
          </div><div class="row" style="flex-direction:column; align-items:stretch; gap:6px; margin-top:6px">
            <textarea id="seqNoteInput" rows="3" placeholder="Optional coach note shown to players on the Play Sequence card‚Ä¶" class="mono" style="width:100%"></textarea>
          </div></div></div></div></div>

      </div>


    </div>

  <div id="adminCard" class="card hidden">
  <div class="coachGrid">
    <div class="row">
      <h1 class="coachCardH1">Admin</h1>
      <span id="adminStatus" class="mono" style="color:#64748b">locked</span>
      <span class="hint"> (admin-only tools)</span>
    </div>

    <div class="row" style="justify-content:flex-end; gap:8px; margin-top:6px">
      <button id="adminCollapseAllBtn" class="btn-slate" type="button">Collapse all</button>
      <button id="adminExpandAllBtn" class="btn-slate" type="button">Expand all</button>
      <button id="adminCardCloseBtn" class="btn btn-ghost" type="button">Close</button>
    </div>



    <!-- TEAMS (Admin) -->
    <div class="subsec admin-subsec" id="adminTeamsSubsec" data-admin-collapsible="1" data-admin-open="1" style="margin-top:14px;">
      <div class="row" style="justify-content:space-between; align-items:center">
        
        <h3 class="adminTitleH3">TEAMS</h3>
        <button class="btn btn-ghost adminSubsecToggle" type="button" aria-label="Collapse section">‚ñæ</button>
      </div>

      <div class="adminSubsecBody" style="margin-top:10px">
        <div class="muted" style="margin-bottom:10px;">
          Manage teams & rosters. Export <code>teams.json</code> and place it next to <code>index.html</code> and <code>situations.json</code>.
        </div>

        <div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px;">
          <button id="adminTeamsDownloadBtn" class="btn btn-ghost" type="button">Download teams.json</button>
          <button id="adminTeamsCopyBtn" class="btn btn-ghost" type="button">Copy teams.json</button>
          <button id="adminTeamsImportBtn" class="btn btn-ghost" type="button">Import teams JSON</button>
          <button id="adminTeamsResetBtn" class="btn btn-ghost" type="button" title="Clear locally saved teams (does not affect teams.json on disk)">Clear local teams</button>
        </div>
        <div class="mt-3 rounded-xl border border-slate-200 bg-slate-50 p-3" style="margin-bottom:10px;">
          <div class="mt-2 flex flex-wrap gap-2">
            <input id="adminTeamsCsvFile" type="file" accept=".csv,.tsv,.txt,.xlsx" class="hidden">
            <button id="adminTeamsCsvUploadBtn" class="btn btn-white" type="button">Upload CSV</button>
            <button id="adminTeamsCsvTemplateBtn" class="btn btn-white" type="button">Download Template</button>
            <button id="adminTeamsCsvSelectedBtn" class="btn btn-white" type="button">Download Selected Team</button>
          </div>
        </div>


        <div class="rowGrid">
          <label class="field fieldHline">
            <span>Team</span>
            <select id="adminTeamSelect" class="select"></select>
          </label>

          <label class="field fieldHline">
            <span>Team Name</span>
            <input id="adminTeamName" class="input" type="text" placeholder="e.g., 13U Black"/>
          </label>

          <label class="field fieldHline">
            <span>Coach Email</span>
            <input id="adminTeamEmail" class="input" type="email" placeholder="coach@example.com"/>
          </label>
        </div>

        <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
          <button id="adminTeamAddBtn" class="btn btn-brand" type="button">Add Team</button>
          <button id="adminTeamUpdateBtn" class="btn btn-ghost" type="button">Update Team</button>
          <button id="adminTeamRemoveBtn" class="btn btn-ghost" type="button">Remove Team</button>
        </div>

        <div class="divider"></div>

        <h4 class="adminTitleH4">Roster</h4>
        <div class="rowGrid">
          <label class="field fieldHline">
            <span>Player</span>
            <select id="adminRosterSelect" class="select" disabled></select>
          </label>

          <label class="field fieldHline">
            <span>Player Name</span>
            <input id="adminPlayerName" class="input" type="text" placeholder="e.g., John Smith" disabled/>
          </label>

          <label class="field fieldHline">
            <span>Player Number</span>
            <input id="adminPlayerNumber" class="input" type="text" inputmode="numeric" placeholder="e.g., 12" disabled/>
          </label>

          <label class="field fieldHline">
            <span>Password</span>
            <div class="adminPassRow" style="display:flex; gap:8px; align-items:center;">
              <input id="adminPlayerPass" class="input" type="text" placeholder="e.g., 4821" disabled/>
              <button id="adminGenPassBtn" class="btn btn-ghost" type="button" disabled>Gen</button>
            </div>
          </label>
        </div>

        <div class="muted" id="adminPlayerIdPreview" style="margin-top:8px;"></div>

        <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
          <button id="adminPlayerAddBtn" class="btn btn-brand" type="button" disabled>Add Player</button>
          <button id="adminPlayerUpdateBtn" class="btn btn-ghost" type="button" disabled>Update Player</button>
          <button id="adminPlayerRemoveBtn" class="btn btn-ghost" type="button" disabled>Remove Player</button>
        </div>
      </div>
    </div>

    <!-- SITUATIONS (Admin) -->
    <div class="subsec admin-subsec" id="adminSituationsSubsec" data-admin-collapsible="1" data-admin-open="0" style="margin-top:14px;">
      <div class="row" style="justify-content:space-between; align-items:center">
        
        <h3 class="adminTitleH3">SITUATIONS</h3>
        <button class="btn btn-ghost adminSubsecToggle" type="button" aria-label="Collapse section">‚ñæ</button>
      </div>

      <div class="adminSubsecBody" style="margin-top:10px">
        <div class="muted" style="margin-bottom:10px;">
          Import one or more <code>.json</code> files containing an array of situations. Existing keys are merged (imported values win).
        </div>

        <div class="mt-3 rounded-xl border border-slate-200 bg-slate-50 p-3" style="margin-bottom:10px;">
          <div class="mt-2 flex flex-wrap gap-2">
            <input id="adminSituationsJsonFile" type="file" accept=".json,application/json" class="hidden" multiple>
            <button id="adminSituationsJsonUploadBtn" class="btn btn-white" type="button">Upload Situations JSON</button>
            <button id="downloadAllBtn" class="btn btn-white" type="button">Download ALL Situations</button>
            <span id="adminSituationsMsg" class="hint" style="margin-left:auto"></span>
          </div>
        </div>
      </div>
    </div>

  </div>
</div>

  </aside>


  <section class="card" id="playCard">
    <div class="cardTitleRow playTitleRow">
      <h1 class="cardTitle" style="margin:0">Play</h1>
      <div id="playHudMount" class="playHudMount"></div>
    </div>

    <!-- @diq:begin [H_PLAYINFO_PANE] Play Info main pane -->
    <div id="playInfoMainPane" class="subcard modeFieldingOnly">
      <div class="pi-header">
        <div class="pi-title">How it works</div>
        <button id="playInfoBackBtn" class="btn btn-ghost" type="button">Back to Play</button>
      </div>
      <div id="playInfoMainBody"></div>
    </div>
    <!-- @diq:end [H_PLAYINFO_PANE] -->
    <div id="fieldingPlayStage" class="modeFieldingOnly">
    <div id="playStage">

    <div id="wrap" style="--chip-size: 36px; --chip-font: 14px;">
      <img id="fieldImg" src="baseballfield.png" alt="Baseball Field">
      <!-- visual-only layers kept for z-ordering -->
      <div id="targetsLayer" class="overlay"></div>
      <div id="ballLayer" class="overlay"><svg viewBox="0 0 1136.953125 942.53125"></svg></div>
      <!-- chips, rings, and hit marker are appended directly to #wrap -->
    <div class="ball locked" style="display: none; width: 15px; height: 15px; box-shadow: rgb(0, 0, 0) 0px 0px 0px 1px, rgba(0, 0, 0, 0.35) 0px 1px 1px; left: 265.289063px; top: 350.180489px; z-index: 10;"></div><div class="chip Battery locked" style="left: 568.476563px; top: 618.12162px;">P</div><div class="chip Battery locked" style="left: 569.613516px; top: 813.676958px;">C</div><div class="chip Infield locked" style="left: 727.271016px; top: 540.809045px;">1B</div><div class="chip Infield locked" style="left: 695.815313px; top: 439.620527px;">2B</div><div class="chip Infield locked" style="left: 435.453047px; top: 438.104594px;">SS</div><div class="chip Infield locked" style="left: 409.303125px; top: 534.745313px;">3B</div><div class="chip Outfield locked" style="left: 280.448438px; top: 277.036728px;">LF</div><div class="chip Outfield locked" style="left: 578.709141px; top: 132.644124px;">CF</div><div class="chip Outfield locked" style="left: 859.536562px; top: 274.004863px;">RF</div><div class="tgt locked" data-id="P" style="left: 646.168359px; top: 574.159567px; width: 73px; height: 73px; display: none;"><span class="tgt-label">P</span></div><div class="tgt locked" data-id="C" style="left: 757.589766px; top: 706.424708px; width: 74px; height: 74px; display: none;"><span class="tgt-label">C</span></div><div class="tgt locked" data-id="1B" style="left: 733.334766px; top: 602.204325px; width: 65px; height: 65px; display: none;"><span class="tgt-label">1B</span></div><div class="tgt locked" data-id="2B" style="left: 568.855547px; top: 441.515443px; width: 65px; height: 65px; display: none;"><span class="tgt-label">2B</span></div><div class="tgt locked" data-id="SS" style="left: 422.567578px; top: 395.279491px; width: 65px; height: 65px; display: none;"><span class="tgt-label">SS</span></div><div class="tgt locked" data-id="3B" style="left: 408.166172px; top: 602.583308px; width: 65px; height: 65px; display: none;"><span class="tgt-label">3B</span></div><div class="tgt locked" data-id="LF" style="left: 266.047031px; top: 349.801505px; width: 65px; height: 65px; display: none;"><span class="tgt-label">LF</span></div><div class="tgt locked" data-id="CF" style="left: 305.840391px; top: 190.628556px; width: 80px; height: 80px; display: none;"><span class="tgt-label">CF</span></div><div class="tgt locked" data-id="RF" style="left: 747.736172px; top: 382.394062px; width: 80px; height: 80px; display: none;"><span class="tgt-label">RF</span></div></div>
    <div class="loginGateCenter" id="fieldingLoginGate" style="display:none">
      <div class="loginGateCard">
        <div style="font-weight:900">Player login required</div>
        <div class="subtle">Select your Team & Player in the Player card to start Fielding.</div>
      </div>
    </div>
    </div>
</div>

<div id="pitchPlayStage" class="modePitchOnly prPlayWrap" style="display:none">
  <div class="prHudRow">
    <span class="prBadge" id="prHudScore">0 / 0</span>
    <span class="prBadge" id="prHudAcc">Acc: ‚Äî</span>
    <span class="prBadge" id="prHudRt">Avg RT: ‚Äî</span>
    <span class="prBadge warn" id="prHudTimer">Ready</span>
  </div>

  <div class="prCanvasWrap">
    <canvas id="prCanvas"></canvas>
    <div class="prOverlayCenter">
      <div class="prOverlayCard" id="prOverlayCard">
        <div style="font-weight:900">Press Start Round</div>
        <div class="subtle">A pitch will appear briefly, then vanish. Identify it fast.</div>
      </div>
    </div>
  </div>

  <div class="prAnsGrid" id="prAnsGrid"></div>

  <div class="subtle" id="prLastFeedback">‚Äî</div>
</div>
  </section>

  </main>

<!-- Password modal -->
<div id="pwModal">
  <div class="box">
    <div style="font-weight:800;margin-bottom:8px">Enter Coach Password</div>
    <input id="pwInput" type="password" style="width:100%;padding:8px;border:1px solid #e5e7eb;border-radius:8px">
    <div id="pwMsg" style="color:#ef4444;margin-top:6px;min-height:1.2em"></div>
    <div class="row" style="justify-content:flex-end;margin-top:10px">
      <button id="pwOk" class="btn-green">Unlock</button>
      <button id="pwCancel" class="btn-slate">Cancel</button>
    </div>
  </div>
</div>

<!-- Admin password modal -->
<div id="adminPwModal" style="position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:1000">
  <div class="box" style="background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:16px;min-width:280px;box-shadow:0 10px 30px rgba(0,0,0,.25)">
    <div style="font-weight:800;margin-bottom:8px">Enter Admin Password</div>
    <input id="adminPwInput" type="password" style="width:100%;padding:8px;border:1px solid #e5e7eb;border-radius:8px">
    <div id="adminPwMsg" style="color:#ef4444;margin-top:6px;min-height:1.2em"></div>
    <div class="row" style="justify-content:flex-end;margin-top:10px">
      <button id="adminPwOk" class="btn-green">Unlock</button>
      <button id="adminPwCancel" class="btn-slate">Cancel</button>
    </div>
  </div>
</div>

<!-- Player Info Modal -->

  <!-- Player Modal -->
  <div id="playerModalOverlay" class="modalOverlay hidden" style="display:none;">
    <div class="modalPanel">
      <div class="modalHeader">
        <div style="font-weight:800;">Player</div>
        <button id="playerModalCloseX" class="btn btn-ghost" type="button">Close</button>
      </div>

      <div class="modalBody"></div>
    </div>
  </div>

<script>
/// @diq:begin [A0] Constants & pure helpers
// Passwords (edit here)
// Note: Coach Tools password is also used to unlock chip/target editing.
// Keep these near the top for easy updates.
const COACH_PASSWORD = 'coach';
const ADMIN_PASSWORD = 'admin';

// Patch map (JS):
// [A0] Boot / globals
// [A1] Utilities + storage
// [A2] Marker scaling + layout
// [A3] Situation model + selection
// [A4] Targets + tolerance + notes
// [A5] Export / import (situations, results, teams)
// [A6] Player login + results sharing
// [A7] Coach tools + teams/roster editor + results viewer
// Keep begin/end markers intact for patching.
/** @typedef {{ x:number, y:number }} Pt */
/** @typedef {{ [posId:string]: Pt }} Starts */
/** @typedef {{ [posId:string]: {x:number,y:number,tol:number} }} Targets */
/** @typedef {{ first:boolean, second:boolean, third:boolean }} RunnersOn */
/** @typedef {{
 *   key:string, title:string, desc:string,
 *   starts?:Starts, targets?:Targets,
 *   hit?:Pt, hitType?:'line'|'popup'|'grounder',
 *   batterAdvance?:number,
 *   outs?:0|1|2,
 *   runnersOn?:RunnersOn
 * }} Situation */

/** ‚Äúenum‚Äù of position ids, frozen for safety */
const POS_IDS = Object.freeze(['P','C','1B','2B','SS','3B','LF','CF','RF']);

/** Don‚Äôt let defaults accidentally change at runtime */
const DEFAULT_STARTS = Object.freeze({
  P:{x:1500,y:1631},  C:{x:1503,y:2147},
  '1B':{x:1917,y:1461}, '2B':{x:1824,y:1158}, SS:{x:1149,y:1158}, '3B':{x:1119,y:1450},
  LF:{x:742,y:790},  CF:{x:1466,y:482}, RF:{x:2273,y:772}
});
Object.freeze(DEFAULT_STARTS.P); Object.freeze(DEFAULT_STARTS.C);
Object.freeze(DEFAULT_STARTS['1B']); Object.freeze(DEFAULT_STARTS['2B']);
Object.freeze(DEFAULT_STARTS.SS); Object.freeze(DEFAULT_STARTS['3B']);
Object.freeze(DEFAULT_STARTS.LF); Object.freeze(DEFAULT_STARTS.CF); Object.freeze(DEFAULT_STARTS.RF);

const IMG_W=3000, IMG_H=2487;
const DEFAULT_TOL=65;
const HOME_NATIVE = { x:1500, y:2147 };
const BASES_NATIVE = {
  home:{x:1501,y:2032}, first:{x:1903,y:1577}, second:{x:1465,y:1192}, third:{x:1101,y:1630}
};

const TIMER_START_SECS = 60;
let _timerId = null;
let _timerSecs = TIMER_START_SECS;

// --- Player identity + per-situation results (localStorage) ---

  // --- Player identity (base random id + user-entered metadata) ---
  const STORAGE_PLAYER_BASE_ID = "diq_player_baseid_v1";
  const STORAGE_PLAYER_META   = "diq_player_meta_v1";

  function slugify(str){
    return String(str || "")
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/-+/g, "-")
      .replace(/^-|-$/g, "");
  }

  function getOrCreatePlayerBaseId(){
    let base = localStorage.getItem(STORAGE_PLAYER_BASE_ID);
    if(!base){
      // 8-char random (base36), stable per browser/device unless cleared
      base = [...crypto.getRandomValues(new Uint32Array(2))]
        .map(n => n.toString(36).padStart(6,"0"))
        .join("")
        .slice(0,8);
      localStorage.setItem(STORAGE_PLAYER_BASE_ID, base);
    }
    return base;
  }

  function loadPlayerMeta(){
    try{
      const raw = localStorage.getItem(STORAGE_PLAYER_META);
      if(!raw) return {team:"", name:"", number:""};
      const obj = JSON.parse(raw);
      return {
        team: typeof obj.team === "string" ? obj.team : "",
        name: typeof obj.name === "string" ? obj.name : "",
        number: typeof obj.number === "string" ? obj.number : (obj.number!=null ? String(obj.number) : "")
      };
    }catch(e){
      return {team:"", name:"", number:""};
    }
  }

  function savePlayerMeta(meta){
    localStorage.setItem(STORAGE_PLAYER_META, JSON.stringify({
      team: meta.team || "",
      name: meta.name || "",
      number: meta.number || ""
    }));
  }

  let PLAYER_BASE_ID = getOrCreatePlayerBaseId();
  let PLAYER_META = loadPlayerMeta();

  // Ensure cached player session is loaded (and base id exists) on page load.
  // Safe to call multiple times.
  function ensurePlayerMeta(){
    PLAYER_BASE_ID = getOrCreatePlayerBaseId();
    const meta = loadPlayerMeta();
    // Never allow PLAYER_META to be null/undefined ‚Äî app must boot even when logged out.
    PLAYER_META = (meta && typeof meta === 'object') ? meta : {team:"", name:"", number:""};
    if(typeof PLAYER_META.team !== 'string') PLAYER_META.team = (PLAYER_META.team!=null ? String(PLAYER_META.team) : "");
    if(typeof PLAYER_META.name !== 'string') PLAYER_META.name = (PLAYER_META.name!=null ? String(PLAYER_META.name) : "");
    if(typeof PLAYER_META.number !== 'string') PLAYER_META.number = (PLAYER_META.number!=null ? String(PLAYER_META.number) : "");
    try{ refreshPlayerLoginUI(); }catch(_e){}
  }

  function buildPlayerId(){
    const m = (PLAYER_META && typeof PLAYER_META === 'object') ? PLAYER_META : {team:"", name:"", number:""};
    const teamSlug = slugify(m.team) || "team";
    const nameSlug = slugify(m.name) || "player";
    const num = String(m.number || "").trim().replace(/\s+/g,"");
    const numSafe = num ? num.replace(/[^0-9a-zA-Z-]/g,"") : "0";
    return `${PLAYER_BASE_ID}-${teamSlug}-${nameSlug}-${numSafe}`;
  }

  function getPlayerId(){
    // Prefer roster playerId when logged in; fallback to local meta-based id.
    try{
      const cur = getCurrentPlayerFromMeta();
      if(cur && cur.player && cur.player.playerId) return String(cur.player.playerId);
    }catch(_e){}
    return buildPlayerId();
  }

  // --- Teams (Coach-managed) + Player Login ---
  const TEAMS_STORAGE_KEY = "diq_teams_v1";
  let TEAMS = { version: 1, teams: [] };

  function slugifyLoose(str){
    return String(str || "")
      .trim()
      .toLowerCase()
      .replace(/['"]/g, "")
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "");
  }

  function deepClone(obj){
    return JSON.parse(JSON.stringify(obj));
  }

  function normalizeTeamsData(data){
  // Accept multiple top-level keys to be forgiving with hand-edited JSON
  const rawTeams =
    (data && (data.teams || data.Teams || data.TEAMS)) || [];
  const teamsArr = Array.isArray(rawTeams) ? rawTeams : [];

  const out = { version: 1, teams: [] };
  teamsArr.forEach((t, i)=>{
    const name = String((t && (t.name || t.team || t.teamName || t.Team || t.TeamName)) || '').trim();
    const id = String((t && (t.id || t.teamId || t.slug)) || (name ? slugify(name) : ('team-' + (i+1))));
    const coachEmail = String((t && (t.coachEmail || t.coachesEmail || t.coach_email || t.email)) || '').trim();

    const rawRoster =
      (t && (t.roster || t.Roster || t.players || t.Players || t.playerList)) || [];
    const rosterArr = Array.isArray(rawRoster) ? rawRoster : [];

    const roster = rosterArr.map((p, j)=>{
      const playerName = String((p && (p.name || p.playerName || p.player || p.PlayerName)) || '').trim();
      const playerNumber = String((p && (p.number || p.playerNumber || p.num || p.PlayerNumber)) || '').trim();
      const password = String((p && (p.password || p.pass || p.pin || p.PlayerPassword)) || '').trim();
      const playerId = String((p && (p.playerId || p.id)) || '').trim();
      return { name: playerName, number: playerNumber, password, playerId };
    }).filter(p=>p.name && p.number);

    out.teams.push({ id, name, coachEmail, roster: roster.map(p => ({ ...p, playerId: computeRosterPlayerId({id, name}, p) })) });
  });

  return out;
}

function computeRosterPlayerId(teamObj, playerObj){
  // Deterministic, stable ID for roster entries (teams.json schema has no ids).
  if (playerObj && playerObj.playerId) return String(playerObj.playerId);
  const teamSlug = slugifyLoose(teamObj && (teamObj.name || teamObj.id) ? (teamObj.name || teamObj.id) : "team") || "team";
  const nameSlug = slugifyLoose(playerObj && playerObj.name ? playerObj.name : "") || "player";
  const num = String(playerObj && playerObj.number != null ? playerObj.number : "").trim().replace(/\s+/g,"");
  const numSafe = num ? num.replace(/[^0-9a-zA-Z-]/g,"") : "0";
  return `${teamSlug}-${nameSlug}-${numSafe}`;
}

  function saveTeamsToLocal(){
    try{
      localStorage.setItem(TEAMS_STORAGE_KEY, JSON.stringify(TEAMS));
    }catch(e){
      console.warn("Failed to save TEAMS to localStorage", e);
    }
  }

  function loadTeamsFromLocal(){
    try{
      const raw = localStorage.getItem(TEAMS_STORAGE_KEY);
      if(!raw) return null;
      return normalizeTeamsData(JSON.parse(raw));
    }catch(e){
      console.warn("Failed to load TEAMS from localStorage", e);
      return null;
    }
  }

  async function loadTeamsFromJson(){
    // Load teams.json (lives alongside index.html) and cache to localStorage as fallback.
    // This works on GitHub Pages and on any HTTP(S) server. (file:// cannot fetch.)
    const base = new URL('.', window.location.href);
    const url = new URL('teams.json', base);

    try{
      const res = await fetch(url.toString(), { cache: 'no-store' });
      if(!res.ok) throw new Error('HTTP ' + res.status);
      const data = await res.json();
      TEAMS = normalizeTeamsData(data);
      // Persist a copy so the app still works if teams.json is temporarily unavailable
      try{ localStorage.setItem(TEAMS_STORAGE_KEY, JSON.stringify(TEAMS)); }catch(_e){}
      return;
    }catch(err){
      console.warn('[Teams] Unable to load teams.json, falling back to localStorage.', err);
    }

    // Fallback: localStorage copy
    try{
      const raw = localStorage.getItem(TEAMS_STORAGE_KEY);
      TEAMS = raw ? normalizeTeamsData(JSON.parse(raw)) : { teams: [] };
    }catch(_e){
      TEAMS = { teams: [] };
    }
}

  // @diq:begin [A13] Teams CSV upload
  function _csvParseLine(line, delim){
    const out = [];
    let cur = '';
    let inQ = false;
    for(let i=0;i<line.length;i++){
      const ch = line[i];
      if(inQ){
        if(ch === '"'){
          if(line[i+1] === '"'){ cur += '"'; i++; }
          else inQ = false;
        }else{
          cur += ch;
        }
      }else{
        if(ch === '"') inQ = true;
        else if(ch === delim){ out.push(cur); cur=''; }
        else cur += ch;
      }
    }
    out.push(cur);
    return out;
  }

  function parseDelimited(text){
    const raw = String(text || '').replace(/\r\n/g,'\n').replace(/\r/g,'\n');
    const lines = raw.split('\n').filter(l=>l.trim().length>0);
    if(lines.length === 0) return { headers: [], rows: [] };

    const first = lines[0];
    const comma = (first.match(/,/g)||[]).length;
    const tab = (first.match(/\t/g)||[]).length;
    const delim = tab > comma ? '\t' : ',';

    const headers = _csvParseLine(lines[0], delim).map(h=>String(h||'').trim());
    const rows = [];
    for(let i=1;i<lines.length;i++){
      const cols = _csvParseLine(lines[i], delim);
      if(cols.every(c=>String(c||'').trim()==='')) continue;
      const obj = {};
      for(let j=0;j<headers.length;j++){
        obj[headers[j]] = (cols[j]==null ? '' : String(cols[j]).trim());
      }
      rows.push(obj);
    }
    return { headers, rows };
  }

  function _truthyRemove(v){
    const s = String(v||'').trim().toLowerCase();
    return s==='1' || s==='y' || s==='yes' || s==='true' || s==='remove' || s==='delete';
  }

  function _csvEscape(v){
    const s = String(v ?? '');
    if(/[",\n\r\t]/.test(s)){
      return '"' + s.replace(/"/g,'""') + '"';
    }
    return s;
  }

  function _detectDelim(line){
    const comma = (String(line||'').match(/,/g)||[]).length;
    const tab = (String(line||'').match(/\t/g)||[]).length;
    return tab > comma ? '\t' : ',';
  }

  // Parse the v3 block CSV:
  // [TEAMS] team_name,coach_email,remove
  // [PLAYERS] team_name,player_name,player_number,player_password,remove
  function parseTeamsCsvV3(text){
    const raw = String(text || '').replace(/\r\n/g,'\n').replace(/\r/g,'\n');
    const lines = raw.split('\n').map(l=>l.trim()).filter(l=>l.length>0);

    const sections = { TEAMS: [], PLAYERS: [] };
    let cur = null;
    for(const line of lines){
      const up = line.toUpperCase();
      if(up === '[TEAMS]'){ cur = 'TEAMS'; continue; }
      if(up === '[PLAYERS]'){ cur = 'PLAYERS'; continue; }
      if(cur) sections[cur].push(line);
    }

    const parseSection = (arr)=>{
      if(!arr || arr.length===0) return { headers:[], rows:[] };
      const delim = _detectDelim(arr[0]);
      const headers = _csvParseLine(arr[0], delim).map(h=>String(h||'').trim());
      const rows = [];
      for(let i=1;i<arr.length;i++){
        const cols = _csvParseLine(arr[i], delim);
        if(cols.every(c=>String(c||'').trim()==='')) continue;
        const obj = {};
        for(let j=0;j<headers.length;j++){
          obj[headers[j]] = (cols[j]==null ? '' : String(cols[j]).trim());
        }
        rows.push(obj);
      }
      return { headers, rows };
    };

    return { teams: parseSection(sections.TEAMS), players: parseSection(sections.PLAYERS) };
  }

  function applyTeamsCsvV3(parsed){
    const out = { teams:0, players:0, removedTeams:0, removedPlayers:0 };

    const mapHeaders = (headers)=>{
      const m = {};
      (headers||[]).forEach(h=>{
        const k = String(h||'').trim().toLowerCase();
        if(k) m[k]=h;
      });
      return m;
    };

    const get = (row, headerMap, key, alts=[])=>{
      const lk = String(key).toLowerCase();
      if(headerMap[lk]) return row[headerMap[lk]];
      for(const a of alts){
        const la = String(a).toLowerCase();
        if(headerMap[la]) return row[headerMap[la]];
      }
      for(const k in row){
        const kl = String(k).trim().toLowerCase();
        if(kl===lk) return row[k];
        for(const a of alts){
          if(kl===String(a).trim().toLowerCase()) return row[k];
        }
      }
      return '';
    };

    const findTeamByNameLocal = (name)=>{
      const n = String(name||'').trim().toLowerCase();
      const list = (TEAMS && Array.isArray(TEAMS.teams)) ? TEAMS.teams : [];
      for(const t of list){
        if(String(t.name||'').trim().toLowerCase() === n) return t;
      }
      return null;
    };

    // --- TEAMS ---
    const th = mapHeaders(parsed.teams.headers);
    for(const r of (parsed.teams.rows||[])){
      const teamName = String(get(r, th, 'team_name', ['team','name','team name','teamname'])).trim();
      if(!teamName) continue;

      const coachEmail = String(get(r, th, 'coach_email', ['coach email','email','coachemail'])).trim();
      const remove = _truthyRemove(get(r, th, 'remove', ['rm','delete','remove?']));

      const existing = findTeamByNameLocal(teamName);
      if(remove){
        if(existing){
          removeTeam(existing.id);
          out.removedTeams++;
        }
        continue;
      }

      if(!existing){
        upsertTeam(teamName, coachEmail || '');
        out.teams++;
      }else{
        // Do NOT clear coach email when blank (requirement)
        if(coachEmail) existing.coachEmail = coachEmail;
      }
    }

    // --- PLAYERS ---
    const ph = mapHeaders(parsed.players.headers);
    for(const r of (parsed.players.rows||[])){
      const teamName = String(get(r, ph, 'team_name', ['team','team name','teamname'])).trim();
      const playerName = String(get(r, ph, 'player_name', ['player','name','player name','playername'])).trim();
      const playerNum  = String(get(r, ph, 'player_number', ['number','player number','playernumber','jersey','jersey number'])).trim();
      const password   = String(get(r, ph, 'player_password', ['password','pin','passcode','player password','playerpassword'])).trim();
      const remove = _truthyRemove(get(r, ph, 'remove', ['rm','delete','remove?']));

      if(!teamName) continue;
      if(!playerName && !playerNum) continue;

      let t = findTeamByNameLocal(teamName);
      if(!t){
        t = upsertTeam(teamName, '');
        out.teams++;
      }

      if(remove){
        const roster = Array.isArray(t.roster) ? t.roster : [];
        let target = null;

        if(playerNum){
          target = roster.find(p => String(p.number||'').trim() === String(playerNum).trim()) || null;
          if(target && playerName){
            const t2 = roster.find(p => String(p.number||'').trim() === String(playerNum).trim() && String(p.name||'').trim().toLowerCase() === playerName.trim().toLowerCase());
            if(t2) target = t2;
          }
        }
        if(!target && playerName){
          target = roster.find(p => String(p.name||'').trim().toLowerCase() === playerName.trim().toLowerCase()) || null;
        }
        if(!target && playerNum){
          target = roster.find(p => String(p.number||'').trim() === String(playerNum).trim()) || null;
        }

        if(target && target.playerId){
          removePlayer(t.id, target.playerId);
          out.removedPlayers++;
        }
        continue;
      }

      // Upsert: require name+number; password is optional (blank preserves existing when possible)
      if(playerName && playerNum){
        const existingRoster = Array.isArray(t.roster) ? t.roster : [];
        const ex = existingRoster.find(p => String(p.number||'').trim() === String(playerNum).trim() && String(p.name||'').trim().toLowerCase() === playerName.trim().toLowerCase()) || null;
        const passToSet = password ? password : (ex && ex.password ? ex.password : '');
        upsertPlayer(t.id, playerName, playerNum, passToSet);
        out.players++;
      }
    }

    TEAMS = normalizeTeamsData(TEAMS);
    saveTeamsToLocal();
    refreshTeamsUIAll();
    if(typeof adminRefreshAll === 'function') adminRefreshAll();
    return out;
  }

  // Backward-compatible: accept legacy v2 flat CSV OR v3 block CSV.
  function importTeamsFromCsvText(text){
    const raw = String(text || '');
    if(/\[\s*TEAMS\s*\]/i.test(raw) && /\[\s*PLAYERS\s*\]/i.test(raw)){
      const parsed = parseTeamsCsvV3(raw);
      return applyTeamsCsvV3(parsed);
    }
    const parsed = parseDelimited(raw);
    return applyTeamsRosterRows(parsed.rows, parsed.headers);
  }

  function applyTeamsRosterRows(rows, headers){
    // Legacy v2 flat CSV importer (kept for backward compatibility)
    if(!Array.isArray(rows) || rows.length===0) return { teams:0, players:0, removedTeams:0, removedPlayers:0 };

    const headerMap = {};
    (headers||[]).forEach(h=>{
      const k = String(h||'').trim().toLowerCase();
      if(k) headerMap[k]=h;
    });

    const get = (row, key, alts=[])=>{
      const lk = String(key).toLowerCase();
      if(headerMap[lk]) return row[headerMap[lk]];
      for(const a of alts){
        const la = String(a).toLowerCase();
        if(headerMap[la]) return row[headerMap[la]];
      }
      for(const k in row){
        if(String(k).trim().toLowerCase()===lk) return row[k];
        for(const a of alts){
          if(String(k).trim().toLowerCase()===String(a).trim().toLowerCase()) return row[k];
        }
      }
      return '';
    };

    const findTeamByNameLocal = (name)=>{
      const n = String(name||'').trim().toLowerCase();
      const list = (TEAMS && Array.isArray(TEAMS.teams)) ? TEAMS.teams : [];
      for(const t of list){
        if(String(t.name||'').trim().toLowerCase() === n) return t;
      }
      return null;
    };

    const normAction = (a)=>{
      const v = String(a||'').trim().toLowerCase();
      if(!v) return '';
      if(v==='remove' || v==='delete' || v==='del' || v==='rm') return 'remove';
      if(v==='add' || v==='update' || v==='upsert') return 'add';
      return v;
    };

    let teamAdds=0, playerAdds=0, removedTeams=0, removedPlayers=0;

    for(const r of rows){
      const teamName = String(get(r,'Team Name',['Team','TeamName'])).trim();
      if(!teamName) continue;

      const coachEmail = String(get(r,'Coach Email',['CoachEmail','Email'])).trim();
      const playerName = String(get(r,'Player Name',['Player','Name','PlayerName'])).trim();
      const playerNum  = String(get(r,'Player Number',['Number','PlayerNumber','Jersey','Jersey Number'])).trim();
      const password   = String(get(r,'Player Password',['Password','Passcode','PIN','Pin'])).trim();
      const actionRaw  = get(r,'Action',['Op','Operation','Mode']);
      const action = normAction(actionRaw);

      let t = findTeamByNameLocal(teamName);

      const hasAnyPlayerFields = !!(playerName || playerNum);
      if(action === 'remove' && !hasAnyPlayerFields){
        if(t){
          removeTeam(t.id);
          removedTeams++;
        }
        continue;
      }

      if(!t){
        t = upsertTeam(teamName, coachEmail || '');
        teamAdds++;
      }else{
        if(coachEmail) t.coachEmail = coachEmail;
      }

      if(action === 'remove' && t){
        const roster = Array.isArray(t.roster) ? t.roster : [];
        let target = null;

        if(playerNum){
          target = roster.find(p => String(p.number||'').trim() === String(playerNum).trim()) || null;
          if(target && playerName){
            const t2 = roster.find(p => String(p.number||'').trim() === String(playerNum).trim() && String(p.name||'').trim().toLowerCase() === playerName.trim().toLowerCase());
            if(t2) target = t2;
          }
        }
        if(!target && playerName){
          target = roster.find(p => String(p.name||'').trim().toLowerCase() === playerName.trim().toLowerCase()) || null;
        }

        if(target && target.playerId){
          removePlayer(t.id, target.playerId);
          removedPlayers++;
        }
        continue;
      }

      if(t && playerName && playerNum && password){
        const before = (t.roster||[]).length;
        upsertPlayer(t.id, playerName, playerNum, password);
        const after = (t.roster||[]).length;
        if(after >= before) playerAdds++;
      }
    }

    TEAMS = normalizeTeamsData(TEAMS);
    saveTeamsToLocal();
    refreshTeamsUIAll();
    if(typeof adminRefreshAll === 'function') adminRefreshAll();
    return { teams:teamAdds, players:playerAdds, removedTeams, removedPlayers };
  }

  function downloadTeamsCsvTemplate(){
    // v3 clean template (no comment rows)
    const csv = [
      '[TEAMS]',
      'team_name,coach_email,remove',
      '',
      '[PLAYERS]',
      'team_name,player_name,player_number,player_password,remove'
    ].join('\n');
    downloadText('diamondiq_teams_template_v3.csv', csv, 'text/csv');
  }

  function downloadSelectedTeamCsvV3(teamId){
    const id = String(teamId||'').trim();
    if(!id) return null;
    const t = findTeam(id);
    if(!t) return null;

    const lines = [];
    lines.push('[TEAMS]');
    lines.push('team_name,coach_email,remove');
    lines.push([t.name||'', t.coachEmail||'', ''].map(_csvEscape).join(','));
    lines.push('');
    lines.push('[PLAYERS]');
    lines.push('team_name,player_name,player_number,player_password,remove');

    const roster = Array.isArray(t.roster) ? t.roster.slice() : [];
    roster.sort((a,b)=> String(a.number||'').localeCompare(String(b.number||''), undefined, {numeric:true, sensitivity:'base'}) || String(a.name||'').localeCompare(String(b.name||'')));
    for(const p of roster){
      lines.push([t.name||'', p.name||'', p.number!=null ? String(p.number) : '', p.password||'', ''].map(_csvEscape).join(','));
    }
    return lines.join('\n');
  }

  // @diq:end [A13] 


  function findTeam(teamId){
  const id = String(teamId || "").trim();
  if(!id) return null;
  const want = id;
  const wantSlug = slugifyLoose(id);
  return (TEAMS.teams || []).find(t => t.id === want || t.id === wantSlug || slugifyLoose(t.name) === wantSlug) || null;
}
  function findPlayer(teamId, playerId){
  const t = findTeam(teamId);
  if(!t) return null;
  const pid = String(playerId || "").trim();
  const pidSlug = slugifyLoose(pid);
  return (t.roster || []).find(p => p.playerId === pid || slugifyLoose(p.playerId) === pidSlug) || null;
}

  // --- Coach TEAMS UI wiring ---
  const coachTeamSelect = document.getElementById("coachTeamSelect");
  const coachTeamName = document.getElementById("coachTeamName");
  const coachTeamEmail = document.getElementById("coachTeamEmail");
  const coachTeamAddBtn = document.getElementById("coachTeamAddBtn");
  const coachTeamUpdateBtn = document.getElementById("coachTeamUpdateBtn");
  const coachTeamRemoveBtn = document.getElementById("coachTeamRemoveBtn");

  const coachReviewInput = document.getElementById("coachReviewInput");
  const coachReviewLoadBtn = document.getElementById("coachReviewLoadBtn");
  const coachReviewClearBtn = document.getElementById("coachReviewClearBtn");
  const coachReviewOutput = document.getElementById("coachReviewOutput");
  const coachReviewPlayback = document.getElementById("coachReviewPlayback");

  const coachCollapseAllBtn = document.getElementById("coachCollapseAllBtn");
  const coachExpandAllBtn = document.getElementById("coachExpandAllBtn");

  const coachRosterSelect = document.getElementById("coachRosterSelect");
  const coachPlayerName = document.getElementById("coachPlayerName");
  const coachPlayerNumber = document.getElementById("coachPlayerNumber");
  const coachPlayerPass = document.getElementById("coachPlayerPass");
  const coachGenPassBtn = document.getElementById("coachGenPassBtn");
  const coachPlayerIdPreview = document.getElementById("coachPlayerIdPreview");
  const coachPlayerAddBtn = document.getElementById("coachPlayerAddBtn");
  const coachPlayerUpdateBtn = document.getElementById("coachPlayerUpdateBtn");
  const coachPlayerRemoveBtn = document.getElementById("coachPlayerRemoveBtn");

  const teamsDownloadBtn = document.getElementById("teamsDownloadBtn");
  const teamsCopyBtn = document.getElementById("teamsCopyBtn");

  const teamsCsvFile = document.getElementById("teamsCsvFile");
  const teamsCsvUploadBtn = document.getElementById("teamsCsvUploadBtn");
  const teamsCsvTemplateBtn = document.getElementById("teamsCsvTemplateBtn");
  const teamsCsvSelectedBtn = document.getElementById("teamsCsvSelectedBtn");

  const teamsCsvExportBtn = document.getElementById("teamsCsvExportBtn");
function setRosterControlsEnabled(enabled){
    if(coachRosterSelect) coachRosterSelect.disabled = !enabled;
    if(coachPlayerName) coachPlayerName.disabled = !enabled;
    if(coachPlayerNumber) coachPlayerNumber.disabled = !enabled;
    if(coachPlayerPass) coachPlayerPass.disabled = !enabled;
    if(coachGenPassBtn) coachGenPassBtn.disabled = !enabled;
    if(coachPlayerAddBtn) coachPlayerAddBtn.disabled = !enabled;
    if(coachPlayerUpdateBtn) coachPlayerUpdateBtn.disabled = !enabled;
    if(coachPlayerRemoveBtn) coachPlayerRemoveBtn.disabled = !enabled;
  }

  function refreshCoachTeamSelect(){
    if(!coachTeamSelect) return;
    const prev = coachTeamSelect.value;
    coachTeamSelect.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "‚Äî Select team ‚Äî";
    coachTeamSelect.appendChild(opt0);

    (TEAMS.teams || []).forEach(t=>{
      const o = document.createElement("option");
      o.value = t.id;
      o.textContent = t.name || t.id;
      coachTeamSelect.appendChild(o);
    });

    if(prev && findTeam(prev)) coachTeamSelect.value = prev;
  }

  function refreshCoachRosterSelect(){
    if(!coachRosterSelect) return;

    const teamId = coachTeamSelect ? coachTeamSelect.value : "";
    const t = teamId ? findTeam(teamId) : null;

    coachRosterSelect.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "‚Äî Select player ‚Äî";
    coachRosterSelect.appendChild(opt0);

    if(!t){
      setRosterControlsEnabled(false);
      if(coachPlayerIdPreview) coachPlayerIdPreview.textContent = "";
      return;
    }

    setRosterControlsEnabled(true);

    (t.roster || []).forEach(p=>{
      const o = document.createElement("option");
      const pid = (p && p.playerId) ? String(p.playerId) : slugifyLoose(`${(t && t.id) ? t.id : teamId}-${p && p.number ? p.number : ''}-${p && p.name ? p.name : ''}`);
      o.value = pid;
      o.textContent = `${p.number ? "#"+p.number+" " : ""}${p.name}`;
      coachRosterSelect.appendChild(o);
    });

    coachRosterSelect.value = "";
    if(coachPlayerName) coachPlayerName.value = "";
    if(coachPlayerNumber) coachPlayerNumber.value = "";
    if(coachPlayerPass) coachPlayerPass.value = "";
    if(coachPlayerIdPreview) coachPlayerIdPreview.textContent = "";
  }


  function setCoachTeamFieldsFromSelection(){
    if(!coachTeamSelect) return;

    const teamId = coachTeamSelect.value;
    const t = teamId ? findTeam(teamId) : null;

    if(coachTeamName) coachTeamName.value = t ? (t.name || "") : "";
    if(coachTeamEmail) coachTeamEmail.value = t ? (t.coachEmail || "") : "";

    // Only refresh roster controls if those elements exist (coach tools may omit them)
    if(coachRosterSelect) refreshCoachRosterSelect();

    refreshPlayerTeamDropdown(); // keep player UI in sync
    refreshPlayerLoginUI();
  }

  function setCoachPlayerFieldsFromSelection(){
    if(!coachTeamSelect || !coachRosterSelect) return;

    const teamId = coachTeamSelect.value;
    const playerId = coachRosterSelect.value;
    const p = (teamId && playerId) ? findPlayer(teamId, playerId) : null;

    if(coachPlayerName) coachPlayerName.value = p ? (p.name || "") : "";
    if(coachPlayerNumber) coachPlayerNumber.value = p ? (p.number || "") : "";
    if(coachPlayerPass) coachPlayerPass.value = p ? (p.password || "") : "";

    if(coachPlayerIdPreview) coachPlayerIdPreview.textContent = p ? `Player ID: ${p.playerId}` : "";
  }

  function buildPlayerIdForTeam(teamName, playerName, playerNumber, baseId){
    // Deterministic, coach-friendly ID (no random prefix): <team>-<name>-<number>
    // baseId is kept only for backward compatibility in callers (results storage uses baseId separately).
    const teamSlug = slugifyLoose(teamName) || "team";
    const nameSlug = slugifyLoose(playerName) || "player";
    const num = String(playerNumber || "").trim().replace(/\s+/g,"");
    const numSafe = num ? num.replace(/[^0-9a-zA-Z-]/g,"") : "0";
    return `${teamSlug}-${nameSlug}-${numSafe}`;
  }

  function genSimplePassword(){
    // 4-digit numeric
    return String(Math.floor(1000 + Math.random()*9000));
  }

  function randomId(len){
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let out = "";
    for(let i=0;i<len;i++) out += chars[Math.floor(Math.random()*chars.length)];
    return out;
  }


  function upsertTeam(name, email){
    const teamName = String(name || "").trim();
    if(!teamName) return null;
    const id = slugifyLoose(teamName) || "team";

    let t = findTeam(id);
    if(!t){
      t = { id, name: teamName, coachEmail: String(email||"").trim(), roster: [] };
      TEAMS.teams.push(t);
    }else{
      t.name = teamName;
      t.coachEmail = String(email||"").trim();
    }
    TEAMS.teams = TEAMS.teams.sort((a,b)=> (a.name||"").localeCompare(b.name||""));
    saveTeamsToLocal();
    return t;
  }

  function removeTeam(teamId){
    TEAMS.teams = (TEAMS.teams || []).filter(t => t.id !== teamId);
    saveTeamsToLocal();
  }

  function upsertPlayer(teamId, playerName, playerNumber, password){
    const t = findTeam(teamId);
    if(!t) return null;

    const name = String(playerName||"").trim();
    const number = String(playerNumber??"").trim();
    const pass = String(password||"").trim();

    if(!name || !number || !pass) return null;

    // stable baseId per player
    let existing = (t.roster || []).find(p => slugifyLoose(p.name)===slugifyLoose(name) && String(p.number)===String(number));
    if(existing){
      existing.name = name;
      existing.number = number;
      existing.password = pass;
      existing.playerId = buildPlayerIdForTeam(t.name, name, number, existing.baseId);
    }
    else{
      const baseId = randomId(8);
      const playerId = buildPlayerIdForTeam(t.name, name, number, baseId);
      existing = { name, number, password: pass, baseId, playerId };
      t.roster.push(existing);
    }

    t.roster = (t.roster || []).sort((a,b)=> (a.number||"").localeCompare(b.number||"") || (a.name||"").localeCompare(b.name||""));
    saveTeamsToLocal();
    return existing;
  }

  function removePlayer(teamId, playerId){
    const t = findTeam(teamId);
    if(!t) return;
    t.roster = (t.roster || []).filter(p => p.playerId !== playerId);
    saveTeamsToLocal();
  }

  function downloadJson(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
  }

  function downloadText(filename, text, mime='text/plain'){
    const blob = new Blob([String(text ?? '')], { type: mime });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
  }

  // Lightweight toast (non-blocking). Falls back to alert if DOM not ready.
  let _toastEl = null;
  let _toastTimer = null;
  function toast(msg, ms=1800){
    try{
      if(!_toastEl){
        _toastEl = document.createElement('div');
        _toastEl.id = 'diqToast';
        _toastEl.className = 'fixed left-1/2 top-4 -translate-x-1/2 z-[9999] px-4 py-2 rounded-xl border border-slate-200 bg-white shadow-lg text-sm font-semibold text-slate-800 hidden';
        document.body.appendChild(_toastEl);
      }
      _toastEl.textContent = String(msg ?? '');
      _toastEl.classList.remove('hidden');
      if(_toastTimer) clearTimeout(_toastTimer);
      _toastTimer = setTimeout(()=>{ try{ _toastEl.classList.add('hidden'); }catch(e){} }, Math.max(800, ms||0));
    }catch(e){
      // last resort
      try{ alert(String(msg ?? '')); }catch(_){}
    }
  }



  function copyTextToClipboard(text){
    return navigator.clipboard.writeText(text);
  }

  if(coachTeamSelect){
    coachTeamSelect.addEventListener("change", setCoachTeamFieldsFromSelection);
  }
  if(coachRosterSelect){
    coachRosterSelect.addEventListener("change", setCoachPlayerFieldsFromSelection);
  }

  if(coachTeamAddBtn){
    coachTeamAddBtn.addEventListener("click", ()=>{
      const t = upsertTeam(coachTeamName.value, coachTeamEmail.value);
      refreshCoachTeamSelect();
      if(t) coachTeamSelect.value = t.id;
      setCoachTeamFieldsFromSelection();
    });
  }
  if(coachTeamUpdateBtn){
    coachTeamUpdateBtn.addEventListener("click", ()=>{
      const teamId = coachTeamSelect.value;
      if(!teamId) return alert("Select a team to update.");
      // allow rename by updating via current name (will slugify)
      // if slug changes, migrate roster
      const old = findTeam(teamId);
      if(!old) return;
      const newName = String(coachTeamName.value||"").trim();
      const newId = slugifyLoose(newName) || teamId;
      const newEmail = String(coachTeamEmail.value||"").trim();

      if(newId !== teamId){
        // migrate
        const migrated = { id: newId, name: newName, coachEmail: newEmail, roster: deepClone(old.roster || []) };
        // rebuild playerIds with new team name/slug
        migrated.roster.forEach(p=>{
          p.playerId = buildPlayerIdForTeam(migrated.name, p.name, p.number, p.baseId);
        });
        removeTeam(teamId);
        TEAMS.teams.push(migrated);
      }else{
        old.name = newName || old.name;
        old.coachEmail = newEmail;
        // rebuild playerIds with team name changes
        (old.roster||[]).forEach(p=>{
          p.playerId = buildPlayerIdForTeam(old.name, p.name, p.number, p.baseId);
        });
      }

      TEAMS.teams = TEAMS.teams.sort((a,b)=> (a.name||"").localeCompare(b.name||""));
      saveTeamsToLocal();
      refreshCoachTeamSelect();
      coachTeamSelect.value = newId;
      setCoachTeamFieldsFromSelection();
    });
  }
  if(coachTeamRemoveBtn){
    coachTeamRemoveBtn.addEventListener("click", ()=>{
      const teamId = coachTeamSelect.value;
      if(!teamId) return alert("Select a team to remove.");
      if(!confirm("Remove this team and its roster?")) return;
      removeTeam(teamId);
      refreshCoachTeamSelect();
      coachTeamSelect.value = "";
      setCoachTeamFieldsFromSelection();
    });
  }

  if(coachGenPassBtn){
    coachGenPassBtn.addEventListener("click", ()=>{
      coachPlayerPass.value = genSimplePassword();
      // update preview
      const t = findTeam(coachTeamSelect.value);
coachPlayerIdPreview.textContent = `Player ID preview: ${buildPlayerIdForTeam(t ? t.name : coachTeamName.value, coachPlayerName.value, coachPlayerNumber.value, baseId)}`;
    });
  }

  function refreshCoachPlayerIdPreview(){
    const teamId = coachTeamSelect.value;
    const t = teamId ? findTeam(teamId) : null;
    if(!t){
      coachPlayerIdPreview.textContent = "";
      return;
    }
const preview = buildPlayerIdForTeam(t.name, coachPlayerName.value, coachPlayerNumber.value, baseId);
    coachPlayerIdPreview.textContent = `Player ID preview: ${preview}`;
  }

  ["input","change"].forEach(ev=>{
    if(coachPlayerName) coachPlayerName.addEventListener(ev, refreshCoachPlayerIdPreview);
    if(coachPlayerNumber) coachPlayerNumber.addEventListener(ev, refreshCoachPlayerIdPreview);
    if(coachTeamName) coachTeamName.addEventListener(ev, ()=>{
      // if team name is being edited, preview updates, but actual ids rebuild on update
      refreshCoachPlayerIdPreview();
    });
  });

  if(coachPlayerAddBtn){
    coachPlayerAddBtn.addEventListener("click", ()=>{
      const teamId = coachTeamSelect.value;
      if(!teamId) return alert("Select a team first.");
      const pass = coachPlayerPass.value || genSimplePassword();
      coachPlayerPass.value = pass;
      const p = upsertPlayer(teamId, coachPlayerName.value, coachPlayerNumber.value, pass);
      if(!p) return alert("Enter player name, number, and password.");
      refreshCoachRosterSelect();
      coachRosterSelect.value = p.playerId;
      setCoachPlayerFieldsFromSelection();
      refreshPlayerTeamDropdown();
      refreshPlayerLoginUI();
    });
  }
  if(coachPlayerUpdateBtn){
    coachPlayerUpdateBtn.addEventListener("click", ()=>{
      const teamId = coachTeamSelect.value;
      const selectedPlayerId = coachRosterSelect.value;
      if(!teamId || !selectedPlayerId) return alert("Select a player to update.");
      const t = findTeam(teamId);
      const old = findPlayer(teamId, selectedPlayerId);
      if(!t || !old) return;

      // Update the record in-place (keep baseId)
      old.name = String(coachPlayerName.value||"").trim();
      old.number = String(coachPlayerNumber.value||"").trim();
      old.password = String(coachPlayerPass.value||"").trim();
      old.playerId = buildPlayerIdForTeam(t.name, old.name, old.number, old.baseId);

      t.roster = (t.roster || []).sort((a,b)=> (a.number||"").localeCompare(b.number||"") || (a.name||"").localeCompare(b.name||""));
      saveTeamsToLocal();
      refreshCoachRosterSelect();
      coachRosterSelect.value = old.playerId;
      setCoachPlayerFieldsFromSelection();
      refreshPlayerTeamDropdown();
      refreshPlayerLoginUI();
    });
  }
  if(coachPlayerRemoveBtn){
    coachPlayerRemoveBtn.addEventListener("click", ()=>{
      const teamId = coachTeamSelect.value;
      const playerId = coachRosterSelect.value;
      if(!teamId || !playerId) return alert("Select a player to remove.");
      if(!confirm("Remove this player from the roster?")) return;
      removePlayer(teamId, playerId);
      refreshCoachRosterSelect();
      refreshPlayerTeamDropdown();
      refreshPlayerLoginUI();
    });
  }

  if(teamsDownloadBtn){
    teamsDownloadBtn.addEventListener("click", ()=>{
      downloadJson("teams.json", TEAMS);
    });
  }
  if(teamsCopyBtn){
    teamsCopyBtn.addEventListener("click", ()=>{
      const txt = JSON.stringify(TEAMS, null, 2);
      copyTextToClipboard(txt)
        .then(()=> alert("Teams JSON copied."))
        .catch(()=>{ alert("Clipboard copy failed. Use Download teams.json instead."); });
    });
  }

  // Teams CSV upload (Excel-friendly)
  if(teamsCsvUploadBtn && teamsCsvFile){
    teamsCsvUploadBtn.addEventListener("click", ()=> teamsCsvFile.click());
    teamsCsvFile.addEventListener("change", ()=>{
      const f = teamsCsvFile.files && teamsCsvFile.files[0];
      if(!f) return;
      const name = String(f.name||'').toLowerCase();
      if(name.endsWith(".xlsx")){
        alert("Please export your Excel file as CSV first (File ‚Üí Save As ‚Üí CSV), then upload the CSV.");
        teamsCsvFile.value = "";
        return;
      }
      const reader = new FileReader();
      reader.onload = ()=>{
        try{
          const text = String(reader.result || "");
          const parsed = parseDelimited(text);
          const res = applyTeamsRosterRows(parsed.rows, parsed.headers);
          toast(`Roster import complete. Added/updated: ${res.players}. Removed players: ${res.removedPlayers||0}. Removed teams: ${res.removedTeams||0}.`);
        }catch(e){
          alert("Could not import CSV: " + (e && e.message ? e.message : e));
        }finally{
          teamsCsvFile.value = "";
        }
      };
      reader.onerror = ()=>{
        alert("Could not read file.");
        teamsCsvFile.value = "";
      };
      reader.readAsText(f);
    });
  }
  if(teamsCsvTemplateBtn){
    teamsCsvTemplateBtn.addEventListener("click", ()=>{
      downloadTeamsCsvTemplate();
    });
  }

  if(teamsCsvSelectedBtn){
    teamsCsvSelectedBtn.addEventListener("click", ()=>{
      const teamId = (coachTeamSelect && coachTeamSelect.value) ? String(coachTeamSelect.value||'') : (playerTeamSelect && playerTeamSelect.value) ? String(playerTeamSelect.value||'') : '';
      if(!teamId) return alert('Select a team first.');
      const csv = downloadSelectedTeamCsvV3(teamId);
      if(!csv) return alert('Could not export selected team.');
      const safeTeam = (findTeam(teamId) && findTeam(teamId).name) ? findTeam(teamId).name : 'team';
      downloadText(`diamondiq_${slugify(safeTeam)}_v3.csv`, csv, 'text/csv');
    });
  }

  if(teamsCsvExportBtn){
    teamsCsvExportBtn.addEventListener("click", ()=>{
      downloadTeamsCsvExport();
    });
  }


  function refreshTeamsUIAll(){
    // Coach Teams UI may be intentionally minimal/absent; guard calls accordingly
    if(coachTeamSelect){
      refreshCoachTeamSelect();
      setCoachTeamFieldsFromSelection();
    }
    refreshPlayerTeamDropdown();
    refreshPlayerLoginUI();
  }

  // --- Player login UI wiring ---
const playerModalOverlay = document.getElementById("playerModalOverlay");
  const playerModalCloseX = document.getElementById("playerModalCloseX");
  const playerTeamSelect = document.getElementById("playerTeamSelect");
  const playerNameSelect = document.getElementById("playerNameSelect");
  const playerPassInput = document.getElementById("playerPass");
  const playerLoginBtn = document.getElementById("playerLoginBtn");
  const playerLogoutBtn = document.getElementById("playerLogoutBtn");
  const playerLoginStatus = document.getElementById("playerLoginStatus");
  const playerIdLine = document.getElementById("playerIdLine");
  const playerIdText = document.getElementById("playerIdText");

  const playerShareResultsBtn = document.getElementById("playerShareResultsBtn");

  const playerCopyReviewCodeBtn = document.getElementById("playerCopyReviewCodeBtn");
const playerShareHint = document.getElementById("playerShareHint");

  function getCurrentPlayerFromMeta(){
    // PLAYER_META is global (loaded from STORAGE_PLAYER_META); must be null-safe.
    const m = (PLAYER_META && typeof PLAYER_META === 'object') ? PLAYER_META : {team:"", name:"", number:""};
    const teamId = slugifyLoose(m.team || "");
    if(!teamId) return null;
    const team = findTeam(teamId);
    if(!team) return null;
    const num = String(m.number || "").trim();
    const name = String(m.name || "").trim();
    const p = (team.roster || []).find(x => String(x.number).trim()===num && slugifyLoose(x.name)===slugifyLoose(name)) || null;
    if(!p) return null;
    return { team, player: p };
  }

  function refreshPlayerTeamDropdown(){
    if(!playerTeamSelect) return;
    const prev = playerTeamSelect.value;
    playerTeamSelect.innerHTML = "";
    const o0 = document.createElement("option");
    o0.value = "";
    o0.textContent = "‚Äî Select team ‚Äî";
    playerTeamSelect.appendChild(o0);

    (TEAMS.teams || []).forEach(t=>{
      const o = document.createElement("option");
      o.value = t.id;
      o.textContent = t.name || t.id;
      playerTeamSelect.appendChild(o);
    });

    if(prev && findTeam(prev)) playerTeamSelect.value = prev;
  }

  function refreshPlayerNameDropdown(){
    if(!playerNameSelect) return;
    const teamId = playerTeamSelect.value;
    const t = teamId ? findTeam(teamId) : null;

    playerNameSelect.innerHTML = "";
    const o0 = document.createElement("option");
    o0.value = "";
    o0.textContent = "‚Äî Select player ‚Äî";
    playerNameSelect.appendChild(o0);

    if(!t){
      playerNameSelect.disabled = true;
      return;
    }

    (t.roster || []).forEach(p=>{
      const o = document.createElement("option");
      const pid = (p && p.playerId) ? String(p.playerId) : slugifyLoose(`${(t && t.id) ? t.id : teamId}-${p && p.number ? p.number : ''}-${p && p.name ? p.name : ''}`);
      o.value = pid;
      o.textContent = `${p.number ? "#"+p.number+" " : ""}${p.name}`;
      playerNameSelect.appendChild(o);
    });

    playerNameSelect.disabled = false;
  }

  function setPlayerUIForLoggedIn(){
    const cur = getCurrentPlayerFromMeta();
    if(cur){
      playerLoginStatus.textContent = `Logged in: ${cur.team.name} ‚Ä¢ #${cur.player.number} ${cur.player.name}`;      playerIdLine.style.display = "block";
      playerIdText.textContent = cur.player.playerId;

      playerLoginBtn.style.display = "none";
      playerLogoutBtn.style.display = "inline-flex";

      playerShareResultsBtn.disabled = false;
// set selects to match meta
      const teamId = cur.team.id;
      playerTeamSelect.value = teamId;
      refreshPlayerNameDropdown();
      playerNameSelect.value = cur.player.playerId;

      playerShareHint.textContent = cur.team.coachEmail ? `Coach email: ${cur.team.coachEmail}` : "No coach email configured for this team (ask coach to add one).";
    }else{
      playerLoginStatus.textContent = "Not logged in";      playerIdLine.style.display = "none";
      playerIdText.textContent = "";

      playerLoginBtn.style.display = "inline-flex";
      playerLogoutBtn.style.display = "none";

      playerShareResultsBtn.disabled = true;
playerShareHint.textContent = "";
    }

  try{
    const sitCard = document.getElementById('situationCard');
    if(sitCard){
      sitCard.style.display = (cur && cur.team && cur.player) ? '' : 'none';
    }
  }catch(_e){}


  // Update top status badge in card header
  try{ updatePlayerStatusBadge(cur); }catch(_e){}

  }

  function refreshPlayerLoginUI(){
    // Preserve current UI selections (don't clobber player pick while logged out)
    const prevTeam = playerTeamSelect && playerTeamSelect.value ? String(playerTeamSelect.value) : "";
    const prevPlayer = playerNameSelect && playerNameSelect.value ? String(playerNameSelect.value) : "";

    // Rebuild team dropdown from TEAMS
    refreshPlayerTeamDropdown();

    // Determine desired team
    const cur = getCurrentPlayerFromMeta();
    let desiredTeam = "";
    if(cur && cur.team && cur.team.id){
      desiredTeam = String(cur.team.id);
    }else if(prevTeam){
      desiredTeam = prevTeam;
    }else{
      const metaTeamId = slugifyLoose(((PLAYER_META && typeof PLAYER_META==='object') ? PLAYER_META.team : '') || "");
      if(metaTeamId && findTeam(metaTeamId)) desiredTeam = metaTeamId;
    }
    if(desiredTeam && findTeam(desiredTeam)){
      playerTeamSelect.value = desiredTeam;
    }

    // Rebuild player dropdown for chosen team
    refreshPlayerNameDropdown();

    // Determine desired player
    if(cur && cur.player && cur.player.playerId){
      playerNameSelect.value = String(cur.player.playerId);
    }else if(prevPlayer){
      const exists = Array.from(playerNameSelect.options || []).some(o => o && o.value === prevPlayer);
      if(exists) playerNameSelect.value = prevPlayer;
    }

    // Do NOT clear password here; only clear on successful login / explicit actions.
    setPlayerUIForLoggedIn();

    // keep header Player Login button state in sync (no refresh needed)

    // If we're in Pitch Recognition mode, re-apply mode so Drill/Start buttons unlock immediately after login changes
    try{ if(typeof DIQMode !== "undefined" && DIQMode && typeof DIQMode.apply==="function"){ DIQMode.apply(DIQMode.getStored ? DIQMode.getStored() : "fielding"); } }catch(e){}
}

  
  function updatePlayerCollapseToggleBtn(){
    const card = document.getElementById("playerSidebarCard");
    const btn = document.getElementById("playerSidebarCloseBtn");
    if(!card || !btn) return;
    const collapsed = card.classList.contains("collapsed");
    btn.textContent = collapsed ? "Expand" : "Collapse";
  }

  function updatePlayerStatusBadge(cur){
    const badge = document.getElementById("playerStatusBadge");
    if(!badge) return;
    if(cur && cur.player){
      badge.classList.remove("badge-orange");
      badge.classList.add("badge-green");
      badge.textContent = `#${cur.player.number} ${cur.player.name}`;
    }else{
      badge.classList.remove("badge-green");
      badge.classList.add("badge-orange");
      badge.textContent = "No player logged in";
    }
  }

function mountPlayerSidebar(){
    const card = document.getElementById("playerSidebarCard");
    const mount = document.getElementById("playerSidebarMount");
    if(!card || !mount || !playerModalOverlay) return;

    // Move the existing Player modal body into the sidebar mount (avoid duplicate IDs)
    const body = playerModalOverlay.querySelector(".modalBody");
    if(body && mount.childNodes.length === 0){
      while(body.firstChild) mount.appendChild(body.firstChild);
    }

    // Disable the overlay/modal UX (we're using the sidebar now)
    playerModalOverlay.style.display = "none";
    playerModalOverlay.classList.add("hidden");

    const closeBtn = document.getElementById("playerSidebarCloseBtn");
    if(closeBtn){
      closeBtn.addEventListener("click", ()=>{
        const isCollapsed = card.classList.contains("collapsed");
        if(isCollapsed) card.classList.remove("collapsed");
        else card.classList.add("collapsed");
        updatePlayerCollapseToggleBtn();
      });
    }
  
  updatePlayerCollapseToggleBtn();
}

function isPlayerLoggedInNow(){
  const cur = getCurrentPlayerFromMeta();
  return !!(cur && cur.player && cur.team);
}
  // expose for header button logic (avoids scoping quirks)
  window.isPlayerLoggedInNow = isPlayerLoggedInNow;

  if(playerTeamSelect){
    playerTeamSelect.addEventListener("change", ()=>{
      refreshPlayerNameDropdown();
    });
  }

  function doPlayerLogin(){
    const teamId = playerTeamSelect.value;
    const playerId = playerNameSelect.value;
    const pass = String(playerPassInput.value || "").trim();

    if(!teamId) return alert("Select a team.");
    if(!playerId) return alert("Select a player.");
    const t = findTeam(teamId);
    const p = findPlayer(teamId, playerId);
    if(!t || !p) return alert("Invalid team/player selection.");
    if(!pass) return alert("Enter your password.");
    if(String(p.password || "").trim() !== pass){
      return alert("Incorrect password.");
    }

    // Persist player identity for this browser/session
    PLAYER_META = { team: t.name, name: p.name, number: p.number };
    savePlayerMeta(PLAYER_META);

    // Switch results storage to this player's base id
    try{
      localStorage.setItem(STORAGE_PLAYER_BASE_ID, p.baseId);
    }catch(e){}
    PLAYER_BASE_ID = p.baseId;

    // Reload results for this player base id
    loadResults();

    refreshPlayerLoginUI();
alert("Logged in.");
  
  // Ensure dropdowns are populated once the sidebar is mounted
  try{ refreshTeamsUIAll(); }catch(_e){}
}

  function doPlayerLogout(){
    if(!confirm("Logout?")) return;
    // Clear player meta & base id
    PLAYER_META = { team:"", name:"", number:"" };
    savePlayerMeta(PLAYER_META);
    try{ localStorage.removeItem(STORAGE_PLAYER_BASE_ID); }catch(e){}
    PLAYER_BASE_ID = getOrCreatePlayerBaseId(); // back to anon/random
    loadResults();

    refreshPlayerLoginUI();
}

  if(playerLoginBtn) playerLoginBtn.addEventListener("click", doPlayerLogin);
  if(playerLogoutBtn) playerLogoutBtn.addEventListener("click", doPlayerLogout);

  function formatCoachFriendlySummary(payload){
    const lines = [];
    lines.push("Diamond IQ Results");
    lines.push("------------------");
    lines.push(`Player ID: ${payload.playerId || ""}`);
    if(payload.playerMeta){
      lines.push(`Player: ${payload.playerMeta.name || ""} #${payload.playerMeta.number || ""}`);
      lines.push(`Team: ${payload.playerMeta.team || ""}`);
    }
    if(payload.generatedAt) lines.push(`Generated: ${payload.generatedAt}`);
    lines.push("");

    const by = payload.bySituation || {};
    const keys = Object.keys(by);
    lines.push(`Situations recorded: ${keys.length}`);
    lines.push("");

    keys.sort().forEach(k=>{
      const r = by[k];
      const title = r.title || k;
      const p1 = r.phase1 || {};
      const p2 = r.phase2 || {};
      lines.push(`${k} ‚Äî ${title}`);
      if(p1.attempts != null){
        lines.push(`  Phase 1: attempts=${p1.attempts}, best=${p1.bestPct ?? "‚Äî"}%, correct=${p1.lastCorrect ? "yes" : "no"}`);
      }
      if(p2.attempts != null){
        lines.push(`  Phase 2: attempts=${p2.attempts}, correct=${p2.lastCorrect ? "yes" : "no"}`);
      }
      if(r.lastPlayedAt){
        lines.push(`  Last played: ${r.lastPlayedAt}`);
      }
      lines.push("");
    });

    return lines.join("\n");
  }

  function mailtoEncode(s){
    return encodeURIComponent(String(s ?? '')).replace(/%0D%0A/g,'%0A');
  }

  function _fmtSecs(v){
    const n = Number(v);
    if(!Number.isFinite(n)) return '‚Äî';
    return (Math.round(n*10)/10).toFixed(1)+'s';
  }
  function _fmtIsoLocal(ts){
    if(!ts) return '‚Äî';
    try{ return new Date(ts).toLocaleString(); }catch(e){ return String(ts); }
  }
  function _padRight(s, w){
    s = String(s==null?'':s);
    return s.length >= w ? s.slice(0, w-1)+'‚Ä¶' : (s + ' '.repeat(w - s.length));
  }

  // Option A: Quick Summary + Situations Table (plain-text email friendly)
  function buildQuickCoachReportOptionA(cur){
    const teamName = (cur && cur.team && cur.team.name) ? cur.team.name : (PLAYER_META.team || '‚Äî');
    const playerName = (cur && cur.player && cur.player.name) ? cur.player.name : (PLAYER_META.name || '‚Äî');
    const playerNum  = (cur && cur.player && cur.player.number!=null) ? cur.player.number : (PLAYER_META.number || '‚Äî');

    const exportedAtStr = new Date().toLocaleString();
    const attempts = (RESULTS && Array.isArray(RESULTS.log)) ? RESULTS.log.length : 0;

    const by = (RESULTS && RESULTS.bySituation && typeof RESULTS.bySituation === 'object') ? RESULTS.bySituation : {};
    const keys = Object.keys(by);
    keys.sort((a,b)=>{
      const ta = (by[a] && by[a].lastTs) ? Date.parse(by[a].lastTs) : 0;
      const tb = (by[b] && by[b].lastTs) ? Date.parse(by[b].lastTs) : 0;
      return tb - ta || String(a).localeCompare(String(b), undefined, {numeric:true, sensitivity:'base'});
    });

    const rows = keys.map(k=>{
      const s = by[k] || {};
      const title = s.title || '';
      const p1 = s.bestPhase1 ? `${s.bestPhase1.score}/${s.bestPhase1.total} ‚Ä¢ t${s.bestPhase1.triesUsed ?? '‚Äî'} ‚Ä¢ ${_fmtSecs(s.bestPhase1.timeElapsed)}` : '‚Äî';
      const p2s1 = s.lastPhase2Stage1 ? `${s.lastPhase2Stage1.success ? '‚úÖ' : '‚ùå'} ‚Ä¢ t${s.lastPhase2Stage1.triesUsed ?? '‚Äî'} ‚Ä¢ ${_fmtSecs(s.lastPhase2Stage1.timeElapsed)}` : '‚Äî';
      const p2s2 = s.lastPhase2Stage2 ? `${s.lastPhase2Stage2.success ? '‚úÖ' : '‚ùå'} ‚Ä¢ t${s.lastPhase2Stage2.triesUsed ?? '‚Äî'} ‚Ä¢ ${_fmtSecs(s.lastPhase2Stage2.timeElapsed)}` : '‚Äî';
      const att = s.attempts != null ? String(s.attempts) : '0';
      const last = s.lastTs ? _fmtIsoLocal(s.lastTs) : '‚Äî';
      return { key:String(k), title:String(title), p1, p2s1, p2s2, attempts:att, last };
    });

    const subject = `Diamond IQ Results ‚Äî ${teamName} ‚Äî #${playerNum} ${playerName}`;

    const header = [
      _padRight('Key', 10),
      _padRight('Title', 22),
      _padRight('Phase 1', 20),
      _padRight('P2 Seq', 18),
      _padRight('P2 S2', 18),
      _padRight('Att', 4),
      'Last'
    ].join(' | ');
    const sep = '-'.repeat(header.length);

    const table = rows.length ? rows.map(r=>[
      _padRight(r.key, 10),
      _padRight(r.title, 22),
      _padRight(r.p1, 20),
      _padRight(r.p2s1, 18),
      _padRight(r.p2s2, 18),
      _padRight(r.attempts, 4),
      r.last
    ].join(' | ')).join('\n') : '(No attempts recorded yet.)';

    const body =
`Diamond IQ ‚Äî Quick Report

Player: ${teamName} ‚Äî #${playerNum} ${playerName}
Date: ${exportedAtStr}
Attempts recorded: ${attempts}

Situations:
${header}
${sep}
${table}

Notes:
- (Coach can add notes here after reviewing.)`;

    return { subject, body };
  }
  // Option B: Coach Review Code (paste into Coach Tools)
  function _b64urlEncode(str){
    const utf8 = encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (m,p)=> String.fromCharCode(parseInt(p,16)));
    return btoa(utf8).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  }
  function _b64urlDecode(b64url){
    let b64 = String(b64url || '').replace(/-/g,'+').replace(/_/g,'/');
    while(b64.length % 4) b64 += '=';
    const bin = atob(b64);
    const esc = bin.split('').map(c=>'%'+('00'+c.charCodeAt(0).toString(16)).slice(-2)).join('');
    return decodeURIComponent(esc);
  }

  function buildCoachReviewPayload(dayKey){
    const cur = getCurrentPlayerFromMeta();
    if(!cur) return null;

    const teamName = (cur.team && cur.team.name) ? cur.team.name : (PLAYER_META.team || '‚Äî');
    const playerName = (cur.player && cur.player.name) ? cur.player.name : (PLAYER_META.name || '‚Äî');
    const playerNum  = (cur.player && cur.player.number!=null) ? cur.player.number : (PLAYER_META.number || '‚Äî');

    const rows = buildDailyAttemptRows(dayKey);
    return {
      v: 1,
      exportedAt: new Date().toISOString(),
      dayKey,
      team: { name: teamName, id: cur.team && cur.team.teamId ? cur.team.teamId : undefined },
      player: { name: playerName, number: playerNum, id: cur.player && cur.player.playerId ? cur.player.playerId : undefined },
      attempts: rows
    };
  }

  function encodeCoachReviewCode(payload){
    const json = JSON.stringify(payload);
    return `DIQ1:${_b64urlEncode(json)}`;
  }

  function decodeCoachReviewCode(code){
    const raw = String(code || '').trim();
    if(!raw) throw new Error('Empty code');
    const cleaned = raw.replace(/\s+/g,''); // allow pasted with line breaks
    if(!cleaned.startsWith('DIQ1:')) throw new Error('Not a DIQ1 code');
    const json = _b64urlDecode(cleaned.slice(5));
    const obj = JSON.parse(json);
    if(!obj || obj.v !== 1) throw new Error('Unsupported version');
    return obj;
  }

  function copyTextToClipboard(txt){
    if(navigator.clipboard && navigator.clipboard.writeText){
      return navigator.clipboard.writeText(txt);
    }
    const ta = document.createElement('textarea');
    ta.value = txt;
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    try{ document.execCommand('copy'); }catch(e){}
    document.body.removeChild(ta);
    return Promise.resolve();
  }

  // Coach Review render + playback (Phase 2 sequence)
  let _coachPlayTimer = null;
  function _stopCoachPlayback(pbId){
    if(_coachPlayTimer){ clearInterval(_coachPlayTimer); _coachPlayTimer = null; }
    const wrap = document.getElementById(pbId || 'coachReviewModalPlayback') || document.getElementById('coachReviewPlayback');
    if(wrap) wrap.innerHTML = '';
  }

  function renderCoachReview(obj){
    const esc = (s)=> String(s??'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

    const teamName = obj.team && obj.team.name ? obj.team.name : '‚Äî';
    const playerName = obj.player && obj.player.name ? obj.player.name : '‚Äî';
    const playerNum = obj.player && obj.player.number!=null ? obj.player.number : '‚Äî';
    const dayKey = obj.dayKey || '‚Äî';

    const attempts = Array.isArray(obj.attempts) ? obj.attempts : [];
    const attemptedSituations = new Set(attempts.map(r=>r.situationKey).filter(Boolean));

    // Mini summary in sidebar
    const mini = document.getElementById('coachReviewMini');
    const miniText = document.getElementById('coachReviewMiniText');
    if(mini && miniText){
      mini.style.display = 'block';
      miniText.innerHTML = `
        <div><span class="muted">Team:</span> <b>${esc(teamName)}</b></div>
        <div><span class="muted">Player:</span> <b>#${esc(playerNum)} ${esc(playerName)}</b></div>
        <div><span class="muted">Date:</span> <b>${esc(dayKey)}</b></div>
        <div><span class="muted">Attempts:</span> <b>${esc(attempts.length)}</b> &nbsp; <span class="muted">Situations:</span> <b>${esc(attemptedSituations.size)}</b></div>
      `;
    }

    // Group by situation
    const grouped = {};
    for(const r of attempts){
      const k = r.situationKey || '(unknown)';
      if(!grouped[k]) grouped[k] = { title: r.situationTitle || '', desc: r.situationDesc || '', outs: (r.outs==null?'':r.outs), runnersOn: (r.runnersOn||null), rows: [] };
      if(r.situationTitle) grouped[k].title = r.situationTitle;
      grouped[k].rows.push(r);
    }
    const keys = Object.keys(grouped).sort((a,b)=>a.localeCompare(b, undefined, {numeric:true, sensitivity:'base'}));

    const meta = document.getElementById('coachReviewModalMeta');
    const out = document.getElementById('coachReviewModalOutput');
    if(meta) meta.textContent = `${teamName} ‚Äî #${playerNum} ${playerName} ‚Äî ${dayKey} ‚Äî Attempts ${attempts.length}`;
    if(out) out.innerHTML = '';
    _stopCoachPlayback('coachReviewModalPlayback');

    if(!out) return;

    if(keys.length === 0){
      out.innerHTML = '<div class="tiny muted">No attempts in this code.</div>';
      return;
    }

    let bodyRows = '';
    const playMap = [];
    for(const k of keys){
      const g = grouped[k];
      {
      const desc = g.desc ? ` ‚Ä¢ ${esc(g.desc)}` : '';
      const outsTxt = (g.outs!=='' && g.outs!=null) ? ` ‚Ä¢ Outs: ${esc(g.outs)}` : '';
      const runnersTxt = (()=>{ 
        const ro = g.runnersOn || {};
        const any = !!(ro.first || ro.second || ro.third);
        if(!g.runnersOn) return '';
        if(!any) return ' ‚Ä¢ Runners: ‚Äî';
        const parts = [];
        if(ro.first) parts.push('1B');
        if(ro.second) parts.push('2B');
        if(ro.third) parts.push('3B');
        return ` ‚Ä¢ Runners: ${esc(parts.join(','))}`;
      })();
      bodyRows += `<tr class="grp"><td colspan="11">${esc(k)} ‚Äî ${esc(g.title || '')}${desc}${outsTxt}${runnersTxt}</td></tr>`;
    }
      for(const r of g.rows){                        let playBtn = `<span class="text-slate-400 text-xs">‚Äî</span>`;
        if(Array.isArray(r.playbackPicked) && r.playbackPicked.length){
          const playIndex = playMap.length;
          playMap.push({ attempt: { picked: r.playbackPicked.slice() }, label: `${r.situationKey} #${r.attemptNo || ''}` });
          playBtn = `<button class="btn btn-white btn-xs" data-play-index="${playIndex}">Play</button>`;
        }

const posBadgeCls = (r.posResult==='SUCCESS') ? 'score-green' : (r.posResult==='FAIL' ? 'score-red' : 'score-yellow');
        const posBadge = (r.posResult && r.posResult!=='‚Äî')
          ? `<span class="badge badge-mini ${posBadgeCls}">${esc(r.posResult)}</span>`
          : `<span class="text-slate-400 text-xs">‚Äî</span>`;

        let posScoreBadge = `<span class="text-slate-400 text-xs">‚Äî</span>`;
        const pc = (r.posScoreCorrect==null?null:Number(r.posScoreCorrect));
        const pt = (r.posScoreTotal==null?null:Number(r.posScoreTotal));
        if(r.posScore && pc!=null && pt!=null && !Number.isNaN(pc) && !Number.isNaN(pt) && pt>0){
          const cls = (pc>=pt) ? 'score-green' : (pc>0 ? 'score-yellow' : 'score-red');
          posScoreBadge = `<span class="badge badge-mini ${cls}">${esc(r.posScore)}</span>`;
        }

        const triesBadge = (num)=>{
          if(num==null || Number.isNaN(num)) return `<span class="text-slate-400 text-xs">‚Äî</span>`;
          const n = Math.max(0, Math.floor(num));
          let cls = 'score-yellow';
          if(n <= 1) cls = 'score-green';
          else if(n >= MAX_TRIES) cls = 'score-red';
          return `<span class="badge badge-mini ${cls}">${n}/${MAX_TRIES}</span>`;
        };

        const posTriesBadge = triesBadge(r.posTriesUsedNum==null?null:Number(r.posTriesUsedNum));
        const seqTriesBadge = triesBadge(r.seqTriesUsedNum==null?null:Number(r.seqTriesUsedNum));

        let seqBadge = `<span class="text-slate-400 text-xs">‚Äî</span>`;
        const seqVal = (r.seqResult || '').trim();
        if(seqVal && seqVal !== '‚Äî'){
          // If any FAIL in the summary, mark red. If both SUCCESS and no FAIL, green. Otherwise yellow.
          const up = seqVal.toUpperCase();
          let cls = 'score-yellow';
          if(up.includes('FAIL')) cls = 'score-red';
          else if(up.includes('SUCCESS') && !up.includes('FAIL')) cls = 'score-green';
          seqBadge = `<span class="badge badge-mini ${cls}">${esc(seqVal)}</span>`;
        }

        bodyRows += `
          <tr>
            <td class="coachMono">${esc(r.time || '')}</td>
            <td class="coachMono num">${esc(r.attemptNo || '')}</td>

            <td class="coachMono">${posBadge}</td>
            <td class="coachMono num">${posScoreBadge}</td>
            <td class="coachMono num">${posTriesBadge}</td>
            <td class="coachMono num">${esc(r.posElapsed || '')}</td>

            <td class="coachMono">${seqBadge}</td>
            <td class="coachMono num">${seqTriesBadge}</td>
            <td class="coachMono num">${esc(r.seqElapsed || '')}</td>

            <td class="coachMono">${esc(r.details || '')}</td>
            <td class="num">${playBtn}</td>
          </tr>
        `;

      }
    }

    out.innerHTML = `
      <div class="coachTblWrap">
        <table class="coachTbl">
          <thead>
            <tr>
              <th>Time</th>
              <th class="num">#</th>
              <th>Position Result</th>
              <th class="num">Pos Score</th>
              <th class="num">Pos Tries</th>
              <th class="num">Pos Time</th>
              <th>Sequence Result</th>
              <th class="num">Seq Tries</th>
              <th class="num">Seq Time</th>
              <th>Selected Sequence</th>
              <th class="num">Playback</th>
            </tr>
          </thead>
          <tbody>${bodyRows}</tbody>
        </table>
      </div>
    `;

    out.querySelectorAll('button[data-play-index]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const i = Number(btn.getAttribute('data-play-index'));
        const item = playMap[i];
        if(!item) return;
        startCoachPlayback(item.attempt, item.label, 'coachReviewModalPlayback');
      });
    });
  }

// Coach Review autoload helper (URL hash: #coachReview=...)
function _diqTryAutoloadCoachReview(){
  if(!_pendingCoachReviewCode) return false;
  try{
    if(coachReviewInput) coachReviewInput.value = _pendingCoachReviewCode;
    const obj = decodeCoachReviewCode(_pendingCoachReviewCode);
    renderCoachReview(obj);
    if(typeof openCoachReviewModal === 'function') openCoachReviewModal();
    if(typeof toast === 'function') toast('Coach Review report loaded from link.');
    return true;
  }catch(e){
    alert("Could not load Coach Review Code from link: " + (e && e.message ? e.message : e));
    return false;
  }finally{
    _pendingCoachReviewCode = null;
  }
}
window._diqCoachReviewAutoload = _diqTryAutoloadCoachReview;


  function startCoachPlayback(attempt, label, pbId){
    const pb = document.getElementById(pbId || 'coachReviewModalPlayback') || document.getElementById('coachReviewPlayback');
    if(!pb) return;
    _stopCoachPlayback(pbId);

    const tokens = Array.isArray(attempt.picked) ? attempt.picked.slice() : [];
    if(tokens.length === 0){
      pb.innerHTML = '<div class="tiny muted">No sequence data to play.</div>';
      return;
    }

    let idx = 0;

    const render = ()=>{
      const pills = tokens.map((t, i)=>{
        const cls = (i === idx) ? 'tokenPill active' : 'tokenPill';
        return `<span class="${cls}">${String(t)}</span>`;
      }).join(' ');

      pb.innerHTML = `
        <div class="card" style="padding:10px;">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
            <div style="font-weight:900;">Playback <span class="muted coachMono" style="font-weight:700; font-size:12px;">${String(label||'')}</span></div>
            <div style="display:flex; gap:8px; flex-wrap:wrap;">
              <button id="coachPlayPrev" class="btn btn-ghost" type="button">Prev</button>
              <button id="coachPlayToggle" class="btn btn-ghost" type="button">${_coachPlayTimer ? 'Pause' : 'Play'}</button>
              <button id="coachPlayNext" class="btn btn-ghost" type="button">Next</button>
              <button id="coachPlayStop" class="btn btn-ghost" type="button">Stop</button>
            </div>
          </div>
          <div style="margin-top:8px; display:flex; flex-wrap:wrap; gap:8px;">${pills}</div>
        </div>
      `;

      const prev = pb.querySelector('#coachPlayPrev');
      const next = pb.querySelector('#coachPlayNext');
      const stop = pb.querySelector('#coachPlayStop');
      const tog  = pb.querySelector('#coachPlayToggle');

      if(prev) prev.onclick = ()=>{ idx = Math.max(0, idx-1); render(); };
      if(next) next.onclick = ()=>{ idx = Math.min(tokens.length-1, idx+1); render(); };
      if(stop) stop.onclick = ()=>{ _stopCoachPlayback(pbId); };

      if(tog){
        tog.onclick = ()=>{
          if(_coachPlayTimer){
            clearInterval(_coachPlayTimer); _coachPlayTimer = null;
            tog.textContent = 'Play';
          }else{
            tog.textContent = 'Pause';
            _coachPlayTimer = setInterval(()=>{
              idx += 1;
              if(idx >= tokens.length){
                clearInterval(_coachPlayTimer); _coachPlayTimer = null;
                idx = tokens.length-1;
                render();
              }else{
                render();
              }
            }, 650);
          }
        };
      }
    };

    render();

    // Autoplay once started via Play button for a "replay" feel
    _coachPlayTimer = setInterval(()=>{
      idx += 1;
      if(idx >= tokens.length){
        clearInterval(_coachPlayTimer); _coachPlayTimer = null;
        idx = tokens.length-1;
        render();
      }else{
        render();
      }
    }, 650);
  }

  function _dayKeyLocal(d){
    const dt = (d instanceof Date) ? d : new Date(d);
    const y = dt.getFullYear();
    const m = String(dt.getMonth()+1).padStart(2,'0');
    const da = String(dt.getDate()).padStart(2,'0');
    return `${y}-${m}-${da}`;
  }
  function _timeLocal(ts){
    try{
      const dd = new Date(ts);
      return dd.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
    }catch(e){ return '‚Äî'; }
  }
  function _safe(s){ return String(s==null?'':s); }

  function buildDailyAttemptRows(dayKey){
  // Build per-situation, per-attempt rows for the given day (one row per full attempt)
  const rows = [];
  if(!RESULTS?.log?.length) return rows;

  const start = new Date(`${dayKey}T00:00:00`);
  const end   = new Date(`${dayKey}T23:59:59.999`);

  const evts = RESULTS.log
    .filter(e=>{
      const ts = new Date(e.ts || 0);
      return ts >= start && ts <= end;
    })
    .sort((a,b)=> (new Date(a.ts||0).getTime()) - (new Date(b.ts||0).getTime()));

  const byKey = {}; // situationKey -> { title, desc, outs, runnersOn, attempts:[], attemptNo:number }

  const fmtTime = (ts)=>{
    try{ return new Date(ts).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'}); }
    catch{ return ''; }
  };

  const seqStr = (arr)=>{
    if(!Array.isArray(arr) || !arr.length) return '';
    return arr.join(' ‚Üí ');
  };

  for(const e of evts){
    // Coach Review rows are anchored on Phase 2 attempts (which may include Phase 1 outcome)
    if(e.phase !== 2) continue;
    if(!e.situationKey) continue;

    const k = e.situationKey;
    if(!byKey[k]){
      byKey[k] = {
        title: _safe(e.situationTitle),
        desc: _safe(e.situationDesc),
        outs: (e.outs==null?'':_safe(e.outs)),
        runnersOn: (e.runnersOn==null?null:e.runnersOn),
        attempts: [],
        attemptNo: 0
      };
    }

    const g = byKey[k];

    if(Number(e.stage) === 1){
      // Stage 1 record begins a new attempt
      g.attemptNo += 1;

      const attempt = {
        situationKey: k,
        situationTitle: g.title,
        situationDesc: g.desc,
        outs: g.outs,
        runnersOn: g.runnersOn,

        ts: e.ts || 0,
        time: fmtTime(e.ts || 0),
        attemptNo: g.attemptNo,

        // Phase 1 (tokens/chips)
        posOk: (e.phase1Ok==null?null:!!e.phase1Ok),
        posTriesUsed: (e.phase1TriesUsed==null?'' : _safe(e.phase1TriesUsed)),

        posTriesUsedNum: (e.phase1TriesUsed==null?null:Number(e.phase1TriesUsed)),
        posElapsed: (e.phase1Elapsed==null?'' : _safe(e.phase1Elapsed) + 's'),

        posScoreCorrect: (e.phase1ScoreCorrect==null?'' : _safe(e.phase1ScoreCorrect)),
        posScoreTotal: (e.phase1ScoreTotal==null?'' : _safe(e.phase1ScoreTotal)),

        // Phase 2 (sequence/relay) stage 1 + stage 2
        seq1Ok: (e.success==null?null:!!e.success),
        seq2Ok: null,
        seqTriesUsed: (e.triesUsed==null?'' : _safe(e.triesUsed)),
        seqTriesUsedNum: (e.triesUsed==null?null:Number(e.triesUsed)),
        seqElapsed: (e.timeElapsed==null?'' : _safe(e.timeElapsed) + 's'),

        seq1: Array.isArray(e.picked) ? e.picked.slice() : [],
        seq2: []
      };

      g.attempts.push(attempt);
      continue;
    }

    if(Number(e.stage) === 2){
      // Stage 2 record attaches to the last attempt for this situationKey
      const last = g.attempts[g.attempts.length-1];
      if(last){
        last.seq2Ok = (e.success==null?null:!!e.success);
        last.seq2 = Array.isArray(e.picked) ? e.picked.slice() : [];
      }
      continue;
    }
  }

  // Flatten into rows
  Object.keys(byKey).sort().forEach(k=>{
    byKey[k].attempts.forEach(a=>{
      const s1 = seqStr(a.seq1);
      const s2 = seqStr(a.seq2);
      let detail = s1;
      if(s2) detail = `${s1}  |  S2: ${s2}`;

      // Sequence result summary
      let seqSummary = '‚Äî';
      if(a.seq1Ok==null) seqSummary = '‚Äî';
      else if(a.seq2Ok==null) seqSummary = (a.seq1Ok ? 'SUCCESS' : 'FAIL');
      else seqSummary = `S1:${a.seq1Ok?'SUCCESS':'FAIL'} / S2:${a.seq2Ok?'SUCCESS':'FAIL'}`;

      rows.push({
        situationKey: a.situationKey,
        situationTitle: a.situationTitle,
        situationDesc: a.situationDesc,
        outs: a.outs,
        runnersOn: a.runnersOn,

        ts: a.ts,
        time: a.time,
        attemptNo: a.attemptNo,

        // Phase 1 columns
        posResult: (a.posOk==null?'‚Äî':(a.posOk?'SUCCESS':'FAIL')),
        posTries: a.posTriesUsed,
        posTriesUsedNum: a.posTriesUsedNum,
        posTriesDisplay: (a.posTriesUsedNum==null||Number.isNaN(a.posTriesUsedNum)) ? '' : `${a.posTriesUsedNum}/${MAX_TRIES}`,
        posElapsed: a.posElapsed,
        posScore: (a.posScoreCorrect!=='' && a.posScoreTotal!=='') ? `${a.posScoreCorrect}/${a.posScoreTotal}` : '',
        posScoreCorrect: a.posScoreCorrect,
        posScoreTotal: a.posScoreTotal,

        // Phase 2 columns
        seqResult: seqSummary,
        seqTries: a.seqTriesUsed,
        seqTriesUsedNum: a.seqTriesUsedNum,
        seqTriesDisplay: (a.seqTriesUsedNum==null||Number.isNaN(a.seqTriesUsedNum)) ? '' : `${a.seqTriesUsedNum}/${MAX_TRIES}`,
        seqElapsed: a.seqElapsed,

        details: detail,

        playbackPicked: a.seq1
      });
    });
  });

  return rows;
}

function shareResultsByEmail(){
    const cur = getCurrentPlayerFromMeta();
    if(!cur) return alert("Login first.");

    const coachEmail = String(cur.team.coachEmail || "").trim();
    if(!coachEmail){
      alert("No coach email configured for your team. Ask your coach to add one in TEAMS.");
      return;
    }

    const dayKey = _dayKeyLocal(new Date());
    const payload = buildCoachReviewPayload(dayKey);
    const code = encodeCoachReviewCode(payload);

    const teamName = (cur.team && cur.team.name) ? cur.team.name : (PLAYER_META.team || '‚Äî');
    const playerName = (cur.player && cur.player.name) ? cur.player.name : (PLAYER_META.name || '‚Äî');
    const playerNum  = (cur.player && cur.player.number!=null) ? cur.player.number : (PLAYER_META.number || '‚Äî');

    const subject = `Diamond IQ Results ${teamName} #${playerNum} ${playerName} - ${dayKey}`;

    const body =
`Hi Coach,

Here are the Diamond IQ Results ${teamName} #${playerNum} ${playerName} - ${dayKey}

Coach Review Code:
${code}

(Use Coach Tools ‚Üí Coach Review to paste this code.)`; 
const mailto = `mailto:${encodeURIComponent(coachEmail)}?subject=${mailtoEncode(subject)}&body=${mailtoEncode(body)}`;
    window.location.href = mailto;
  }

  if(playerShareResultsBtn){
    playerShareResultsBtn.addEventListener("click", shareResultsByEmail);
  }



  function resultsStorageKey(){
    return STORAGE_RESULTS_PREFIX + PLAYER_BASE_ID;
  }

  if(playerCopyReviewCodeBtn){
    playerCopyReviewCodeBtn.addEventListener('click', async ()=>{
      const cur = getCurrentPlayerFromMeta();
      if(!cur) return alert("Login first.");
      const dayKey = _dayKeyLocal(new Date());
      const payload = buildCoachReviewPayload(dayKey);
      const code = encodeCoachReviewCode(payload);
      await copyTextToClipboard(code);
      toast("Coach Review Code copied.");
    });
  }

  function loadResults(){
    try{
      const raw = localStorage.getItem(resultsStorageKey());
      if(!raw) return { playerBaseId: PLAYER_BASE_ID, playerId: "", log: [], bySituation: {} };
      const obj = JSON.parse(raw) || {};
      return {
        playerBaseId: PLAYER_BASE_ID,
        playerId: (typeof obj.playerId === "string") ? obj.playerId : "",
        log: Array.isArray(obj.log) ? obj.log : [],
        bySituation: (obj.bySituation && typeof obj.bySituation === "object") ? obj.bySituation : {}
      };
    }catch(e){
      return { playerBaseId: PLAYER_BASE_ID, playerId: "", log: [], bySituation: {} };
    }
  }
  function saveResults(){
    try{
      localStorage.setItem(resultsStorageKey(), JSON.stringify(RESULTS));
    }catch(e){
      // ignore quota / privacy mode errors
    }
  }


let RESULTS = loadResults();
if(!RESULTS.playerId) RESULTS.playerId = getPlayerId();
if(RESULTS.playerId !== getPlayerId()) RESULTS.playerId = getPlayerId();
saveResults();

function recordAttempt(entry){
  try{
    const e = Object.assign({ playerId: getPlayerId(), ts: new Date().toISOString() }, entry || {});
    RESULTS.log.push(e);

    const key = e.situationKey;
    if(key){
      const prev = RESULTS.bySituation[key] || {};
      const next = Object.assign({}, prev);
      next.key = key;
      next.title = e.situationTitle || prev.title || '';
      next.attempts = (prev.attempts || 0) + 1;
      next.lastTs = e.ts;

      // Phase 1 best score
      if(e.phase === 1 && Number.isFinite(e.score) && Number.isFinite(e.total)){
        const best = prev.bestPhase1 || null;
        const cand = { score: e.score, total: e.total, triesUsed: e.triesUsed, timeElapsed: e.timeElapsed, ts: e.ts };
        if(!best || cand.score > best.score || (cand.score === best.score && (cand.triesUsed||999) < (best.triesUsed||999))){
          next.bestPhase1 = cand;
        }else{
          next.bestPhase1 = best;
        }
      }

      // Phase 2 stage results
      if(e.phase === 2 && (e.stage === 1 || e.stage === 2)){
        const field = (e.stage === 2) ? 'lastPhase2Stage2' : 'lastPhase2Stage1';
        next[field] = { success: !!e.success, triesUsed: e.triesUsed, timeElapsed: e.timeElapsed, picked: e.picked || [], ts: e.ts };
      }

      RESULTS.bySituation[key] = next;
    }
    saveResults();
  }catch(err){}
}
// --- end results ---

const Fcopy = o => JSON.parse(JSON.stringify(o));
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const clampInt=(v,min,max)=>{v=Math.floor(Number(v)); if(Number.isNaN(v)) v=min; return clamp(v,min,max);};
// --- Guard to ignore programmatic changes in input handlers
let _muteCoachInputs = false;
function withInputMute(fn){
  _muteCoachInputs = true;
  try { fn(); } finally { _muteCoachInputs = false; }
}

function safeSetText(el, text){ if (el) el.textContent = String(text ?? ''); }
function safeSetValue(el, val){ if (el) el.value = String(val ?? ''); }

const lerp=(a,b,t)=>a+(b-a)*t;
function quadBezier(p0,p1,p2,t){return {x:(1-t)*(1-t)*p0.x+2*(1-t)*t*p1.x+t*t*p2.x,y:(1-t)*(1-t)*p0.y+2*(1-t)*t*p1.y+t*t*p2.y};}

// --- How To Play templates + renderer ---
const HOWTO_PHASE1_HTML = `
  <div style="font-weight:900; margin:6px 0 2px">Fielding Positions</div>
  <ol style="margin:6px 0 0 1.2em">
    <li>Select a situation from the dropdown (or click <em>Random</em>).</li>
    <li>Review the Description, Runners, and Outs shown in the header.</li>
    <li>Press <em>Start Situation</em> to begin</li>
    <li>Drag the 9 player chips into the correct defensive positions.</li>
    <li>Press <em>Check Positions</em> to verify. You have 3 tries to get them correct.</li>
  </ol>
  <div class="hint" style="margin-top:8px">
    Note: Correct chips will display within a highlighted target ring
  </div>
`;

const HOWTO_PHASE2_HTML = `
  <div style="font-weight:900; margin:6px 0 2px">Relay Sequence</div>
  <ol style="margin:6px 0 0 1.2em">
    <li>Select <em>Continue</em> to begin</li>
    <li>Select the players (chips) in the correct throw order to execute the play.</li>
    <li>Click chips to add them to your sequence; click again to unselect (unless a chip is already locked as correct).</li>
    <li>Press <em>Verify Sequence</em> to check your picks. You have 3 tries.</li>
  </ol>
  <div class="hint" style="margin-top:8px">
    Note: Correct chips (in the proper order) will lock and remain highlighted.
  </div>
`;



const HOWTO_HELP_HTML = `
  <div style="font-weight:900; margin:6px 0 2px">Fielding Positions</div>
  <ol style="margin:6px 0 0 1.2em">
    <li>Select a situation from the dropdown (or click <em>Random</em>).</li>
    <li>Review the Description, Runners, and Outs shown in the header.</li>
    <li>Press <em>Start Situation</em> to begin</li>
    <li>Drag the 9 player chips into the correct defensive positions.</li>
    <li>Press <em>Check Positions</em> to verify. You have 3 tries to get them correct.</li>
  </ol>
  <div class="hint" style="margin-top:8px">
    Note: Correct chips will display within a highlighted target ring
  </div>

  <div style="height:12px"></div>

  <div style="font-weight:900; margin:6px 0 2px">Relay Sequence</div>
  <ol style="margin:6px 0 0 1.2em">
    <li>Select <em>Continue</em> to begin</li>
    <li>Select the players (chips) in the correct throw order to execute the play.</li>
    <li>Click chips to add them to your sequence; click again to unselect (unless a chip is already locked as correct).</li>
    <li>Press <em>Verify Sequence</em> to check your picks. You have 3 tries.</li>
  </ol>
  <div class="hint" style="margin-top:8px">
    Note: Correct chips (in the proper order) will lock and remain highlighted.
  </div>
`;

// Cache refs once
const howToDetails = document.getElementById('howToDetails');
const howToBody    = document.querySelector('#howToCard .howto-body');

function setHowToPhase(phase /* 'p1' | 'p2' */){
  if (!howToBody) return;
  // preserve open/closed state
  const wasOpen = !!(howToDetails && howToDetails.open);
  howToBody.innerHTML = (phase === 'p2') ? HOWTO_PHASE2_HTML : HOWTO_PHASE1_HTML;
  if (howToDetails && wasOpen) howToDetails.open = true;
}

function getSituationByKey(key){ return (SITUATIONS || []).find(s => s.key === key) || null; }

function setTargetNotes(sKey, id, text){
  const s = SITUATIONS.find(x => x.key === sKey); if (!s) return;
  if (!s.targets) s.targets = {};
  const prev = s.targets[id] || {};
  s.targets[id] = { ...prev, notes: String(text || '') };
}

function getTargetNotes(sKey, id){
  const s = SITUATIONS.find(x => x.key === sKey);
  return s?.targets?.[id]?.notes || '';
}

// Add this helper near your other small helpers
function isPostRound(){
  // Only between Phase 1 end and Phase 2 start ‚Äî not after Phase 2 has ended
  return (
    !coachUnlocked &&
    _roundHasStarted === true &&
    !phase2Active &&
    !_phase2Ended &&
    ( _allTargetsCorrect || (!gameActive && remainingTries === 0) )
  );
}

function snapChipsToTargets(){
  if (!currentSituation || !currentSituation.targets) return;
  POS_IDS.forEach(id=>{
    const t = currentSituation.targets[id];
    if (!t) return;
    const rec = tokens.get(id);
    if (!rec) return;
    rec.pos = { x: Math.round(t.x), y: Math.round(t.y) };
    placeToken(id);
  });
}

function getSeqForCurrent(){
  // Returns sanitized sequence array or empty if disabled
  const raw = (currentSituation && Array.isArray(currentSituation.playSeq))
    ? currentSituation.playSeq
    : [];
  return raw
    .map(s => String(s||'').toUpperCase().trim())
    .filter(s => POS_IDS.includes(s));
}

function getSeq2ForCurrent(){
  // Optional Stage-2 sequence
  const raw = (currentSituation && Array.isArray(currentSituation.playSeq2)) ? currentSituation.playSeq2 : [];
  return raw.map(s => String(s||'').trim()).filter(Boolean);
}

function showSeqPanel(textHTML){
  if (!seqPanel || !seqBody) return;

  // Build note (if any) from the current situation
  const note = (currentSituation && typeof currentSituation.seqNote === 'string' && currentSituation.seqNote.trim())
    ? `<div style="margin-top:10px;padding:8px;border:1px dashed #cbd5e1;border-radius:8px;background:#f8fafc">
         <div style="font-weight:800;color:#334155;margin-bottom:4px">Coach Note</div>
         <div style="white-space:pre-wrap">${currentSituation.seqNote.trim().replace(/[<>&]/g, s => ({'<':'&lt;','>':'&gt;','&':'&amp;'}[s]))}</div>
       </div>`
    : '';

  seqPanel.classList.remove('hidden');
  const sub = document.getElementById('situationSeqSubcard');
  if (sub) sub.style.display = '';
  seqBody.innerHTML = (textHTML || '') + note;
}

function hideSeqPanel(){
  if (!seqPanel) return;
  seqPanel.classList.add('hidden');
  const sub = document.getElementById('situationSeqSubcard');
  if (sub) sub.style.display = 'none';
  if (seqBody) seqBody.innerHTML = '';
}

function setChipsSelectable(on){
  tokens.forEach(({el}, id)=>{
    if (!el) return;
    if (on){
      el.classList.add('selectableChip');
      el.style.pointerEvents = 'auto';            // allow clicking chips in Phase 2
    } else {
      el.classList.remove('selectableChip','correctPulse','wrongShake');
      el.style.pointerEvents = '';                // ‚Üê remove any inline override
      // Dragging is still governed by canDrag() inside makeChipDraggable()
    }
  });
}

function phase2UpdateHud(){
  // During active sequence selection (after Continue), NO subcards should be displayed.
  // The Play Sequence subcard is rendered only when Phase 2 ENDS (success or out of tries)
  // via endPhase2()/showSeqPanel().
  if (!_phase2Ended){
    hideSeqPanel?.();
    return;
  }
  // If Phase 2 has ended, keep whatever endPhase2() rendered.
}

/// @diq:begin Play Sequence Builder (Coach)
/** Ensures array is valid POS_IDS only, uppercased */
function sanitizeSeq(arr){
  return (arr || [])
    .map(s => String(s||'').toUpperCase().trim())
    .filter(s => POS_IDS.includes(s));
}

/** Write to model + repaint builder */
function setPlaySeq(next){
  if (!currentSituation) return;
  currentSituation.playSeq = sanitizeSeq(next);
  renderSeqBuilder();
}





/** Clickable grid for adding steps */
function buildSeqPosGrid(){
  if (!seqPosGrid) return;
  seqPosGrid.innerHTML = '';
  POS_IDS.forEach(id=>{
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'pos-btn';
    btn.textContent = id;
    const group = (['P','C'].includes(id) ? 'Battery' : (['1B','2B','SS','3B'].includes(id) ? 'Infield' : 'Outfield'));
    btn.dataset.group = group;
    btn.addEventListener('click', ()=>{
      const next = (currentSituation.playSeq || []).slice();
      next.push(id);
      setPlaySeq(next);
    });
    seqPosGrid.appendChild(btn);
  });
}

/** Draggable list item (no per-item dragover/drop ‚Äî handled at list level) */
function makeSeqItem(id, index){
  const li = document.createElement('div');
  li.className = 'seq-item';
  li.draggable = true;
  li.dataset.index = String(index);

  const num = document.createElement('div');
  num.className = 'seq-num';
  num.textContent = String(index + 1);

  const tag = document.createElement('div');
  tag.className = 'seq-tag';
  tag.textContent = id;

  const del = document.createElement('button');
  del.type = 'button';
  del.className = 'seq-remove';
  del.textContent = '‚ùå';
  del.title = 'Remove this step';
  del.addEventListener('click', ()=>{
    const next = (currentSituation.playSeq || []).slice();
    next.splice(index, 1);
    setPlaySeq(next);
  });

  li.appendChild(num);
  li.appendChild(tag);
  li.appendChild(del);

  // Only start/end here; list container handles positioning
  li.addEventListener('dragstart', ()=>{
    li.classList.add('dragging');
  });
  li.addEventListener('dragend', ()=>{
    li.classList.remove('dragging');
  });

  return li;
}

/** Re-render the sequence list and count */
function renderSeqBuilder(){
  if (!seqList || !currentSituation) return;
  const seq = sanitizeSeq(currentSituation.playSeq);
  seqList.innerHTML = '';
  seq.forEach((id, i)=> seqList.appendChild(makeSeqItem(id, i)));
  if (seqCountHud) seqCountHud.textContent = String(seq.length);

  // Keep Phase 2 HUD in sync
  if (typeof updateHud === 'function'){
    if (phase2Active){
      updateHud();
    } else {
      updateHud(Number(scoreVal?.textContent) || 0);
    }
  }
}

/** Enable drag-reorder at the LIST level (robust across browsers) */
function wireSeqListDnDOnce(){
  if (!seqList || seqList._dndWired) return;
  seqList._dndWired = true;

  let ghost = null;

  function ensureGhost(){
    if (!ghost){
      ghost = document.createElement('div');
      ghost.className = 'seq-ghost';
    }
    return ghost;
  }

  function getAfterElement(container, y){
    const items = [...container.querySelectorAll('.seq-item:not(.dragging)')];
    let closest = { offset: Number.NEGATIVE_INFINITY, element: null };
    for (const el of items){
      const rect = el.getBoundingClientRect();
      const offset = y - (rect.top + rect.height / 2);
      if (offset < 0 && offset > closest.offset){
        closest = { offset, element: el };
      }
    }
    return closest.element; // null means append at end
  }

  seqList.addEventListener('dragover', (e)=>{
    e.preventDefault();
    const g = ensureGhost();
    const after = getAfterElement(seqList, e.clientY);
    if (after) seqList.insertBefore(g, after);
    else seqList.appendChild(g);
  });

  seqList.addEventListener('drop', (e)=>{
    e.preventDefault();
    const dragging = seqList.querySelector('.seq-item.dragging');
    if (!dragging) return;

    // Compute new index from ghost position
    const children = [...seqList.children];
    const newIndex = children.indexOf(ghost);
    const oldIndex = Number(dragging.dataset.index);

    // Clean up early so renderSeqBuilder paints a clean list
    if (ghost && ghost.parentNode) ghost.remove();

    if (Number.isInteger(oldIndex) && newIndex >= 0 && oldIndex !== newIndex){
      const next = (currentSituation.playSeq || []).slice();
      const [moved] = next.splice(oldIndex, 1);
      next.splice(newIndex, 0, moved);
      setPlaySeq(next); // re-renders list and renumbers
    } else {
      // No change ‚Äî just re-render to refresh indices
      renderSeqBuilder();
    }
  });

  seqList.addEventListener('dragend', ()=>{
    if (ghost && ghost.parentNode) ghost.remove();
  });
}

/** Templates */
function applySeqTemplate(val){
  if (!val) return;
  const arr = String(val).split(',').map(s=>s.trim());
  setPlaySeq(arr);
}

/** Wire up builder controls once */
function wireSeqBuilderOnce(){
  if (!seqSubsec) return;
  if (seqSubsec._wired) return;
  seqSubsec._wired = true;

  buildSeqPosGrid();
  renderSeqBuilder();
  wireSeqListDnDOnce();

  if (seqTemplateSel){
    seqTemplateSel.addEventListener('change', ()=>{
      applySeqTemplate(seqTemplateSel.value);
      // reset to placeholder
      seqTemplateSel.value = '';
    });
  }
  if (seqClearBtn){
    seqClearBtn.addEventListener('click', ()=>{
      setPlaySeq([]);
    });
  }

  // Keep the existing overall note behavior
  if (seqNoteInput){
    const syncSeqNote = () => {
      if (!currentSituation) return;
      currentSituation.seqNote = String(seqNoteInput.value || '');
    };
    seqNoteInput.addEventListener('input',  syncSeqNote);
    seqNoteInput.addEventListener('change', syncSeqNote);
  }



}

// Remove any in-progress Phase 2 sequence-throw visualization (ball + trail + RAF)
function cleanupSeqThrowViz(){
  try{ if (_seqAnimRaf){ cancelAnimationFrame(_seqAnimRaf); } }catch{}
  _seqAnimRaf = null;

  if (_seqTrail && _seqTrail.parentNode) _seqTrail.remove();
  _seqTrail = null;

  if (_seqBallEl && _seqBallEl.parentNode) _seqBallEl.remove();
  _seqBallEl = null;
}

function formatSecs(s){
  // Show mm:ss if you'd like; spec only asks for seconds, but this reads nicer.
  const m = Math.floor(s/60), sec = s%60;
  return `${m}:${String(sec).padStart(2,'0')}`;
}

function updateTimerHud(){
  if (!timerVal || !timerBadge) return;
  // Display as seconds with an "s" OR as mm:ss ‚Äî choose one line below

  // Option A: plain seconds with trailing 's' (matches your HTML shell)
  timerVal.textContent = String(_timerSecs);

  // Option B: mm:ss (then also change the HTML shell to not append 's'):
  // timerVal.textContent = formatSecs(_timerSecs);

  // Visual warning under 10s
  if (_timerSecs <= 10) timerBadge.classList.add('low');
  else timerBadge.classList.remove('low');
}

function stopTimer(){
  if (_timerId){ clearInterval(_timerId); _timerId = null; }
}

function startTimer(seconds = TIMER_START_SECS){
  stopTimer();
  _timerSecs = Math.max(0, seconds|0);
  updateTimerHud();
  _timerId = setInterval(()=>{
    _timerSecs = Math.max(0, _timerSecs - 1);
    updateTimerHud();
    if (_timerSecs === 0){
      // Time's up ‚Üí behave like tries are exhausted
      if (!coachUnlocked && _roundHasStarted){
        if (phase2Active){
          try{
            // Phase 2: out of time = out of tries ‚Üí show fail card + animate sequence
            phase2TriesLeft = 0;
            endPhase2(false);
          }catch{}
        } else if (gameActive){
          try{
            // Phase 1: force a final check so rings reveal and round ends
            remainingTries = 1; // makes isFinalTry true inside checkPositions()
            checkPositions();   // will decrement to 0 and run end-of-round logic
          }catch{}
        }
      }
      stopTimer();
    }
  }, 1000);
}


function resetTimer(seconds = TIMER_START_SECS){
  startTimer(seconds);
}

/** Exact match: same length and each pick equals expected in order */
function isExactSequenceMatch(picks, order){
  if (!Array.isArray(picks) || !Array.isArray(order)) return false;
  if (picks.length !== order.length) return false;
  for (let i = 0; i < order.length; i++){
    if (picks[i] !== order[i]) return false;
  }
  return true;
}

function wipePhase2StateUI(){
  // model
  phase2Active    = false;
  allowSeqPanel   = false;
  seqIndex        = 0;
  phase2TriesLeft = PHASE2_MAX_TRIES;
  phase2Picks     = [];
  phase2Locked    = new Set();

  // UI (chips)
  tokens.forEach(({el})=>{
    if (!el) return;
    el.classList.remove('seq-locked','selectableChip','correctPulse','wrongShake');
    el.style.pointerEvents = '';        // restore default clickability
    // remove any pick/index badges and attrs, regardless of variant
    clearChipPickMarker?.(el);          // uses your consolidated remover
    // belt-and-suspenders if you keep older helpers around:
    el.removeAttribute('data-pick-index');
    el.removeAttribute('data-pick-idx');
  });

  // UI (controls/panels/animations)
  hideSeqPanel?.();
  verifySeqBtn?.classList.add('hidden');
  setChipsSelectable?.(false);
  cleanupSeqThrowViz?.();               // remove seq ball + trail, if present

  // HUD
  updateHud?.(0);
}

// NEW: count how many picks are correct in order, consecutively from the start
function getPhase2ConsecutiveCorrect(){
  if (!phase2Active || !Array.isArray(seqOrder) || !seqOrder.length) return 0;
  let i = 0;
  while (i < phase2Picks.length && i < seqOrder.length && phase2Picks[i] === seqOrder[i]) i++;
  return i; // number of correct-in-order picks from the beginning
}

// ----- Phase 2 hygiene: clear all UI + state -----
function phase2ClearAllUI(){
  // data
  phase2Picks = [];
  phase2Locked = new Set();

  // chip visuals (numbers + highlight)
  tokens.forEach(({el})=>{
    if (!el) return;
    clearChipPickMarker(el);     // remove any sequence badge/attr
    el.classList.remove('seq-locked','correctPulse','wrongShake');
  });

  // controls / panel
  if (verifySeqBtn) verifySeqBtn.classList.add('hidden');
  setChipsSelectable(false);
  hideSeqPanel();

  // state flags
  phase2Active = false;
  allowSeqPanel = false;

  // ensure HUD reflects non-phase-2 state (score visible again)
  updateHud(Number(scoreVal?.textContent) || 0);
}

// ===== Sequence marker helpers (consolidated ‚Äì single source of truth) =====

/** Remove any/all visual sequence markers from one chip element. */
function clearChipPickMarker(el){
  if (!el) return;
  // Remove known attrs
  el.removeAttribute('data-pick');
  el.removeAttribute('data-pick-idx');
  el.removeAttribute('data-pick-index');
  el.removeAttribute('data-seq');
  // Remove known badge nodes
  el.querySelectorAll('.seq-badge, .seqBadge, .pick-badge, .chip-index, [data-role="seq-badge"]').forEach(n => n.remove());
}


/** Add/update a small numeric badge at top-right of chip (1-based). */
function setChipPickIndex(el, n){
  if (!el) return;
  // Start clean
  clearChipPickMarker(el);
  if (!Number.isFinite(n) || n <= 0) return;

  const badge = document.createElement('span');
  badge.className = 'seq-badge';
  badge.setAttribute('data-role', 'seq-badge');
  badge.textContent = String(n);
  Object.assign(badge.style, {
    position: 'absolute',
    right: '-6px',
    top: '-6px',
    minWidth: '16px',
    height: '16px',
    padding: '0 4px',
    borderRadius: '999px',
    fontWeight: '900',
    fontSize: '11px',
    lineHeight: '16px',
    textAlign: 'center',
    color: '#0b1321',
    background: '#f1f5f9',
    border: '1px solid rgba(0,0,0,.25)',
    boxShadow: '0 1px 2px rgba(0,0,0,.25)',
    pointerEvents: 'none',
    userSelect: 'none',
    zIndex: 2
  });

  el.appendChild(badge);
  el.setAttribute('data-pick-idx', String(n));
}



/** Full re-render: wipe all markers, then number 1..N from phase2Picks */
function rerenderPickMarkers(){
  tokens.forEach(({el}) => clearChipPickMarker(el));
  (phase2Picks || []).forEach((pid, i)=>{
    const rec = tokens.get(pid);
    if (rec?.el) setChipPickIndex(rec.el, i + 1);
  });
}



/** Clear the model & visuals of all picks. */
function clearAllPicks(){
  phase2Picks = [];
  tokens.forEach(({el})=>{
    if (!el) return;
    clearChipPickMarker(el);
    el.classList.remove('correctPulse','wrongShake');
  });
}



/// @diq:begin [Phase 2: End & Result Panels]
function endPhase2(success = true) {
  stopTimer();

  // Mark Phase 2 as finished and ensure rings/panel don't reappear
  _phase2Ended = true;
  disableTargetSelection?.();
  hideTargetPanel?.();

  // If Phase 2 was never actually started, just clear & return
  if (!phase2Active) {
    phase2Active = false;
    allowSeqPanel = false;
    hideSeqPanel?.();
    if (verifySeqBtn) verifySeqBtn.classList.add('hidden');
    setChipsSelectable?.(false);
    phase2Locked = new Set();
    phase2Picks  = [];
    tokens.forEach(({el})=>{
      if (!el) return;
      clearChipPickMarker?.(el);
      el.classList.remove('seq-locked','correctPulse','wrongShake');
      el.style.pointerEvents = '';
    });
    cleanupSeqThrowViz?.();
    return;
  }

  // Record Phase 2 attempt (per-stage) before we potentially transition/exit
  try{
    recordAttempt({
      phase: 2,
      stage: phase2Stage,
      situationKey: currentSituation ? currentSituation.key : null,
      situationTitle: currentSituation ? currentSituation.title : '',
      situationDesc: currentSituation ? (currentSituation.desc || '') : '',
      outs: currentSituation ? (currentSituation.outs ?? null) : null,
      runnersOn: currentSituation ? (currentSituation.runnersOn || null) : null,
      // Phase 1 outcome (tokens)
      phase1Ok: _phase1Summary ? !!_phase1Summary.ok : null,
      phase1TriesUsed: _phase1Summary ? _phase1Summary.triesUsed : null,
      phase1Elapsed: _phase1Summary ? _phase1Summary.elapsed : null,
      phase1ScoreCorrect: _phase1Summary ? _phase1Summary.scoreCorrect : null,
      phase1ScoreTotal: _phase1Summary ? _phase1Summary.scoreTotal : null,

      success: !!success,
      triesUsed: (typeof phase2TriesLeft === 'number') ? (PHASE2_MAX_TRIES - phase2TriesLeft) : null,
      timeElapsed: (typeof _timerSecs === 'number') ? Math.max(0, TIMER_START_SECS - _timerSecs) : null,
      picked: Array.isArray(phase2Picks) ? phase2Picks.slice() : []
    });
  }catch(e){}

  // If Stage 1 succeeded and this situation has a Stage 2 sequence, immediately run Stage 2
  if (success && phase2Stage === 1){
    const seq2 = getSeq2ForCurrent();
    if (Array.isArray(seq2) && seq2.length){
      phase2Stage = 2;

      // Reset Phase 2 state for Stage 2 (do NOT end Phase 2)
      seqOrder = seq2.slice();
      seqIndex = 0;
      phase2TriesLeft = PHASE2_MAX_TRIES;
      if (phase2TriesLeftEl) phase2TriesLeftEl.textContent = phase2TriesLeft;
      phase2Locked = new Set();
      phase2Picks = [];
      clearAllPicks();
      updatePhase2Hud();

      // Do NOT show any subcards during Phase 2; show Play Sequence only after Phase 2 ends
      allowSeqPanel = false;
      hideSeqPanel?.();
      if (continueBtn) continueBtn.classList.add('hidden');

  // Situation Builder undo/redo availability follows coach lock + current situation
  try{ sbEnsureKey(); sbUpdateButtons(); }catch(e){}
      if (verifySeqBtn) verifySeqBtn.classList.remove('hidden');

      // Keep chips clickable for the next pick
      phase2Active = true;
      setChipsSelectable(true);
      resetTimer(TIMER_START_SECS);
      startTimer();

      return;
    }
  }

// Stop interaction for a real Phase 2 end
  phase2Active = false;
  phase2Stage = 1;
  setChipsSelectable(false);

  if (continueBtn) continueBtn.classList.add('hidden');
  if (verifySeqBtn) verifySeqBtn.classList.add('hidden');

  // Now allow the sequence panel to appear with result info
  allowSeqPanel = true;

  if (success) {
    showSeqSuccessPanel?.();
  } else {
    phase2TriesLeft = 0;
    showSeqFailPanel?.();
  }

  // Chips that were locked-in as correct remain highlighted & marked.
  // Everything else should not be clickable anymore.
  tokens.forEach(({el}, id)=>{
    if (!el) return;
    const locked = phase2Locked.has(id);
    if (!locked){
      clearChipPickMarker?.(el);
      el.classList.remove('seq-locked');
      el.style.pointerEvents = '';
    } else {
      el.style.pointerEvents = 'none';
    }
  });

  // === Teaching moment: animate the intended relay path ===
  if (Array.isArray(seqOrder) && seqOrder.length >= 2) {
    setTimeout(() => {
      try { animateSequenceThrows(seqOrder); } catch {}
    }, 350);
  }
}

// Treat any badge/attr as "marked"
function chipIsMarked(el){
  return !!(el && (el.hasAttribute('data-pick') || el.querySelector('.seq-badge')));
}

let _seqBallEl = null;
let _seqTrail = null;
let _seqAnimRaf = null;

/** Build (or reuse) the tiny ball used for throw animations */
function ensureSeqBall(){
  if (_seqBallEl && _seqBallEl.parentNode) return _seqBallEl;
  _seqBallEl = document.createElement('div');
  _seqBallEl.className = 'seqBall';
  wrap.appendChild(_seqBallEl);
  return _seqBallEl;
}

/** Build (or reuse) an SVG overlay to draw throw lines, with arrowhead marker */
/** Build (or reuse) an SVG overlay to draw throw lines, with a small arrowhead marker */
function ensureSeqTrail(){
  if (_seqTrail && _seqTrail.parentNode) return _seqTrail;
  _seqTrail = document.createElement('div');
  _seqTrail.className = 'throwTrail';
  const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS,'svg');
  svg.setAttribute('viewBox', `0 0 ${imgRect.width} ${imgRect.height}`);

  // Define a smaller arrowhead marker once (scaled by stroke width)
  const defs = document.createElementNS(svgNS, 'defs');
  const marker = document.createElementNS(svgNS, 'marker');
  marker.setAttribute('id', 'arrowHead');
  marker.setAttribute('markerUnits', 'strokeWidth'); // scale with stroke width
  marker.setAttribute('markerWidth', '4.5');         // smaller base
  marker.setAttribute('markerHeight', '4.5');
  marker.setAttribute('refX', '4.2');                // positions tip at end of path
  marker.setAttribute('refY', '2.25');
  marker.setAttribute('orient', 'auto');

  const arrowPath = document.createElementNS(svgNS, 'path');
  // small triangle; fill inherits line color via currentColor
  arrowPath.setAttribute('d', 'M0,0 L0,4.5 L4.5,2.25 z');
  arrowPath.setAttribute('fill', 'currentColor');
  arrowPath.setAttribute('stroke', 'none');
  marker.appendChild(arrowPath);

  defs.appendChild(marker);
  svg.appendChild(defs);

  _seqTrail.appendChild(svg);
  wrap.appendChild(_seqTrail);
  return _seqTrail;
}


/** Remove temporary ball + trail */
function sizeOverlays(){
  if (!wrap) return;

  // 1) Snapshot new container rect
  const r = wrap.getBoundingClientRect();
  imgRect = { width:r.width, height:r.height, left:r.left, top:r.top };

  // 2) Scale chip size + fonts and scale markers (ball/runner/hit marker)
  updateChipScale();

  // 3) Re-position all chips from native coords
  POS_IDS.forEach(id => placeToken(id));

  // 4) Reposition + resize target rings from model
  if (currentSituation && currentSituation.targets){
    getAllRings().forEach(el => {
      const id  = el.dataset.id;
      const tgt = currentSituation.targets[id];
      if (!tgt) return;
      const css = unitToCss(tgt);
      el.style.left = css.left + 'px';
      el.style.top  = css.top  + 'px';
      const dpx = tolToCssDiameter(Number(tgt.tol) || DEFAULT_TOL, /*allowTiny*/ coachUnlocked);
      el.style.width  = dpx + 'px';
      el.style.height = dpx + 'px';
    });
  }

  // 5) Ball graphics: reset and rebuild SVG to match new viewBox
  if (animReq){ cancelAnimationFrame(animReq); animReq = null; }
  if (ballSvg) ballSvg.innerHTML = '';
  buildBallGraphics(); // also calls syncBallToHit()

  // 6) Reposition coach hit marker (if visible)
  if (hitMarker && currentSituation && currentSituation.hit){
    const css = unitToCss(currentSituation.hit);
    hitMarker.style.left = css.left + 'px';
    hitMarker.style.top  = css.top  + 'px';
  }

  // 7) Repaint static base-runner dots and snap animated runner to base
  renderBaseRunners();
  if (runnerEl && runnerEl.style.display !== 'none'){
    placeRunnerAtBase(runnerLastBase);
  }

  scaleMarkers();

  // Clear any in-progress Phase 2 throw animation after a resize/layout change
  cleanupSeqThrowViz();

  if (phase2Active && ballEl){
    ballEl.style.display = 'block';
    ballEl.style.zIndex = '10';
  }

}

/** Get CSS-space point for a position id, using target (snap) locations */
/** Get CSS-space point for a position id, using the chip‚Äôs actual DOM left/top if present. */
function getCssPointForPosId(posId){
  const rec = tokens.get(posId);
  if (rec?.el){
    const x = parseFloat(rec.el.style.left)  || 0;
    const y = parseFloat(rec.el.style.top)   || 0;
    return { x, y };
  }
  // Fallback to target location if the chip isn't built yet
  const tgt = currentSituation?.targets?.[posId];
  return tgt ? nativeToCssPoint({ x: tgt.x, y: tgt.y }) : null;
}

/** Small chip pulse for feedback */
function pulseChip(id){
  const rec = tokens.get(id);
  if (!rec?.el) return;
  rec.el.classList.add('correctPulse');
  setTimeout(()=> rec.el?.classList?.remove('correctPulse'), 260);
}

/** Animate the REAL ball (ballEl) along a straight, optionally offset line from A to B.
 *  Leaves a colored path with a proper triangular arrowhead showing direction. */
/** Animate the REAL ball from A‚ÜíB and leave a colored line + small arrowhead. */
function animateThrowLeg(fromPt, toPt, color, visualOffset){
  return new Promise(function(resolve){
    const trail = ensureSeqTrail();
    const svg   = trail.querySelector('svg');
    const svgNS = 'http://www.w3.org/2000/svg';

    // === match Phase 1 line width exactly ===
    const LINE_WIDTH = (typeof getBallStrokeWidth === 'function')
      ? getBallStrokeWidth()
      : 3; // safe fallback

    // --- per-color, width-aware arrowhead ---
    function getOrMakeMarker(colorStr){
      const safe = String(colorStr || '#111827').toLowerCase().replace(/[^a-z0-9]+/g,'_');
      const id   = `arrowHead_${safe}_w${LINE_WIDTH}`;
      let m = svg.querySelector(`#${id}`);
      if (m) return m;

      let defs = svg.querySelector('defs');
      if (!defs){
        defs = document.createElementNS(svgNS, 'defs');
        svg.appendChild(defs);
      }

      // smaller head that scales with stroke
      const aw  = Math.max(LINE_WIDTH * 2.2, 4);   // width/height of marker box
      const ah  = aw;
      const mid = ah / 2;

      m = document.createElementNS(svgNS, 'marker');
      m.setAttribute('id', id);
      m.setAttribute('markerUnits', 'strokeWidth'); // scale with line width
      m.setAttribute('markerWidth',  String(aw));
      m.setAttribute('markerHeight', String(ah));
      m.setAttribute('refX', String(aw));           // tip sits at end of path
      m.setAttribute('refY', String(mid));
      m.setAttribute('orient', 'auto');

      const tri = document.createElementNS(svgNS, 'path');
      tri.setAttribute('d', `M0,0 L${aw},${mid} L0,${ah} Z`);
      tri.style.fill   = colorStr || '#111827';     // explicit color (no currentColor)
      tri.style.stroke = 'none';
      m.appendChild(tri);
      defs.appendChild(m);
      return m;
    }

    const c      = color || '#111827';
    const marker = getOrMakeMarker(c);

    // optional perpendicular offset to unstack duplicate legs
    const off = visualOffset || { x:0, y:0 };
    const A = { x: fromPt.x + off.x, y: fromPt.y + off.y };
    const B = { x: toPt.x   + off.x, y: toPt.y   + off.y };

    // draw the leg (thin + clean, like Phase 1)
    const path = document.createElementNS(svgNS, 'path');
    path.setAttribute('d', `M ${A.x},${A.y} L ${B.x},${B.y}`);
    path.setAttribute('marker-end', `url(#${marker.id})`);
    path.style.stroke         = c;
    path.style.fill           = 'none';
    path.style.strokeWidth    = String(LINE_WIDTH); // ‚Üê match Phase 1
    path.style.strokeLinecap  = 'butt';             // keep arrow tip crisp
    path.style.strokeLinejoin = 'round';
    path.style.opacity        = '.95';
    svg.appendChild(path);

    // move the actual ball
    if (ballEl){
      ballEl.style.display = 'block';
      ballEl.style.left = A.x + 'px';
      ballEl.style.top  = A.y + 'px';
      ballEl.style.zIndex = '10';
    }

    const dist = Math.hypot(B.x - A.x, B.y - A.y);
    const duration = clamp(420 + dist * 0.45, 380, 1100);

    const t0 = performance.now();
    function step(now){
      const t = clamp((now - t0) / duration, 0, 1);
      const e = 1 - Math.pow(1 - t, 3);
      if (t < 1){
        if (ballEl){
          ballEl.style.left = (A.x + (B.x - A.x) * e) + 'px';
          ballEl.style.top  = (A.y + (B.y - A.y) * e) + 'px';
        }
        _seqAnimRaf = requestAnimationFrame(step);
      } else {
        if (ballEl){
          ballEl.style.left = B.x + 'px';
          ballEl.style.top  = B.y + 'px';
        }
        resolve();
      }
    }
    _seqAnimRaf = requestAnimationFrame(step);
  });
}


/** Animate throws along the provided order of POS_IDS.
 *  Uses distinct colors and offsets duplicate legs to avoid stacking. */
async function animateSequenceThrows(order){
  try{ if (_seqAnimRaf){ cancelAnimationFrame(_seqAnimRaf); } }catch{}
  _seqAnimRaf = null;

  var pts = (order || [])
    .map(function(id){ return { id:id, pt:getCssPointForPosId(id) }; })
    .filter(function(x){ return !!x.pt; });
  if (pts.length < 2) return;

  var trail = ensureSeqTrail();
  var svg = trail.querySelector('svg');
  svg.setAttribute('viewBox', '0 0 ' + imgRect.width + ' ' + imgRect.height);

  if (ballEl){
    ballEl.style.display = 'block';
    ballEl.style.zIndex = '10';
    ballEl.style.left = pts[0].pt.x + 'px';
    ballEl.style.top  = pts[0].pt.y + 'px';
  }

  var COLORS = [
    '#FF3B30', // bright red
    '#FFCC00', // strong yellow
    '#AF52DE', // purple
    '#5856D6', // indigo
    '#FF2D55', // hot pink/magenta
    '#8E8E93',  // medium-light gray (neutral)
    '#FF9500' // vivid orange
  ];
  var seenPairs = {}; // track duplicates

  pulseChip(pts[0].id);

  var chain = Promise.resolve();
  for (var i = 0; i < pts.length - 1; i++){
    (function(i){
      var a = pts[i];
      var b = pts[i + 1];
      var color = COLORS[i % COLORS.length];

      // Key is undirected pair so A‚ÜíB and B‚ÜíA share
      var key = [a.id, b.id].sort().join('|');
      var count = seenPairs[key] || 0;
      seenPairs[key] = count + 1;

      // Compute perpendicular offset
      var dx = b.pt.x - a.pt.x;
      var dy = b.pt.y - a.pt.y;
      var len = Math.sqrt(dx*dx + dy*dy) || 1;
      var nx = -dy / len;
      var ny =  dx / len;
      var offsetPx = 8 * count; // 8px per duplicate
      var vOff = { x: nx * offsetPx, y: ny * offsetPx };

      chain = chain
        .then(function(){ pulseChip(a.id); return animateThrowLeg(a.pt, b.pt, color, vOff); })
        .then(function(){ pulseChip(b.id); return new Promise(r => setTimeout(r, 120)); });
    })(i);
  }

  chain.finally(function(){
    try{ if (_seqAnimRaf){ cancelAnimationFrame(_seqAnimRaf); } }catch{}
    _seqAnimRaf = null;
  });
}


/** Show a simple "success" message inside the Play Sequence card */
function showSeqSuccessPanel(){
  // Prefer the active order; fall back to the situation's playSeq
  const seqArr = (Array.isArray(seqOrder) && seqOrder.length)
    ? seqOrder
    : (currentSituation && Array.isArray(currentSituation.playSeq) ? currentSituation.playSeq : []);
  const seqStr = seqArr.length ? seqArr.join(' \u2192 ') : '‚Äî';

  showSeqPanel(`
    <div style="color:#16a34a;font-weight:700">‚úÖ Correct sequence!</div>
    <div class="hint" style="margin-top:6px">Expected: <b>${seqStr}</b></div>
  `);
}


/** Show a "failure" message inside the Play Sequence card */
function showSeqFailPanel() {
  const seqStr = seqOrder.join(' ‚Üí ') || '‚Äî';
  showSeqPanel(`
    <div style="color:#dc2626;font-weight:700">‚ùå Incorrect sequence</div>
    <div class="hint" style="margin-top:6px">Expected: <b>${seqStr}</b></div>
  `);
}

function wireOnce(){
  if (_wired) return;
  _wired = true;

  // Coach tools collapsible sections
  initCoachToolsCollapsibles();
  if(coachCollapseAllBtn) coachCollapseAllBtn.addEventListener('click', ()=> setAllCoachSubsecsCollapsed(true));
  if(coachExpandAllBtn) coachExpandAllBtn.addEventListener('click', ()=> setAllCoachSubsecsCollapsed(false));

  // Coach Review (paste code ‚Üí modal table + playback)
  const coachReviewModal = document.getElementById('coachReviewModal');
  const coachReviewModalClose = document.getElementById('coachReviewModalClose');
  const coachReviewOpenBtn = document.getElementById('coachReviewOpenBtn');
  const coachReviewCopyCodeBtn = document.getElementById('coachReviewCopyCodeBtn');

  function openCoachReviewModal(){
    if(!coachReviewModal) return;
    coachReviewModal.classList.remove('hidden');
  }
  function closeCoachReviewModal(){
    if(!coachReviewModal) return;
    coachReviewModal.classList.add('hidden');
    _stopCoachPlayback('coachReviewModalPlayback');
  }

  if(coachReviewModalClose) coachReviewModalClose.addEventListener('click', closeCoachReviewModal);
  if(coachReviewModal){
    const backdrop = coachReviewModal.querySelector('.diq-modal-backdrop');
    if(backdrop) backdrop.addEventListener('click', closeCoachReviewModal);
    document.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape' && !coachReviewModal.classList.contains('hidden')) closeCoachReviewModal();
    });
  }

  if(coachReviewLoadBtn){
    coachReviewLoadBtn.addEventListener('click', ()=>{
      try{
        const obj = decodeCoachReviewCode(coachReviewInput ? coachReviewInput.value : '');
        renderCoachReview(obj);
        openCoachReviewModal();
      }catch(e){
        alert("Could not load Coach Review Code: " + (e && e.message ? e.message : e));
      }
    });
}
  if(coachReviewClearBtn){
    coachReviewClearBtn.addEventListener('click', ()=>{
      if(coachReviewInput) coachReviewInput.value = '';
      const mini = document.getElementById('coachReviewMini');
      if(mini) mini.style.display = 'none';
      const miniText = document.getElementById('coachReviewMiniText');
      if(miniText) miniText.innerHTML = '';
      if(coachReviewOutput) coachReviewOutput.innerHTML = '';
      if(coachReviewPlayback) coachReviewPlayback.innerHTML = '';
      const mout = document.getElementById('coachReviewModalOutput');
      if(mout) mout.innerHTML = '';
      const mpb = document.getElementById('coachReviewModalPlayback');
      if(mpb) mpb.innerHTML = '';
      closeCoachReviewModal();
    });
  }
  if(coachReviewOpenBtn){
    coachReviewOpenBtn.addEventListener('click', ()=> openCoachReviewModal());
  }
  if(coachReviewCopyCodeBtn){
    coachReviewCopyCodeBtn.addEventListener('click', async ()=>{
      try{
        const txt = (coachReviewInput && coachReviewInput.value) ? coachReviewInput.value.trim() : '';
        if(!txt) return alert('No code to copy.');
        await copyTextToClipboard(txt);
        toast('Coach Review Code copied.');
      }catch(e){}
    });
  }

  // --- everything from your ‚Äú/* Wiring */‚Äù block goes here ---
  if (sitSelect) sitSelect.addEventListener('change', e=> setSituation(e.target.value));
  if (randomSitBtn) randomSitBtn.addEventListener('click', pickRandomSituation);

  if (resetBtn)  resetBtn.addEventListener('click', resetPlayers);
  if (checkBtn)  checkBtn.addEventListener('click', checkPositions);

  if (startBtn)  startBtn.addEventListener('click', ()=>{
    if (!currentSituation) return;

    _roundHasStarted = true;
    _phase2Ended = false;
  _targetPanelDismissedOnce = false;
    _targetPanelDismissedOnce = false;
    allowSeqPanel = false;

    // --- Set game state up front ---
    gameActive = true;
    resetTimer(TIMER_START_SECS);
    _phase1Summary = null;
    remainingTries = MAX_TRIES;
    updateHud(0);
    _allTargetsCorrect = false;

    wipePhase2StateUI();
    if (continueBtn) continueBtn.classList.add('hidden');

    // --- Reset round UI ---
    disableTargetSelection();
    hideTargetPanel();
    if (!coachUnlocked) getAllRings().forEach(el=> el.style.display='none');
    startBtn.disabled = true;
    if (resetBtn) resetBtn.disabled = false;
    if (checkBtn) checkBtn.disabled = false;
    if (checkBtn){ checkBtn.classList.remove('hidden'); }
    setChipsLocked(false);
    syncBallToHit();

    // --- Animate hit + runners ---
    const ht = (currentSituation.hitType) || (hitTypeSel && hitTypeSel.value) || 'line';
    animateHit(ht);

    const advFromSit = (typeof currentSituation.batterAdvance === 'number') ? currentSituation.batterAdvance : null;
    const advFromUI  = advanceSel ? clampInt(advanceSel.value,0,4) : null;
    const advance    = (advFromSit ?? advFromUI ?? mapHitTypeToAdvance(ht));

    liveRunners = normalizeRunnersOn(currentSituation.runnersOn);

    let existingDone = false, batterDone = false;
    let finalExisting = null;
    let batterDest = null;

    animateExistingRunnersAdvance(advance, (finalState)=>{
      finalExisting = finalState;
      existingDone = true;
      maybeFinish();
   });

    animateBatterAdvance(advance, (destBase)=>{
      batterDest = destBase;
      batterDone = true;
      maybeFinish();
    });

    function maybeFinish(){
      if (!existingDone || !batterDone) return;
      liveRunners = normalizeRunnersOn(finalExisting || liveRunners);

      if (batterDest === 'first')        liveRunners.first  = true;
      else if (batterDest === 'second')  liveRunners.second = true;
      else if (batterDest === 'third')   liveRunners.third  = true;

      renderBaseRunners();
      updateRunnersHudFromLive();
    }
  });

    // Verify Sequence button is part of the Situation card (row 3). Do not create/move into header.

// ===== Small helpers (add once anywhere in <script>) =====
function getCorrectPrefixLen(picks, order){
  const n = Math.min(picks.length, order.length);
  let k = 0;
  for (; k < n; k++){
    if (picks[k] !== order[k]) break;
  }
  return k; // number of leading chips correct & in order
}

// Replace the old lockCorrectPrefix with this:
function lockCorrectPrefix(k){
  // Never reduce already-locked count
  const prev = phase2Locked.size || 0;
  const want = Math.max(prev, Math.max(0, Math.min(k, seqOrder.length)));

  const lockIds = seqOrder.slice(0, want);       // ‚Üê lock by the expected order only
  phase2Locked = new Set(lockIds);

  // Update visuals for ALL chips
  tokens.forEach(({el}, id)=>{
    if (!el) return;
    const locked = phase2Locked.has(id);
    clearChipPickMarker(el);
    el.classList.remove('seq-locked','correctPulse','wrongShake');

    if (locked){
      setChipPickIndex(el, lockIds.indexOf(id) + 1);
      el.classList.add('seq-locked');
      el.classList.remove('selectableChip');
      el.style.pointerEvents = 'none';
    } else {
      el.style.pointerEvents = ''; // keep them clickable
    }
  });

  // Keep the model picks trimmed to the locked prefix (helps re-numbering)
  phase2Picks = lockIds.slice();
  rerenderPickMarkers();

  // Coach Review (paste code ‚Üí table + playback)
  if(coachReviewLoadBtn){
    coachReviewLoadBtn.addEventListener('click', ()=>{
      try{
        const obj = decodeCoachReviewCode(coachReviewInput ? coachReviewInput.value : '');
        renderCoachReview(obj);
      }catch(e){
        alert("Could not load Coach Review Code: " + (e && e.message ? e.message : e));
      }
    });
  }
  if(coachReviewClearBtn){
    coachReviewClearBtn.addEventListener('click', ()=>{
      if(coachReviewInput) coachReviewInput.value = '';
      if(coachReviewOutput) coachReviewOutput.innerHTML = '';
      if(coachReviewPlayback) coachReviewPlayback.innerHTML = '';
      _stopCoachPlayback();
    });
  }

wireSeqBuilderOnce();
}

  // --- Verify Sequence (Phase 2) ---
  verifySeqBtn.addEventListener('click', ()=>{
    if (!phase2Active || !seqOrder.length) return;

    const tooMany  = phase2Picks.length > seqOrder.length;
    const kAttempt = getCorrectPrefixLen(phase2Picks, seqOrder); // how many from the start were correct
    const kPrev    = phase2Locked.size || 0;

    // ‚úÖ Always lock the longest correct prefix (never regress),
    // even if the player over-selected chips this attempt.
    const newK = Math.max(kPrev, kAttempt);
    lockCorrectPrefix(newK);

    // Visual feedback for any extra, unnecessary picks
    if (tooMany){
      phase2Picks.slice(seqOrder.length).forEach(id=>{
        const el = tokens.get(id)?.el;
        if (el){
          el.classList.add('wrongShake');
          setTimeout(()=> el.classList.remove('wrongShake'), 220);
        }
      });
    }

    // Success requires exact match: same length AND same ordered picks.
    const exact = !tooMany && isExactSequenceMatch(phase2Picks, seqOrder);
    if (exact){
      endPhase2(true);
      return;
    }

    // Not exact ‚Üí consume a try (keep the panel hidden during attempts)
    phase2TriesLeft = Math.max(0, phase2TriesLeft - 1);
    updateHud();
    hideSeqPanel();

    if (phase2TriesLeft === 0){
      endPhase2(false);
    }
  });

  // --- CONTINUE button: start Phase 2, snap chips, hide rings/target panel, hide Check Positions ---
  if (continueBtn) continueBtn.addEventListener('click', ()=>{
    if (!isPostRound()) return;
    _phase2Ended = false;

    phase2Locked = new Set();
    phase2Picks  = [];
    tokens.forEach(({el})=>{
      if (!el) return;
      clearChipPickMarker(el);
      el.classList.remove('seq-locked','correctPulse','wrongShake','selectableChip');
      el.style.pointerEvents = '';
    });

    const seq = getSeqForCurrent();
    if (!seq.length){
      // No play sequence configured ‚Üí never run Phase 2; hide the button and panel
      continueBtn.classList.add('hidden');
      hideSeqPanel();
      return;
    }

    // Phase 2 setup
    hideTargetPanel();             // hide Selected Target card immediately
    _targetPanelDismissedOnce = true; // never show Selected Target again this run
    disableTargetSelection();      // stop ring selection in post-round view
    allowSeqPanel = false;         // do not show Play Sequence panel during Phase 2 (results only)

    // Move chips to their correct targets, then hide the rings (non-coach)
    snapChipsToTargets();
    if (!coachUnlocked) getAllRings().forEach(el => el.style.display = 'none');

    // Hide "Check Positions" during Phase 2
    if (checkBtn){
      checkBtn.classList.add('hidden');
      checkBtn.disabled = true;
    }

    // Start Phase 2 state
  phase2Stage = 1;
    seqOrder = seq;
    seqIndex = 0; // not used in the new "pick then verify" flow, kept for compatibility
    phase2TriesLeft = PHASE2_MAX_TRIES;
    clearAllPicks();     // start fresh
    updateHud();         // show 0/<seq length> in the score HUD
    phase2Active = true;
    resetTimer(TIMER_START_SECS);

    // Always keep the regular ball visible in Phase 2
    if (ballEl){
      ballEl.style.display = 'block';
      ballEl.style.zIndex = '10';
    }

    setChipsSelectable(true);
    updateHud();

    // During Phase 2 attempts, keep the Play Sequence subcard hidden.
    hideSeqPanel?.();

    // Show Verify button; Play Sequence subcard remains hidden during Phase 2 attempts
    verifySeqBtn.classList.remove('hidden');

    continueBtn.classList.add('hidden');
  });

  if (seqInput){
    const syncSeq = () => {
      if (!currentSituation) return;
      currentSituation.playSeq = String(seqInput.value || '')
        .split(',')
        .map(s => s.toUpperCase().trim())
        .filter(s => POS_IDS.includes(s));
    };
    seqInput.addEventListener('input',  syncSeq);
    seqInput.addEventListener('change', syncSeq);
  }

  if (seqNoteInput){
    const syncSeqNote = () => {
      if (!currentSituation) return;
      currentSituation.seqNote = String(seqNoteInput.value || '');
    };
    seqNoteInput.addEventListener('input',  syncSeqNote);
    seqNoteInput.addEventListener('change', syncSeqNote);
  }

  if (coachBtn) coachBtn.addEventListener('click', ()=>{
    // Always reset the situation when the Coach Tools button is clicked
    resetPlayers();

    if (coachUnlocked){
      setCoachMode(false);
      coachCard.classList.add('hidden');
      setChipsLocked(!gameActive||remainingTries===0);
      getAllRings().forEach(el=>el.style.display='none');
      syncBallToHit();
    } else {
      openPwModal();
    }
  });


  // Close button on Coach Tools card (does not reset situation)
  const coachCardCloseBtn = document.getElementById('coachCardCloseBtn');
  if (coachCardCloseBtn) coachCardCloseBtn.addEventListener('click', ()=>{
    if (coachUnlocked){
      setCoachMode(false);
      if (coachCard) coachCard.classList.add('hidden');
      setChipsLocked(!gameActive||remainingTries===0);
      getAllRings().forEach(el=>el.style.display='none');
      syncBallToHit();
    } else {
      if (coachCard) coachCard.classList.add('hidden');
    }
  });


  // --- Admin button / modal (separate password) ---
  const adminBtn = document.getElementById('adminBtn');
  const adminCard = document.getElementById('adminCard');
  const adminStatus = document.getElementById('adminStatus');

  const adminPwModal = document.getElementById('adminPwModal');
  const adminPwInput = document.getElementById('adminPwInput');
  const adminPwOk = document.getElementById('adminPwOk');
  const adminPwCancel = document.getElementById('adminPwCancel');
  const adminPwMsg = document.getElementById('adminPwMsg');

  let adminUnlocked = false;

  function openAdminPwModal(){
    if (!adminPwModal) return;
    adminPwMsg.textContent = '';
    adminPwInput.value = '';
    adminPwModal.style.display = 'flex';
    setTimeout(()=>adminPwInput.focus(), 0);
  }
  function closeAdminPwModal(){
    if (!adminPwModal) return;
    adminPwModal.style.display = 'none';
  }
  function setAdminMode(on){
    adminUnlocked = !!on;
    if (adminCard) adminCard.classList.toggle('hidden', !adminUnlocked);
    if (adminStatus) adminStatus.textContent = adminUnlocked ? 'unlocked' : 'locked';
  }
  function tryUnlockAdmin(){
    if (!adminPwInput) return;
    if (adminPwInput.value === ADMIN_PASSWORD){
      closeAdminPwModal();
      setAdminMode(true);
    } else {
      adminPwMsg.textContent = 'Incorrect password.';
    }
  }

  if (adminPwCancel) adminPwCancel.addEventListener('click', closeAdminPwModal);
  if (adminPwOk) adminPwOk.addEventListener('click', tryUnlockAdmin);
  if (adminPwInput) adminPwInput.addEventListener('keydown', e=>{ if(e.key==='Enter') tryUnlockAdmin(); });

  if (adminBtn) adminBtn.addEventListener('click', ()=>{
    if (adminUnlocked){
      setAdminMode(false);
      if (adminCard) adminCard.classList.add('hidden');
    } else {
      openAdminPwModal();
    }
  });

  // Close button on Admin Tools card
  const adminCardCloseBtn = document.getElementById('adminCardCloseBtn');
  if (adminCardCloseBtn) adminCardCloseBtn.addEventListener('click', ()=>{
    if (adminUnlocked){
      setAdminMode(false);
      if (adminCard) adminCard.classList.add('hidden');
    } else {
      if (adminCard) adminCard.classList.add('hidden');
    }
  });


  // When the target dropdown changes, sync tolerance + notes
  if (tolTargetSel) {
    tolTargetSel.addEventListener('change', () => {
      syncTolInputsFromModel(tolTargetSel.value);      // existing
      syncTolNotesFromModel(tolTargetSel.value);       // NEW
    });
  }

  // Notes typing -> save to model and re-render if same target is displayed
  if (tolNotes) {
    tolNotes.addEventListener('input', () => {
      if (!currentSituation || _muteCoachInputs) return;
      const id = tolTargetSel?.value || POS_IDS[0];
      setTargetNotes(currentSituation.key, id, tolNotes.value);
      if (_currentSelectedTargetId === id) renderTargetPanel(id);
    });
  }

  if (pwCancel) pwCancel.addEventListener('click', closePwModal);
  if (pwOk)     pwOk.addEventListener('click', tryUnlock);
  if (pwInput)  pwInput.addEventListener('keydown', e=>{ if(e.key==='Enter') tryUnlock(); });

  if (hitTypeSel)  hitTypeSel.addEventListener('change', ()=>{
    if (!currentSituation) return;
    currentSituation.hitType = hitTypeSel.value || 'line';
    if (currentSituation.batterAdvance == null) advanceSel.value = String(mapHitTypeToAdvance(currentSituation.hitType));
  });
  if (advanceSel)  advanceSel.addEventListener('change', ()=>{ if(currentSituation) currentSituation.batterAdvance=clampInt(advanceSel.value,0,4); });
  if (testHitBtn)  testHitBtn.addEventListener('click', ()=> animateHit());

  if (run1B) run1B.addEventListener('change', ()=> setRunnersOn(null, {quiet:false}));
  if (run2B) run2B.addEventListener('change', ()=> setRunnersOn(null, {quiet:false}));
  if (run3B) run3B.addEventListener('change', ()=> setRunnersOn(null, {quiet:false}));

  if (tolNum)        tolNum.addEventListener('input',   () => setTolLive(tolTargetSel.value, tolNum.value));
  if (tolRange)      tolRange.addEventListener('input', () => setTolLive(tolTargetSel.value, tolRange.value));

  if (newSituationBtn)  newSituationBtn.addEventListener('click', addNewSituation);
  if (saveSituationBtn) saveSituationBtn.addEventListener('click', ()=>{
    // Refresh = re-apply the currently selected situation to the field/UI (no saving).
    if (!currentSituation) return;
    const k = currentSituation.key;
    restoreSituationFromOrig(k);
    setSituation(k);
    if (situationMsg){
      situationMsg.textContent='Situation refreshed.';
      setTimeout(()=> situationMsg.textContent='', 1400);
    }
  });
  if (deleteSituationBtn && typeof deleteCurrentSituation === 'function') deleteSituationBtn.addEventListener('click', deleteCurrentSituation);
  if (resetStartsBtn)   resetStartsBtn.addEventListener('click', resetStartsToDefaults);

  if (sbUndoBtn) sbUndoBtn.addEventListener('click', sbUndo);
  if (sbRedoBtn) sbRedoBtn.addEventListener('click', sbRedo);

  // Snapshot/commit history for tolerance + notes edits (avoid one entry per keystroke)
  const sbCommitTol = ()=>{ if(_sbTolStartSnap){ sbPushUndo(_sbTolStartSnap); _sbTolStartSnap=null; } };
  const sbCommitNotes = ()=>{ if(_sbNotesStartSnap){ sbPushUndo(_sbNotesStartSnap); _sbNotesStartSnap=null; } };

  if (tolNum){
    tolNum.addEventListener('focus', ()=>{ if(coachUnlocked) _sbTolStartSnap = sbSnapshot(); });
    tolNum.addEventListener('change', sbCommitTol);
    tolNum.addEventListener('blur', sbCommitTol);
  }
  if (tolRange){
    tolRange.addEventListener('pointerdown', ()=>{ if(coachUnlocked) _sbTolStartSnap = sbSnapshot(); });
    tolRange.addEventListener('pointerup', sbCommitTol);
    tolRange.addEventListener('change', sbCommitTol);
    tolRange.addEventListener('blur', sbCommitTol);
  }
  if (tolNotes){
    tolNotes.addEventListener('focus', ()=>{ if(coachUnlocked) _sbNotesStartSnap = sbSnapshot(); });
    tolNotes.addEventListener('change', sbCommitNotes);
    tolNotes.addEventListener('blur', sbCommitNotes);
  }

  if (outsSelSituation) outsSelSituation.addEventListener('change', e=> setOuts(e.target.value, {quiet:false}));

  if (newTitleInput) {
    newTitleInput.addEventListener('input', () => {
      if (_muteCoachInputs || !currentSituation) return;
      currentSituation.title = newTitleInput.value.trim();
      updateCurrentOptionLabel();
    });
  }

  if (newDescInput) {
    newDescInput.addEventListener('input', () => {
      if (_muteCoachInputs || !currentSituation) return;
      currentSituation.desc = newDescInput.value;
      if (descHud) descHud.textContent = currentSituation.desc || '';
if (typeof updateDescriptionHudText === 'function') updateDescriptionHudText();
    });
  }

  if (downloadCurrentBtn) downloadCurrentBtn.addEventListener('click', ()=>{
    refreshSituationAll(); // ensure UI ‚Üí model before exporting
    download(safeSituationJsonFilename((currentSituation && (currentSituation.title||currentSituation.key)) || 'situation-current'), buildCurrentSituationExport());
  });
  if (downloadAllBtn)     downloadAllBtn.addEventListener('click', ()=>{
    refreshSituationAll();
    download('situations-all.json', buildAllSituationsExport());
  });

      // Results export buttons (avoid relying on id->window globals)
  const copyResultsBtn = document.getElementById('copyResultsBtn');
  const downloadResultsBtn = document.getElementById('downloadResultsBtn');
  const copyResultsTopBtn = document.getElementById('copyResultsTopBtn'); // optional

  if (copyResultsBtn)      copyResultsBtn.addEventListener('click', async ()=>{ try{ await copyResults(); }catch{} });
  if (downloadResultsBtn)  downloadResultsBtn.addEventListener('click', ()=>{ downloadResults(); });
  if (copyResultsTopBtn)   copyResultsTopBtn.addEventListener('click', async ()=>{ try{ await copyResults(); }catch{} });

  wireSeqBuilderOnce();
}

/// @diq:begin [A0.1] App state (mutable)
let SITUATIONS = [];
let SITUATIONS_ORIG_BY_KEY = {};

const SITUATIONS_FALLBACK = [];
let currentSituation = null;

let startsMap = {};
let hitsMap   = {};

let gameActive = false;
let remainingTries = 0;
const MAX_TRIES = 3;

let _allTargetsCorrect = false;

// Phase 1 (chip placement) summary for the most recently completed round
let _phase1Summary = null; // { ok:boolean, triesUsed:number, elapsed:number, ts:number }

let coachUnlocked = false;

// Situation Builder edit history (Undo/Redo, per-situation; 10-step)
const SB_HISTORY_MAX = 10;
let sbHistKey = null;         // currentSituation.key the stacks apply to
let sbUndoStack = [];         // array of snapshots
let sbRedoStack = [];
let _sbTolStartSnap = null;   // snapshot captured at start of tol edits
let _sbNotesStartSnap = null; // snapshot captured at start of notes edits

// Coach Review: allow loading report code from URL fragment (e.g. #coachReview=...)
let _pendingCoachReviewCode = null;
try{
  const h = String(window.location.hash || '');
  const m = h.match(/(?:^#|&)coachReview=([^&]+)/);
  if(m && m[1]) _pendingCoachReviewCode = decodeURIComponent(m[1]);
}catch(e){ _pendingCoachReviewCode = null; }

try{
  window.addEventListener('hashchange', ()=>{
    try{
      const h = String(window.location.hash || '');
      const m = h.match(/(?:^#|&)coachReview=([^&]+)/);
      if(m && m[1]) _pendingCoachReviewCode = decodeURIComponent(m[1]);
    }catch(e){}
    
    if(_pendingCoachReviewCode && !coachUnlocked){ try{ openPwModal(); }catch(e){} }
if(coachUnlocked && typeof window._diqCoachReviewAutoload === 'function'){
      try{ window._diqCoachReviewAutoload(); }catch(e){}
    }
  });
}catch(e){}


let runnerEl = null;
let runnerAnimId = null;
let runnerLastBase = 'home';

let imgRect={width:1,height:1,left:0,top:0};
let CHIP_PX = 36;

let ballSvg=null, ballPath=null, ballEl=null, hitMarker=null;
let animReq=null;

let liveRunners = { first:false, second:false, third:false };
let _animSuppressedBases = new Set();

let _wired = false;

let _roundHasStarted = false;

let phase2Active = false;
let seqOrder = [];     // array of POS_IDS e.g. ['LF','SS','2B','C']
let seqIndex = 0;      // current expected index
let _phase2Ended = false;   // prevents target panel from showing after Phase 2

let _targetPanelDismissedOnce = false; // once Continue is pressed, never show Selected Target again during this run
const PHASE2_MAX_TRIES = 3;
let phase2TriesLeft = 0;
let allowSeqPanel = false;
let phase2Picks = [];
let phase2Stage = 1; // 1 = primary playSeq, 2 = optional secondary playSeq2         // array of POS_IDS in the order the user picked
let verifySeqBtn = document.getElementById('verifySeqBtn'); // lives in Situation card row 3 (moved by layout)
let phase2Locked = new Set(); // chips locked as correct prefix (GLOBAL)

const Bus = (() => {
  /** @type {Record<string, Set<Function>>} */ const map = {};
  return {
    on(evt, fn){ (map[evt] ||= new Set()).add(fn); return () => map[evt].delete(fn); },
    off(evt, fn){ map[evt]?.delete(fn); },
    emit(evt, payload){ map[evt]?.forEach(fn => { try{ fn(payload); } catch{} }); }
  };
})();

let _currentSelectedTargetId = null;

/// @diq:begin [A0.2] DOM refs
const img=document.getElementById('fieldImg');
const wrap=document.getElementById('wrap');
const targetsLayer=document.getElementById('targetsLayer');
const ballLayer=document.getElementById('ballLayer');

const sitSelect=document.getElementById('sitSelect');
const randomSitBtn = document.getElementById('randomSitBtn');
const startBtn=document.getElementById('startBtn');
const resetBtn=document.getElementById('resetBtn');
const checkBtn=document.getElementById('checkBtn');
const scoreVal=document.getElementById('scoreVal');
const triesVal=document.getElementById('triesVal');
const triesBadge = document.getElementById('triesBadge');
const scoreBadge = document.getElementById('scoreBadge');
const descHud = document.getElementById('descHud');

const tolNotes = document.getElementById('tolNotes');

const targetPanel      = document.getElementById('targetPanel');
const targetPanelTitle = document.getElementById('targetPanelTitle');
const targetPanelBody  = document.getElementById('targetPanelBody');

const continueBtn = document.getElementById('continueBtn');
const seqPanel    = document.getElementById('seqPanel');
const seqBody     = document.getElementById('seqBody');
const seqInput    = document.getElementById('seqInput');
const seqNoteInput = document.getElementById('seqNoteInput');

/* Play Sequence Builder refs */
const seqSubsec      = document.getElementById('seqSubsec');
const seqPosGrid     = document.getElementById('seqPosGrid');
const seqList        = document.getElementById('seqList');
const seqTemplateSel = document.getElementById('seqTemplateSel');
const seqClearBtn    = document.getElementById('seqClearBtn');
const seqCountHud    = document.getElementById('seqCountHud');

const timerBadge = document.getElementById('timerBadge');
const timerVal   = document.getElementById('timerVal');

const coachBtn=document.getElementById('coachBtn');
// Ensure header groups exist and move elements into them for consistent layout

const ensureHeaderGrouping = () => {
  const header = document.querySelector('header');
  if (!header) return;

  // Ensure .header-actions exists to group start/reset/check/hud/coach
  let actions = header.querySelector('.header-actions');
  if (!actions) {
    actions = document.createElement('div');
    actions.className = 'header-actions';
    header.appendChild(actions);
  }

  // Explicit order inside the actions row
  const order = [
    document.getElementById('randomSitBtn'),
    document.getElementById('sitSelect'),
    document.getElementById('descHud'),
    document.getElementById('runnersBadge'),
    document.getElementById('outsHud'),
    document.getElementById('startBtn'),
    document.getElementById('resetBtn'),
    document.getElementById('checkBtn'),
    document.getElementById('continueBtn'),
    document.getElementById('hud'),
    document.getElementById('coachBtn'),
  ];

  order.forEach(el => { if (el) actions.appendChild(el); });

  // Keep <h1> at the very front
  const h1 = header.querySelector('h1');
  if (h1) header.insertBefore(h1, header.firstChild);
};

// @diq:begin [A_PITCH_LAYOUT] Pitch-recognition inspired layout (DOM move only)
function applyPitchRecognitionLayout(){
  const aside = document.querySelector('aside.sideCol');
  const sitCard = document.getElementById('situationCard');
  const sitMount = document.getElementById('situationControlsMount');
  const hudMount = document.getElementById('playHudMount');
  const headerDock = document.getElementById('diqHeaderDock');

  // Move the situation control bar (buttons/select/badges) out of the header into the Situation card
  // Do this by IDs so it works even if markup changes, while keeping all existing logic/listeners intact.
  const moveById = (id, mount) => {
    const el = document.getElementById(id);
    if (el && mount && el.parentElement !== mount){
      mount.appendChild(el);
    }
  };

  // Build 3 rows inside the Situation card:
  // Row 1: Random + Situation dropdown
  // Row 2: Situation Title + (optional) Desc + Runners + Outs
  // Row 3: Start/Reset/Check/Continue/Verify (only visible when the app shows them)
  const buildSituationRows = () => {
    if (!sitMount) return null;

    // Clear any previous children (we'll re-append the real elements to the right row)
    sitMount.innerHTML = '';

    const row1 = document.createElement('div');
    row1.className = 'sitRow sitRow1';

    const row2 = document.createElement('div');
    row2.className = 'sitRow sitRow2';

    const row3 = document.createElement('div');
    row3.className = 'sitRow sitRow3';

    sitMount.appendChild(row1);
    sitMount.appendChild(row2);
    sitMount.appendChild(row3);

    return { row1, row2, row3 };
  };

  const rows = buildSituationRows();

  // Primary: if we have a header dock wrapper, drain it (so the IDs exist in DOM), then we will re-home by id
  if (headerDock){
    // Don't leave the old controls in the header even if something unexpected lives there
    headerDock.style.display = 'none';
  }

  // Explicitly place known situation controls into the correct row
  if (rows){
    // Row 1
    ['randomSitBtn','sitSelect'].forEach(id => moveById(id, rows.row1));

    // Row 2
    ['descHud','runnersBadge','outsHud'].forEach(id => moveById(id, rows.row2));

    // Row 3
    ['startBtn','resetBtn','checkBtn','continueBtn','verifySeqBtn'].forEach(id => moveById(id, rows.row3));
  }

  // After moving, hide the dock wrapper if it still exists
  if (headerDock){
    headerDock.style.display = 'none';
  }

  // Move HUD badges into the Play card header
  const hud = document.getElementById('hud');
  if (hud && hudMount){
    hudMount.appendChild(hud);
  }

  // Merge Selected Target + Play Sequence into Situation subcards
  const targetPanel = document.getElementById('targetPanel');
  const targetMount = document.getElementById('situationTargetMount');
  if (targetPanel && targetMount){
    targetMount.appendChild(targetPanel);
  }

  const seqPanel = document.getElementById('seqPanel');
  const seqMount = document.getElementById('situationSeqMount');
  if (seqPanel && seqMount){
    seqMount.appendChild(seqPanel);
  }

  // Subcards should appear only when relevant to the current phase
  const targetSub = document.getElementById('situationTargetSubcard');
  const seqSub    = document.getElementById('situationSeqSubcard');

  function updateSituationSubcardsVisibility(){
    // Prefer the app's current phase if available; fall back to DOM visibility of panels
    const phase = (window.__diqHowToPhase || window.diqHowToPhase || window.currentPhase || '').toString();
    const isP2 = phase === 'p2' || phase === 'phase2' || phase === 'seq';
    const isP1 = phase === 'p1' || phase === 'phase1' || phase === 'chips' || phase === '';

    // Selected Target: hidden by default; show only after Phase 1 completes (all correct OR out of tries)
    if (targetSub){
      const tp = document.getElementById('targetPanel');
      const shouldShow = (typeof isPostRound === 'function') ? isPostRound() : (tp && !tp.classList.contains('hidden'));
      targetSub.style.display = shouldShow ? '' : 'none';
    }

    // Play Sequence: hidden by default; show only during/after Phase 2 and when there is an actual sequence rendered
    if (seqSub){
      const hasSeqItems = !!(seqPanel && (seqPanel.querySelectorAll('li').length > 0 || seqPanel.querySelectorAll('.seqItem').length > 0));
      seqSub.style.display = (isP2 && hasSeqItems) ? '' : 'none';
    }
  }

  // Expose for other logic to trigger without changing core game behavior
  try{ window.__diqUpdateSituationSubcardsVisibility = updateSituationSubcardsVisibility; }catch(e){}

  // Hook setHowToPhase without changing app logic
  if (!window.__diqPRPhaseHooked){
    window.__diqPRPhaseHooked = true;
    const orig = window.setHowToPhase;
    if (typeof orig === 'function'){
      window.setHowToPhase = function(ph){
        try { window.__diqHowToPhase = ph; } catch(e){}
        const r = orig.apply(this, arguments);
        try { updateSituationSubcardsVisibility(); } catch(e){}
        return r;
      };
    }
  }

  // Initial state
  try { updateSituationSubcardsVisibility(); } catch(e){}

  // Header "Play Info" button shows instructions in the main Play pane (replaces field until back)
  const playInfoTopBtn = document.getElementById('playInfoTopBtn');
  const playInfoMainPane = document.getElementById('playInfoMainPane');
  const playInfoMainBody = document.getElementById('playInfoMainBody');
  const playInfoBackBtn  = document.getElementById('playInfoBackBtn');
  const wrap = document.getElementById('wrap');

  function showPlayInfoInMain(){
    if (!playInfoMainPane || !playInfoMainBody) return;
    // Help view should explain BOTH phases (Fielding Positions + Relay Sequence)
    playInfoMainBody.innerHTML = HOWTO_HELP_HTML;
    playInfoMainPane.classList.add('active');
    playInfoMainPane.style.display = '';
    if (wrap) wrap.style.display = 'none';
  }

  function hidePlayInfoInMain(){
    if (playInfoMainPane){
      playInfoMainPane.classList.remove('active');
      playInfoMainPane.style.display = 'none';
    }
    if (wrap) wrap.style.display = '';
    if (playInfoMainBody) playInfoMainBody.innerHTML = '';
  }


  if (playInfoTopBtn && !playInfoTopBtn.__diqWired){
    playInfoTopBtn.__diqWired = true;
    playInfoTopBtn.addEventListener('click', ()=>{
      // If already showing play info, go back to play
      const active = !!(playInfoMainPane && playInfoMainPane.classList.contains('active'));
      if (active) hidePlayInfoInMain();
      else showPlayInfoInMain();
    });
  }
  if (playInfoBackBtn && !playInfoBackBtn.__diqWired){
    playInfoBackBtn.__diqWired = true;
    playInfoBackBtn.addEventListener('click', hidePlayInfoInMain);
  }


  // Player card: move How-To content into player sidebar card and toggle via "Play Info" button
  const playerCard = document.getElementById('playerSidebarCard');
  const howToCard  = document.getElementById('howToCard');
  const howToDetails = document.getElementById('howToDetails');

  if (playerCard){
    // Ensure player card is visible in the new sidebar layout
    playerCard.classList.remove('hidden');

    // Place Player card above Situation card (like the reference layout)
    if (aside && sitCard && aside.contains(sitCard) && aside.contains(playerCard)){
      if (aside.firstElementChild !== playerCard){
        aside.insertBefore(playerCard, sitCard);
      }
    }
    // Mount the how-to details as a subcard inside the player card
    if (howToDetails){
      let box = document.getElementById('playerPlayInfoBox');
      if (!box){
        box = document.createElement('div');
        box.id = 'playerPlayInfoBox';
        box.className = 'subcard hidden';
        const t = document.createElement('div');
        t.className = 'subcardTitle';
        t.textContent = 'How it works';
        box.appendChild(t);
        playerCard.appendChild(box);
      }

      // Move the how-to body (not the outer card)
      const howBody = howToDetails.querySelector('.howto-body') || howToDetails;
      if (howBody && !box.contains(howBody)){
        box.appendChild(howBody);
      }

      // Remove the old how-to card from the sidebar to avoid duplicates
      if (howToCard) howToCard.style.display = 'none';
    }
  }
}
// @diq:end [A_PITCH_LAYOUT]



const coachCard=document.getElementById('coachCard');
const coachStatus=document.getElementById('coachStatus');

const tolTargetSel=document.getElementById('tolTargetSel');
const tolNum=document.getElementById('tolNum');
const tolRange=document.getElementById('tolRange');

function selectTolTarget(id, opts = {}){
  if(!id || !tolTargetSel) return;
  tolTargetSel.value = id;
  tolTargetSel.dispatchEvent(new Event('change', { bubbles:true }));
  if(opts && opts.focusNotes && tolNotes){
    try{ tolNotes.focus(); }catch(e){}
  }
}

const hitTypeSel=document.getElementById('hitTypeSel');
const testHitBtn=document.getElementById('testHitBtn');
const advanceSel=document.getElementById('advanceSel');

const downloadCurrentBtn=document.getElementById('downloadCurrentBtn');
const downloadAllBtn=document.getElementById('downloadAllBtn');

const pwModal=document.getElementById('pwModal');
const pwInput=document.getElementById('pwInput');
const pwOk=document.getElementById('pwOk');
const pwCancel=document.getElementById('pwCancel');
const pwMsg=document.getElementById('pwMsg');

const newTitleInput   = document.getElementById('newTitleInput');
const newDescInput    = document.getElementById('newDescInput');
const newSituationBtn  = document.getElementById('newSituationBtn');
const saveSituationBtn = document.getElementById('saveSituationBtn');
const deleteSituationBtn = document.getElementById('deleteSituationBtn');
const resetStartsBtn = document.getElementById('resetStartsBtn');
const sbUndoBtn = document.getElementById('sbUndoBtn');
const sbRedoBtn = document.getElementById('sbRedoBtn');
const situationMsg     = document.getElementById('situationMsg');

const outsValHud      = document.getElementById('outsVal');
const outsSelSituation = document.getElementById('outsSelSituation');
const runnersValHud   = document.getElementById('runnersVal');

const run1B = document.getElementById('run1B');
const run2B = document.getElementById('run2B');
const run3B = document.getElementById('run3B');

/// @diq:begin [A0.3] Geometry & scaling (deduped)
function unitToCss(native){ return { left:native.x*(imgRect.width/IMG_W), top:native.y*(imgRect.height/IMG_H) }; }
function cssToUnit(left,top){ return { x:left*(IMG_W/imgRect.width), y:top*(IMG_H/imgRect.height) }; }
function nativeToCssPoint(pt){ const css=unitToCss(pt); return { x:css.left, y:css.top }; }

function updateChipScale(){
  const base = Math.min(imgRect.width, imgRect.height);
  // slightly smaller than before (still larger than bases, text remains very readable)
  const size = clamp(Math.round(base * 0.045), 11, 30);
  CHIP_PX = size;
  const fz = clamp(Math.round(size * 0.46), 9, 14);
  wrap.style.setProperty('--chip-size', size + 'px');
  wrap.style.setProperty('--chip-font', fz + 'px');
}

function tolToCssDiameter(tol, allowTiny=false){
  const s = Math.min(imgRect.width / IMG_W, imgRect.height / IMG_H);
  const dCss = 2 * tol * s;
  if (allowTiny) return Math.max(6, Math.round(dCss));
  const minByChip = CHIP_PX * 1.8;
  return Math.round(Math.max(dCss, minByChip));
}

// @diq:end [A0]
/// @diq:begin [A1] Resize & Layout (single source of truth)
/* schedule layout on next frame (avoid resize jank) */
let _resizeRaf = null;
function scheduleLayout(){
  if (_resizeRaf) cancelAnimationFrame(_resizeRaf);
  _resizeRaf = requestAnimationFrame(() => {
    _resizeRaf = null;
    sizeOverlays();
  });
}

/* observe #wrap ‚Äî reacts to container changes, not just window resize */
let _wrapResizeObserver = null;
function observeWrap(){
  if (!window.ResizeObserver || !wrap) return;
  try{
    if (_wrapResizeObserver) _wrapResizeObserver.disconnect();
    _wrapResizeObserver = new ResizeObserver(() => scheduleLayout());
    _wrapResizeObserver.observe(wrap);
  }catch{}
}

/* global listeners */
window.addEventListener('resize', scheduleLayout);
window.addEventListener('orientationchange', scheduleLayout);

window.addEventListener('resize', updateDescriptionHudText);
window.addEventListener('orientationchange', updateDescriptionHudText);

// @diq:end [A1]
/// @diq:begin [A2] Marker Scaling (single copy)
// Increased starting sizes; still scale down/up responsively
const BASE_MARKER_SIZES = {
  ball:40,
  runner:50,      // animated batter
  baseRunner:50,  // static on-base runners
  hit:40
};

function uiScale(){
  return Math.min(imgRect.width / IMG_W, imgRect.height / IMG_H);
}

function getBallStrokeWidth(){
  const s = uiScale();
  return clamp(Math.round(3 * s * 1.1), 2, 6);
}

function scaleMarkers(){
  const s = uiScale();
  const sizePx = (base, min=8, max=28) => clamp(Math.round(base * s), min, max);

  wrap.querySelectorAll('.runner .rlabel, .baseRunner .rlabel').forEach(el=>{
    const s = uiScale();
    el.style.fontSize = clamp(Math.round(13 * s * 1.05), 11, 18) + 'px';
  });

  // Ball
  if (ballEl){
    const d = sizePx(BASE_MARKER_SIZES.ball, 8, 26);
    ballEl.style.width  = d + 'px';
    ballEl.style.height = d + 'px';
    const outline = clamp(Math.round(2 * s), 1, 3);
    const drop    = clamp(Math.round(3 * s), 1, 4);
    ballEl.style.boxShadow = `0 0 0 ${outline}px #000, 0 1px ${drop}px rgba(0,0,0,.35)`;
  }

  // Animated batter
  if (runnerEl){
    const d = sizePx(BASE_MARKER_SIZES.runner, 8, 24);
    runnerEl.style.width  = d + 'px';
    runnerEl.style.height = d + 'px';
  }

  // Static + moving base runners
  if (wrap){
    wrap.querySelectorAll('.baseRunner, .movingRunner').forEach(el=>{
      const d = sizePx(BASE_MARKER_SIZES.baseRunner, 12, 48);
      el.style.width  = d + 'px';
      el.style.height = d + 'px';
    });
  }

  if (hitMarker){
    const d = sizePx(BASE_MARKER_SIZES.hit, 10, 28);
    hitMarker.style.width  = d + 'px';
    hitMarker.style.height = d + 'px';
  }
}

// @diq:end [A2]
/// @diq:begin [A3] Chips (tokens) ‚Äî core drag/drop
/* Token registry: id -> { el, pos:{x,y} } */
const tokens = new Map();

/* Remove any existing chips */
function clearChips(){
  if (!wrap) return;
  wrap.querySelectorAll('.chip').forEach(n=>n.remove());
  tokens.clear();
}

/* Build 9 draggable chips and place them at the current situation starts */
function buildTokens(){
  clearChips();

  const sKey = (currentSituation && currentSituation.key) || (SITUATIONS[0] && SITUATIONS[0].key);

  POS_IDS.forEach(id=>{
    const el=document.createElement('div');

    const group = (['P','C'].includes(id) ? 'Battery'
                 : (['1B','2B','SS','3B'].includes(id) ? 'Infield' : 'Outfield'));

    el.className = `chip ${group}`;
    el.textContent = id;
    wrap.appendChild(el);

    // pick a start from saved map (if any), else DEFAULT_STARTS
    const start = sKey ? getStartFor(sKey,id) : DEFAULT_STARTS[id];

    tokens.set(id, { el, pos: Fcopy(start) });
    placeToken(id);
    makeChipDraggable(el,id);
  });
}

/* Position a single chip according to its native pos -> CSS px */
function placeToken(id){
  const rec = tokens.get(id);
  if (!rec || !rec.pos || !rec.el) return;   // safe if buildTokens hasn't run yet
  const css = unitToCss(rec.pos);
  rec.el.style.left = css.left + 'px';
  rec.el.style.top  = css.top  + 'px';
}

/* Can the user drag chips right now? */
function canDrag(){
  return coachUnlocked || (gameActive && remainingTries > 0);
}

/* Basic pointer-driven dragging (writes native coords back to tokens map) */
function makeChipDraggable(el,id){
  let drag=null;
  let preSnap=null;

  // --- drag for Phase 1 / coach ---
  el.addEventListener('pointerdown', e=>{
    if (!canDrag()) return;
    e.preventDefault();
    el.setPointerCapture(e.pointerId);

    // Situation Builder history: capture pre-edit snapshot (coach only)
    if (coachUnlocked && currentSituation) { try{ preSnap = sbSnapshot(); }catch(err){ preSnap=null; } }

    const rec = tokens.get(id);
    const css = unitToCss(rec.pos);

    drag = { cx:e.clientX, cy:e.clientY, left:css.left, top:css.top };

    const onMove = (e2)=>{
      if (!drag) return;
      const left = drag.left + (e2.clientX - drag.cx);
      const top  = drag.top  + (e2.clientY - drag.cy);
      el.style.left = left + 'px';
      el.style.top  = top  + 'px';
      const native = cssToUnit(left, top);
      tokens.get(id).pos = { x: native.x, y: native.y };
    };

    const onUp = ()=>{
      window.removeEventListener('pointermove', onMove);

      // Persist coach-edited starts for this situation and record undo step
      if (coachUnlocked && currentSituation){
        try{
          const starts = getOnscreenStarts();
          startsMap[currentSituation.key] = Fcopy(starts);
          currentSituation.starts = Fcopy(starts);
          saveStarts();
        }catch(e){}
        try{ if(preSnap) sbPushUndo(preSnap); }catch(e){}
        preSnap = null;
      }

      drag = null;
    };

    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp, { once:true });
  });

  el.addEventListener('click', ()=>{
    if (!phase2Active) return;
    if (!seqOrder || !seqOrder.length) return;

    // Don‚Äôt allow toggling locked (already-correct) chips
    if (phase2Locked.has(id)) return;

    const idx = phase2Picks.indexOf(id);

    if (idx === -1){
      // ‚úÖ Allow selecting beyond required count; verification will fail if length mismatches
      phase2Picks.push(id);
      setChipPickIndex(el, phase2Picks.length);
    } else {
      // Deselect this chip and renumber visible badges
      phase2Picks.splice(idx, 1);
      clearChipPickMarker(el);
      rerenderPickMarkers();
    }

    // Keep the Play Sequence panel hidden until success/exhaustion
    hideSeqPanel();
  });

}

// @diq:end [A3]
/// @diq:begin [A4] Targets (rings)
function getRingEl(id){ return wrap.querySelector(`.tgt[data-id="${id}"]`); }
function getAllRings(){ return Array.from(wrap.querySelectorAll('.tgt')); }
function buildTargets(){
  getAllRings().forEach(n=>n.remove());
  const t=currentSituation.targets||{};
  Object.entries(t).forEach(([id,pt])=>{
    const ring=document.createElement('div');
    ring.className='tgt'; ring.dataset.id = id;
    const css=unitToCss(pt);
    ring.style.left=css.left+'px'; ring.style.top =css.top +'px';
    const label=document.createElement('span');
    label.className='tgt-label'; label.textContent=id;
    ring.appendChild(label);
    const tol = Number(pt.tol) || DEFAULT_TOL;
    const dpx = tolToCssDiameter(tol, coachUnlocked);
    ring.style.width  = dpx + 'px';
    ring.style.height = dpx + 'px';
    if (coachUnlocked){
      ring.style.display='block';
      ring.classList.add('show-label','draggable'); ring.classList.remove('locked');
      makeTargetDraggable(ring,id);

      // Coach convenience: click a ring to select it in Targets & Tolerance dropdown
      ring.addEventListener('click', (e)=>{
        if(!coachUnlocked) return;
        e.stopPropagation();
        selectTolTarget(id);
      });
    } else {
      ring.style.display='none';
      ring.classList.remove('show-label','draggable'); ring.classList.add('locked');
    }
    wrap.appendChild(ring);
  });
}
function makeTargetDraggable(el,id){
  let drag=null;
  let preSnap=null;
  el.addEventListener('pointerdown',e=>{
    if(!coachUnlocked) return;
    e.preventDefault();
    el.setPointerCapture(e.pointerId);
    drag={cx:e.clientX,cy:e.clientY,left:parseFloat(el.style.left),top:parseFloat(el.style.top)};

    if (coachUnlocked && currentSituation) { try{ preSnap = sbSnapshot(); }catch(err){ preSnap=null; } }
    window.addEventListener('pointermove',onMove);
    window.addEventListener('pointerup',onUp,{once:true});
  });
  function onMove(e){
    if(!drag) return;
    const left=drag.left+(e.clientX-drag.cx);
    const top =drag.top +(e.clientY-drag.cy);
    el.style.left=left+'px'; el.style.top=top+'px';
    const pt=cssToUnit(left,top);
    setTargetFor(currentSituation.key,id,pt,currentSituation.targets?.[id]?.tol ?? DEFAULT_TOL);
  }
  function onUp(){
    window.removeEventListener('pointermove',onMove);
    try{ if(preSnap) sbPushUndo(preSnap); }catch(e){}
    preSnap=null;
    drag=null;
  }
}

function shouldShowTargetPanel(){
  // Selected Target sub-card should only be visible AFTER Phase 1 ends (post-round),
  // BEFORE Phase 2 starts, and NOT after Phase 2 has ended.
  return (typeof isPostRound === 'function' && isPostRound()) && !_targetPanelDismissedOnce && !phase2Active && !_phase2Ended;
}

function renderTargetPanel(id){
  if (!targetPanel || !targetPanelTitle || !targetPanelBody) return;
  if (!shouldShowTargetPanel()) { hideTargetPanel?.(); return; }
  _currentSelectedTargetId = id;

  targetPanel.classList.remove('hidden');
  targetPanelTitle.textContent = 'Selected Target';

  const notes = getTargetNotes(currentSituation.key, id);
  targetPanelBody.innerHTML = notes
    ? `<div style="font-weight:800;margin-bottom:6px">Selected Target: ${id}</div><div>${String(notes).replace(/\n/g, '<br>')}</div>`
    : `<div style="font-weight:800;margin-bottom:6px">Selected Target: ${id}</div><div class="hint">No notes.</div>`;
}

function showTargetInstruction(){
  if (!targetPanel || !targetPanelTitle || !targetPanelBody) return;
  if (!shouldShowTargetPanel()) { hideTargetPanel?.(); return; }
  _currentSelectedTargetId = null;

  targetPanel.classList.remove('hidden');
  targetPanelTitle.textContent = `Selected Target`;
  targetPanelBody.innerHTML = `<div class="hint">Select a target ring on the field to view its notes.</div>`;
  targetPanelBody.classList.add('show-instruction');
}

/** Enable click-to-select for rings (used only after last try) */
function enableTargetSelection(){
  getAllRings().forEach(ring=>{
    ring.classList.add('selectable');           // visual affordance
    ring.addEventListener('click', onRingClick);
  });

  // Always show the instruction card when selection turns on (non-coach)
  if (isPostRound()) {
    if (typeof showTargetInstruction === 'function') {
      showTargetInstruction();                  // ‚Üê ensures "Select a target ring..." is visible now
    } else if (typeof showTargetPanel === 'function') {
      showTargetPanel();
    }
  }
}

/** Disable click-to-select for rings and forget the current selection */
function disableTargetSelection(){
  getAllRings().forEach(ring=>{
    ring.classList.remove('selectable');
    ring.removeEventListener('click', onRingClick);
  });
  _currentSelectedTargetId = null;
}

/** Click handler for a ring; shows panel only when game is over (non-coach mode) */
function onRingClick(e){
  if (isPostRound()){
    const id = e.currentTarget?.dataset?.id;
    if (id) {
      renderTargetPanel(id);
      targetPanelBody.classList.remove('show-instruction');
    }
  }
}

/** Panel visibility helpers */
function showTargetPanel(){
  if (targetPanel) targetPanel.classList.remove('hidden');
  const sub = document.getElementById('situationTargetSubcard');
  if (sub) sub.style.display = '';
}
function hideTargetPanel(){
  if (targetPanel) targetPanel.classList.add('hidden');
  const sub = document.getElementById('situationTargetSubcard');
  if (sub) sub.style.display = 'none';
}

// @diq:end [A4]
/// @diq:begin [A5] Runners & Outs
function normalizeRunnersOn(obj){ const src=obj||{}; return { first:!!src.first, second:!!src.second, third:!!src.third }; }
function runnersStateToArray(r){ const out=[]; if(r.first)out.push('1B'); if(r.second)out.push('2B'); if(r.third)out.push('3B'); return out; }
function getRunnersFromCheckboxes(){ return { first:!!(run1B&&run1B.checked), second:!!(run2B&&run2B.checked), third:!!(run3B&&run3B.checked) }; }
function updateRunnersHudFromLive(){
  if (!runnersValHud) return;
  // Show the runners defined by the situation (static), not the live/animated state
  const baseSource = (currentSituation && currentSituation.runnersOn)
    ? normalizeRunnersOn(currentSituation.runnersOn)
    : normalizeRunnersOn(liveRunners);
  const arr = runnersStateToArray(baseSource);
  runnersValHud.textContent = arr.length ? arr.join(',') : '‚Äî';
}
function setRunnersOn(next,{quiet=true}={}){
  if (!currentSituation) return;
  const newState = next ? normalizeRunnersOn(next) : normalizeRunnersOn(getRunnersFromCheckboxes());
  currentSituation.runnersOn = { ...newState };
  if (!gameActive) liveRunners = { ...newState };
  if (run1B&&run2B&&run3B){ run1B.checked=!!newState.first; run2B.checked=!!newState.second; run3B.checked=!!newState.third; }
  updateRunnersHudFromLive();
  renderBaseRunners();
  scaleMarkers();
  if (!quiet && situationMsg){ situationMsg.textContent='Runners updated'; setTimeout(()=>situationMsg.textContent='',900); }
}
function setOuts(value,{quiet=true}={}){
  if (!currentSituation) return;
  const v = clampInt(value,0,2);
  currentSituation.outs = v;
  if (outsValHud) outsValHud.textContent = String(v);
  if (outsSelSituation && outsSelSituation.value !== String(v)) outsSelSituation.value = String(v);
  if (!quiet && situationMsg){ situationMsg.textContent='Outs updated'; setTimeout(()=>{situationMsg.textContent='';},900); }
}
/* draw/remove base runners  */
function renderBaseRunners(state, exclude = new Set()){
  // Merge explicit excludes + global suppression
  const blocked = new Set([...exclude, ..._animSuppressedBases]);

  // Only remove static dots; keep animated movers alive
  if (wrap) wrap.querySelectorAll('.baseRunner:not(.movingRunner)').forEach(n=>n.remove());

  const r = state ? normalizeRunnersOn(state) : normalizeRunnersOn(liveRunners);

  const add=(baseName)=>{
    if (blocked.has(baseName)) return; // skip bases we‚Äôre animating
    const pos=BASES_NATIVE[baseName]; if(!pos||!wrap) return;
    const m=document.createElement('div');
    m.className='baseRunner';
    m.dataset.base = baseName;
    const css=unitToCss(pos);
    m.style.left=css.left+'px';
    m.style.top =css.top +'px';
    wrap.appendChild(m);
  };

  if (r.first)  add('first');
  if (r.second) add('second');
  if (r.third)  add('third');

  if (typeof scaleMarkers === 'function') scaleMarkers();
}
function advanceRunnersState(state,bases){
  bases = clampInt(bases,0,3);
  const r = normalizeRunnersOn(state);
  if (bases<=0) return {...r};
  const occ=[]; if(r.first)occ.push(1); if(r.second)occ.push(2); if(r.third)occ.push(3);
  occ.sort((a,b)=>b-a);
  const dest={1:false,2:false,3:false};
  for(const b of occ){ const nb=b+bases; if (nb<4) dest[nb]=true; }
  return { first:!!dest[1], second:!!dest[2], third:!!dest[3] };
}

// @diq:end [A5]
/// @diq:begin [A6] Ball & Hit
function buildBallGraphics(){
  ballLayer.innerHTML = '';
  const svgNS='http://www.w3.org/2000/svg';
  const svg=document.createElementNS(svgNS,'svg');
  svg.setAttribute('viewBox',`0 0 ${imgRect.width} ${imgRect.height}`);
  ballSvg=svg; ballLayer.appendChild(svg);
  if (!ballEl){
    ballEl=document.createElement('div');
    ballEl.className='ball'; ballEl.style.display='none';
    wrap.appendChild(ballEl);
    makeBallDraggable(ballEl);
  }
  syncBallToHit();
}
function ensureDefaultHit(){
  if (!currentSituation) return;
  if (!currentSituation.hit || isNaN(currentSituation.hit.x) || isNaN(currentSituation.hit.y)){
    currentSituation.hit = { x:1500, y:900 };
  }
}
function syncBallToHit(){
  if (!ballEl || !currentSituation) return;
  ensureDefaultHit();
  const css=unitToCss(currentSituation.hit);
  ballEl.style.left=css.left+'px'; ballEl.style.top=css.top+'px';
  ballEl.style.display = (coachUnlocked || gameActive || phase2Active) ? 'block' : 'none';
  ballEl.classList.toggle('locked', !coachUnlocked);
}
function makeBallDraggable(el){
  let drag=null;
  el.addEventListener('pointerdown',e=>{
    if (!coachUnlocked) return;
    e.preventDefault(); el.setPointerCapture(e.pointerId);
    drag={cx:e.clientX,cy:e.clientY,left:parseFloat(el.style.left)||0, top:parseFloat(el.style.top)||0};
    window.addEventListener('pointermove',onMove);
    window.addEventListener('pointerup',onUp,{once:true});
  });
  function onMove(e){
    if(!drag) return;
    const left=drag.left+(e.clientX-drag.cx), top=drag.top+(e.clientY-drag.cy);
    el.style.left=left+'px'; el.style.top=top+'px';
    const pt=cssToUnit(left,top);
    if(currentSituation) currentSituation.hit={ x:Math.round(pt.x), y:Math.round(pt.y) };
  }
  function onUp(){ window.removeEventListener('pointermove',onMove); drag=null; }
}
function placeHitMarker(){
  if (hitMarker){ hitMarker.remove(); hitMarker=null; }
  if (!coachUnlocked) return;
  ensureDefaultHit();
  const css=unitToCss(currentSituation.hit);
  hitMarker=document.createElement('div');
  hitMarker.className='hitTarget'; hitMarker.style.left=css.left+'px'; hitMarker.style.top=css.top+'px';
  wrap.appendChild(hitMarker); makeHitMarkerDraggable(hitMarker);
}
function makeHitMarkerDraggable(el){
  let drag=null;
  el.addEventListener('pointerdown',e=>{
    if (!coachUnlocked) return;
    e.preventDefault(); el.setPointerCapture(e.pointerId);
    drag={cx:e.clientX,cy:e.clientY,left:parseFloat(el.style.left),top:parseFloat(el.style.top)};
    window.addEventListener('pointermove',onMove);
    window.addEventListener('pointerup',onUp,{once:true});
  });
  function onMove(e){
    if(!drag) return;
    const left=drag.left+(e.clientX-drag.cx), top=drag.top+(e.clientY-drag.cy);
    el.style.left=left+'px'; el.style.top=top+'px';
    const pt=cssToUnit(left,top);
    currentSituation.hit={ x:Math.round(pt.x), y:Math.round(pt.y) };
    syncBallToHit();
  }
  function onUp(){ window.removeEventListener('pointermove',onMove); drag=null; }
}
function mapHitTypeToAdvance(hitType){
  switch((hitType||'').toLowerCase()){
    case 'grounder': return 1;
    case 'line':     return 2;
    case 'popup':    return 0;
    default:         return 1;
  }
}
function animateHit(style){
  const sit=currentSituation; if(!sit) return;
  ensureDefaultHit(); style = style || sit.hitType || 'line';
  if (ballSvg) ballSvg.innerHTML='';
  const startCss=nativeToCssPoint(HOME_NATIVE), endCss=nativeToCssPoint(sit.hit);
  const svgNS='http://www.w3.org/2000/svg';

  // Popup path controls (used for both the blue line + the moving ball so it always follows the line)
  let popupC1=null, popupC2=null;

  if (style==='line' || style==='grounder'){
    ballPath=document.createElementNS(svgNS,'line');
    Object.entries({x1:startCss.x,y1:startCss.y,x2:endCss.x,y2:endCss.y}).forEach(([k,v])=>ballPath.setAttribute(k,v));
    ballPath.setAttribute('stroke','#0ea5e9');
    ballPath.setAttribute('stroke-width', String(getBallStrokeWidth()));
    if (style==='grounder') ballPath.setAttribute('stroke-dasharray','8 8');
    ballSvg.appendChild(ballPath);
  } else {
    // Cubic bezier gives a nice high arch while allowing a gentler "descent" near the end.
    const distLocal=Math.hypot(endCss.x-startCss.x,endCss.y-startCss.y);
    const archH=clamp(distLocal*0.70, 180, 420); // higher arch
    const dx=endCss.x-startCss.x, dy=endCss.y-startCss.y;

    // Peak earlier + reduce lift near landing so there's less arch at the very end.
    popupC1={ x:startCss.x + dx*0.35, y:startCss.y + dy*0.35 - archH };
    popupC2={ x:startCss.x + dx*0.78, y:startCss.y + dy*0.78 - archH*0.25 };

    const d=`M ${startCss.x},${startCss.y} C ${popupC1.x},${popupC1.y} ${popupC2.x},${popupC2.y} ${endCss.x},${endCss.y}`;
    ballPath=document.createElementNS(svgNS,'path');
    ballPath.setAttribute('d',d); ballPath.setAttribute('fill','none');
    ballPath.setAttribute('stroke','#0ea5e9');
    ballPath.setAttribute('stroke-width', String(getBallStrokeWidth()));
    ballSvg.appendChild(ballPath);
  }

  ballEl.style.left=`${startCss.x}px`; ballEl.style.top=`${startCss.y}px`; ballEl.style.display='block';
  const dist=Math.hypot(endCss.x-startCss.x,endCss.y-startCss.y);
  const duration = clamp(1200 + dist * 0.90, 1500, 3200); // slower + smoother
  let t0=performance.now(); if (animReq) cancelAnimationFrame(animReq);
  const p0={x:startCss.x,y:startCss.y}, p3={x:endCss.x,y:endCss.y};

  function cubicPoint(a,b,c,d,t){
    const mt=1-t, mt2=mt*mt, t2=t*t;
    const w0=mt2*mt, w1=3*mt2*t, w2=3*mt*t2, w3=t2*t;
    return { x:w0*a.x + w1*b.x + w2*c.x + w3*d.x,
             y:w0*a.y + w1*b.y + w2*c.y + w3*d.y };
  }

  function step(now){
    const t=clamp((now-t0)/duration,0,1);

    // For popup: ease-in-out to simulate "hang time" while still tracking the same blue line path.
    const u=(style==='popup')?(0.5-0.5*Math.cos(Math.PI*t)):t;

    const pos=(style==='popup' && popupC1 && popupC2)
      ? cubicPoint(p0,popupC1,popupC2,p3,u)
      : {x:lerp(p0.x,p3.x,t), y:lerp(p0.y,p3.y,t)};

    ballEl.style.left=`${pos.x}px`; ballEl.style.top=`${pos.y}px`;
    if (t<1) animReq=requestAnimationFrame(step);
    else { if (ballSvg) ballSvg.innerHTML=''; animReq=null; if (ballEl) ballEl.style.display='block'; }
  }
  animReq=requestAnimationFrame(step);
}
function ensureRunner(){
  if (!runnerEl){
    runnerEl = document.createElement('div');
    runnerEl.className = 'runner';
    runnerEl.style.display = 'none';

    // Add label element inside (counter-rotated via CSS)
    const lab = document.createElement('span');
    lab.className = 'rlabel';
    lab.textContent = 'B'; // Batter when moving
    runnerEl.appendChild(lab);

    wrap.appendChild(runnerEl);
  }
}
function placeRunnerAtBase(base){
  ensureRunner();
  runnerLastBase = base;

  const pt = BASES_NATIVE[base] || BASES_NATIVE.home;
  const css = unitToCss(pt);

  runnerEl.style.left = css.left + 'px';
  runnerEl.style.top  = css.top  + 'px';
  runnerEl.style.display = 'block';

  // Label B1/B2/B3 on base; hide on home
  const lab = runnerEl.querySelector('.rlabel');
  if (lab){
    lab.textContent =
      base === 'first'  ? 'B1' :
      base === 'second' ? 'B2' :
      base === 'third'  ? 'B3' : 'B';
  }
}
function hideRunner(){ if (runnerEl) runnerEl.style.display='none'; runnerLastBase='home'; }
function animateBatterAdvance(basesAdvanced, onDone){
  ensureRunner();
  if (runnerAnimId){ cancelAnimationFrame(runnerAnimId); runnerAnimId=null; }

  // Normalize + clamp
  basesAdvanced = clampInt(basesAdvanced, 0, 4);

  // If OUT (0 bases), show a short run toward 1B and stop (to visualize the throw-out)
  if (basesAdvanced === 0){
    const fromCss = nativeToCssPoint(BASES_NATIVE['home']);
    const toCss   = nativeToCssPoint(BASES_NATIVE['first']);

    // Place runner at home to start
    runnerEl.style.left = fromCss.x + 'px';
    runnerEl.style.top  = fromCss.y + 'px';
    runnerEl.style.display = 'block';
    runnerLastBase = 'home';

    // Stop ~80% of the way to 1B (tweak if you want)
    const stopT = 0.80;
    const midX  = lerp(fromCss.x, toCss.x, stopT);
    const midY  = lerp(fromCss.y, toCss.y, stopT);

    const dist = Math.hypot(toCss.x - fromCss.x, toCss.y - fromCss.y) * stopT;
    const duration = clamp(700 + dist * 0.55, 600, 1400);

    let t0 = performance.now();
    const step = (now) => {
      const t = clamp((now - t0) / duration, 0, 1);
      const e = 1 - Math.pow(1 - t, 3); // ease-out
      runnerEl.style.left = lerp(fromCss.x, midX, e) + 'px';
      runnerEl.style.top  = lerp(fromCss.y, midY, e) + 'px';
      runnerEl.style.display = 'block';
      if (t < 1){
        runnerAnimId = requestAnimationFrame(step);
      } else {
        // Stays visible short of 1B; not credited as reaching first
        runnerLastBase = 'home'; // keep model as not-on-base
        if (typeof onDone === 'function') onDone('home');
      }
    };
    runnerAnimId = requestAnimationFrame(step);
    return;
  }

  // Path of bases (index is "bases moved")
  const path=['home','first','second','third','home'];
  const legs=path.slice(0, Math.min(4,basesAdvanced)+1);

  placeRunnerAtBase(legs[0]);
  let legIdx=0;

  const runLeg=()=>{
    if (legIdx>=legs.length-1){
      // Finished
      const destBase = legs[legs.length-1];      // first/second/third/home
      runnerLastBase = destBase;
      if (typeof onDone === 'function') onDone(destBase);
      return;
    }
    const fromName=legs[legIdx], toName=legs[legIdx+1];
    const fromCss=nativeToCssPoint(BASES_NATIVE[fromName]);
    const toCss  =nativeToCssPoint(BASES_NATIVE[toName]);
    const dist=Math.hypot(toCss.x-fromCss.x,toCss.y-fromCss.y);
    const duration=clamp(700+dist*0.55, 800, 1600);

    let t0=performance.now();
    const step=(now)=>{
      const t=clamp((now-t0)/duration,0,1);
      const e=1-Math.pow(1-t,3);
      runnerEl.style.left=lerp(fromCss.x,toCss.x,e)+'px';
      runnerEl.style.top =lerp(fromCss.y,toCss.y,e)+'px';
      runnerEl.style.display='block';
      if (t<1) runnerAnimId=requestAnimationFrame(step);
      else { runnerLastBase=toName; legIdx++; runLeg(); }
    };
    runnerAnimId=requestAnimationFrame(step);
  };
  runLeg();
}

const BASE_ORDER = ['first', 'second', 'third', 'home'];

/**
 * Animate a runner that starts on a base (first/second/third) forward `advance` bases.
 * Returns a Promise that resolves when this runner's animation finishes.
 */
function animateExistingRunnerFrom(baseName, advance){
  return new Promise(resolve=>{
    // Nothing to do
    const startIdx = BASE_ORDER.indexOf(baseName);
    if (startIdx < 0 || advance <= 0) return resolve();

    // Remove the static dot for this base so we don't double-draw
    const toRemove = wrap.querySelector(`.baseRunner[data-base="${baseName}"]`);
    if (toRemove) toRemove.remove();

    // Create a moving element (reuse .baseRunner styling)
    const mover = document.createElement('div');
    mover.className = 'movingRunner';
    mover.style.position = 'absolute';
    mover.style.transform = 'translate(-50%,-50%)';
    wrap.appendChild(mover);

    // Let it scale like other markers
    if (typeof scaleMarkers === 'function') scaleMarkers();

    // Build its path across legs
    const destIdx = Math.min(startIdx + advance, BASE_ORDER.length - 1); // up to "home"
    const legs = BASE_ORDER.slice(startIdx, destIdx + 1); // e.g. ['first','second','third'] (or 'home')

    // Place at starting base
    const startCss = nativeToCssPoint(BASES_NATIVE[legs[0]]);
    mover.style.left = startCss.x + 'px';
    mover.style.top  = startCss.y + 'px';
    mover.style.display = 'block';

    let leg = 0, animId=null;

    const runLeg = ()=>{
      if (leg >= legs.length - 1){
        // If finished on "home", remove; otherwise we‚Äôll later redraw statically via renderBaseRunners
        if (mover && mover.parentNode) mover.remove();
        return resolve();
      }
      const fromName = legs[leg];
      const toName   = legs[leg + 1];
      const fromCss  = nativeToCssPoint(BASES_NATIVE[fromName]);
      const toCss    = nativeToCssPoint(BASES_NATIVE[toName]);
      const dist     = Math.hypot(toCss.x - fromCss.x, toCss.y - fromCss.y);

      // Match your slower, smooth feel
      const duration = clamp(700 + dist * 0.55, 800, 1600);

      let t0 = performance.now();
      const step = (now)=>{
        const t = clamp((now - t0) / duration, 0, 1);
        const e = 1 - Math.pow(1 - t, 3); // smooth ease-out
        mover.style.left = lerp(fromCss.x, toCss.x, e) + 'px';
        mover.style.top  = lerp(fromCss.y, toCss.y, e) + 'px';
        if (t < 1) animId = requestAnimationFrame(step);
        else { leg++; runLeg(); }
      };
      animId = requestAnimationFrame(step);
    };

    runLeg();
  });
}

/**
 * Animate all existing runners (first/second/third) forward `advance` bases in parallel.
 * Calls onDone(finalState) when all have finished (finalState excludes batter).
 */
function animateExistingRunnersAdvance(advance, onDone){
  const start = normalizeRunnersOn(liveRunners);

  const movers = [];
  if (start.first)  movers.push('first');
  if (start.second) movers.push('second');
  if (start.third)  movers.push('third');

  if (movers.length === 0){
    const finalState = advanceRunnersState(start, advance);
    if (typeof onDone === 'function') onDone(finalState);
    return;
  }

  // Suppress the starting bases for movers (no static dot while they run)
  movers.forEach(b => _animSuppressedBases.add(b));

  // Initial paint while suppressed (so their start dots disappear immediately)
  renderBaseRunners(start);

  // Animate all movers
  Promise.all(movers.map(b => animateExistingRunnerFrom(b, advance)))
    .then(()=>{
      // Compute final state and clear suppression
      const finalState = advanceRunnersState(start, advance);
      movers.forEach(b => _animSuppressedBases.delete(b));

      // Repaint final positions (no ghosts)
      renderBaseRunners(finalState);

      if (typeof onDone === 'function') onDone(finalState);
    });
}

// @diq:end [A6]
/// @diq:begin [A7] Coach tools & visibility
const CALIB_PASSWORD = COACH_PASSWORD;
function applyCoachVisibility(){
  coachCard.classList.toggle('hidden', !coachUnlocked);
  getAllRings().forEach(el=> el.style.display = coachUnlocked ? 'block' : 'none');

  // Single-ball model in coach mode: remove the orange hit marker if present
  if (hitMarker){ hitMarker.remove(); hitMarker = null; }

  // Always show the white ball; draggable when coach is unlocked
  if (ballEl){
    ballEl.style.display = (coachUnlocked || gameActive) ? 'block' : 'none';
    ballEl.classList.toggle('locked', !coachUnlocked);  // unlocked in coach mode
    ballEl.style.zIndex = '10';                         // keep on top of runners/chips
  }

  syncBallToHit();
}

function setChipsLocked(locked){ tokens.forEach(({el})=> el.classList.toggle('locked', locked && !coachUnlocked)); }
function updateHud(scoreCount){
  // --- helper: "Score: <b><span id='scoreVal'>n</span>/<den></b>" ---
  function setScoreDisplay(n, den){
    if (scoreVal) scoreVal.textContent = String(n);
    if (scoreBadge){
      const b = scoreBadge.querySelector('b');
      if (!b) return;
      const sv = b.querySelector('#scoreVal');
      if (!sv) return;

      // ensure the text node immediately after #scoreVal is "/<den>"
      let node = sv.nextSibling;
      if (!node || node.nodeType !== Node.TEXT_NODE){
        while (node){ const next = node.nextSibling; b.removeChild(node); node = next; }
        b.appendChild(document.createTextNode('/' + den));
      } else {
        node.textContent = '/' + den;
      }
    }
  }

  // --- Phase 2 visibility rule for SCORE (hide for players) ---
  const hideScoreForPhase2 = (phase2Active && !coachUnlocked);
  if (scoreBadge) scoreBadge.style.display = hideScoreForPhase2 ? 'none' : '';

  if (!hideScoreForPhase2){
    // Show score in Phase 1 (9 positions) OR in Coach mode during Phase 2
    if (phase2Active){
      // Coach can see Phase 2 progress (consecutive-correct prefix)
      const total = Array.isArray(seqOrder) ? seqOrder.length : 0;
      const good  = (typeof getPhase2ConsecutiveCorrect === 'function')
        ? getPhase2ConsecutiveCorrect()
        : 0;
      setScoreDisplay(good, total);

      if (scoreBadge){
        const pct = total ? (good / total) : 0;
        const state = pct >= 2/3 ? 'green' : (pct >= 1/3 ? 'yellow' : 'red');
        setBadgeState(scoreBadge, state, 'score');
      }
    } else {
      // Phase 1 score (0..9)
      const n = (typeof scoreCount === 'number') ? scoreCount : (Number(scoreVal?.textContent) || 0);
      setScoreDisplay(n, 9);
      if (scoreBadge){
        const pct = n / 9;
        const state = pct >= 2/3 ? 'green' : (pct >= 1/3 ? 'yellow' : 'red');
        setBadgeState(scoreBadge, state, 'score');
      }
    }
  }

  // --- Tries HUD (unchanged semantics) ---
  let triesLabel = '';
  let triesState = 'green';

  if (coachUnlocked) {
    triesLabel = '‚àû';
  } else if (phase2Active) {
    const t = Math.max(0, phase2TriesLeft);
    triesLabel = `${t}/${PHASE2_MAX_TRIES}`;
    triesState = (t >= 2) ? 'green' : (t === 1 ? 'yellow' : 'red');
  } else {
    const t = gameActive ? remainingTries : MAX_TRIES;
    triesLabel = `${t}/${MAX_TRIES}`;
    triesState = (t >= 2) ? 'green' : (t === 1 ? 'yellow' : 'red');
  }

  if (triesVal) triesVal.textContent = triesLabel;
  if (triesBadge) setBadgeState(triesBadge, triesState, 'tries');
}

function setBadgeState(el, state /* 'green'|'yellow'|'red' */, base){
  if (!el) return;
  el.classList.remove(`${base}-green`, `${base}-yellow`, `${base}-red`);
  el.classList.add(`${base}-${state}`);
}

function setCoachMode(enabled){
  coachUnlocked = !!enabled;
  coachStatus.textContent = coachUnlocked ? 'unlocked' : 'locked';
  coachStatus.style.color = coachUnlocked ? '#16a34a' : '#64748b';

  // Ensure Coach Tools panel is only visible when unlocked
  if (typeof coachCard !== 'undefined' && coachCard){
    if (coachUnlocked) coachCard.classList.remove('hidden');
    else coachCard.classList.add('hidden');
  }

  if (coachUnlocked) setChipsLocked(false); else setChipsLocked(!gameActive || remainingTries===0);
  buildTargets(); applyCoachVisibility(); updateHud(Number(scoreVal.textContent)||0);
  disableTargetSelection();
  hideTargetPanel();
  endPhase2(false);
  if (continueBtn) continueBtn.classList.add('hidden');

  // If a Coach Review code was supplied via URL, try to auto-load it when coach mode is enabled
  if(coachUnlocked && typeof window._diqCoachReviewAutoload === 'function'){
    try{ window._diqCoachReviewAutoload(); }catch(e){}
  }
}
function openPwModal(){ pwModal.style.display='flex'; pwMsg.textContent=''; pwInput.value=''; pwInput.focus(); }
function closePwModal(){ pwModal.style.display='none'; }
function tryUnlock(){ if(pwInput.value===CALIB_PASSWORD){ closePwModal(); setCoachMode(true); } else { pwMsg.textContent='Incorrect password.'; } }

// @diq:end [A7]
/// @diq:begin [A8] Situations I/O & helpers
const STORAGE_VERSION = 1;
const STORAGE_STARTS = `bb_iq_starts_v${STORAGE_VERSION}`;
const STORAGE_HITS   = `bb_iq_hits_v${STORAGE_VERSION}`;

/** @param {any} sRaw @param {number} i @returns {Situation} */
function normalizeSituation(sRaw, i){
  const safe = { ...(sRaw||{}) };
  safe.key   = String(safe.key||'').trim() || `S${i+1}`;
  safe.title = safe.title || safe.key;
  safe.desc  = safe.desc  || '';

  // geometry
  safe.targets = normalizeTargets(safe.targets)||{};
  safe.starts  = normalizeStarts(safe.starts);

  // hit + meta
  safe.hit     = normalizeHit(safe.hit);
  safe.hitType = mapHitType(safe.hitType);
  const advJSON = (typeof safe.batterAdvance==='number') ? clampInt(safe.batterAdvance,0,4) : null;
  safe.batterAdvance = (advJSON!=null) ? advJSON : mapHitTypeToAdvance(safe.hitType);

  // countables
  safe.outs = clampInt((safe.outs ?? 0), 0, 2);

  // runners
  safe.runnersOn = normalizeRunnersOn(safe.runnersOn);

  // Phase 2: sequence + note
  const rawSeq = Array.isArray(safe.playSeq) ? safe.playSeq : String(safe.playSeq || '')
                    .split(',')
                    .map(s => s.toUpperCase().trim())
                    .filter(Boolean);
  safe.playSeq = rawSeq.filter(s => POS_IDS.includes(s));
  safe.seqNote = (typeof safe.seqNote === 'string') ? safe.seqNote : '';

  return /** @type {Situation} */ (safe);
}

function defaultStartsMap(){
  const map = {};
  (SITUATIONS||[]).forEach(s=>{ map[s.key] = s.starts ? Fcopy(s.starts) : Fcopy(DEFAULT_STARTS); });
  return map;
}
function migrateLocalStorage(){
  // Example: from v1 -> v2 in the future
  // keep as placeholder; do nothing today
  return;
}
migrateLocalStorage();
loadStarts(); loadHits();
function loadStarts(){
  startsMap = defaultStartsMap();
  try{
    const raw = localStorage.getItem(STORAGE_STARTS); if (!raw) return;
    const saved = JSON.parse(raw);
    Object.keys(saved||{}).forEach(k=>{
      const dst = startsMap[k] || (startsMap[k]=Fcopy(DEFAULT_STARTS));
      POS_IDS.forEach(id=>{
        const v = saved[k]?.[id];
        if (v && !isNaN(v.x) && !isNaN(v.y)) dst[id] = { x:Math.round(Number(v.x)), y:Math.round(Number(v.y)) };
      });
    });
  }catch(e){ console.warn('[Starts] localStorage merge error:', e); }
}
function saveStarts(){ try{ localStorage.setItem(STORAGE_STARTS, JSON.stringify(startsMap)); }catch{} }
function getStartFor(sKey,id){ const s = startsMap[sKey] || DEFAULT_STARTS; return s[id] || DEFAULT_STARTS[id]; }
function setStartFor(sKey,id,pt){ if(!startsMap[sKey]) startsMap[sKey]=Fcopy(DEFAULT_STARTS); startsMap[sKey][id]={x:pt.x,y:pt.y}; }

function loadHits(){ try{ const raw=localStorage.getItem(STORAGE_HITS); hitsMap = raw ? JSON.parse(raw) : {}; }catch{ hitsMap={}; } }
function saveHits(){ try{ localStorage.setItem(STORAGE_HITS, JSON.stringify(hitsMap)); }catch{} }
function getHitSaved(sKey){ const v=hitsMap[sKey]; return (v && !isNaN(v.x) && !isNaN(v.y)) ? { x:Math.round(v.x), y:Math.round(v.y) } : null; }
function setHitSaved(sKey, pt){ if (!pt || isNaN(pt.x) || isNaN(pt.y)) return; hitsMap[sKey] = { x:Math.round(pt.x), y:Math.round(pt.y) }; }

function setTargetFor(sKey,id,pt,tol=DEFAULT_TOL){
  const s = SITUATIONS.find(x=>x.key===sKey); if(!s) return;
  if(!s.targets) s.targets={};
  const prev = s.targets[id] || {};
  const prevNotes = (typeof prev.notes === 'string') ? prev.notes : '';
  const prevTol = (Number.isFinite(prev.tol) ? prev.tol : DEFAULT_TOL);
  // Preserve per-target notes when moving/updating target coordinates.
  s.targets[id] = {
    ...prev,
    x: Math.round(pt.x),
    y: Math.round(pt.y),
    tol: Number(tol || prevTol || DEFAULT_TOL),
    notes: prevNotes
  };
}
function getTargetFor(sKey,id){
  const s = SITUATIONS.find(x=>x.key===sKey);
  return (s && s.targets && s.targets[id]) ? s.targets[id] : null;
}

function normPoint(px){
  if (!px || isNaN(px.x) || isNaN(px.y)) return null;
  let x=Number(px.x), y=Number(px.y);
  if (x>=0 && x<=1 && y>=0 && y<=1){ x=Math.round(x*IMG_W); y=Math.round(y*IMG_H); } else { x=Math.round(x); y=Math.round(y); }
  return {x,y};
}
function normalizeStarts(obj){
  if (!obj || typeof obj !== 'object') return null;
  const out={}; POS_IDS.forEach(id=>{ if (obj[id]){ const p=normPoint(obj[id]); if(p) out[id]=p; }});
  return Object.keys(out).length ? out : null;
}
function normalizeTargets(obj){
  const out={}; if (!obj || typeof obj !== 'object') return out;
  POS_IDS.forEach(id=>{
    const raw = obj[id];
    if (raw){
      const p = normPoint(raw);
      if (p){
        out[id] = {
          x:p.x, y:p.y,
          tol: Number(raw.tol) || DEFAULT_TOL,
          notes: typeof raw.notes === 'string' ? raw.notes : ''
        };
      }
    }
  });
  return out;
}
function normalizeHit(obj){ if (!obj || typeof obj !== 'object') return {}; const p=normPoint(obj); return p ? {x:p.x,y:p.y} : {}; }
function mapHitType(v){ const t=String(v||'').toLowerCase(); return (t==='line'||t==='popup'||t==='grounder')?t:'line'; }

async function loadSituationsFromJson(){
  try{
    const res = await fetch('./situations.json?ts=' + Date.now(), { cache:'no-store' });
    if(!res.ok) throw new Error('HTTP '+res.status);
    const arr = await res.json();
    if (!Array.isArray(arr)) throw new Error('situations.json must be an array');

    SITUATIONS = arr.map((raw,i)=> normalizeSituation(raw,i));
    console.info('[Situations] Loaded', SITUATIONS.length);

  }catch(err){
    console.warn('[Situations] JSON load failed, using fallback:', err?.message||err);
    SITUATIONS = (SITUATIONS_FALLBACK||[]).map((raw,i)=> normalizeSituation(raw,i));
  }

    // Keep an immutable snapshot of the loaded situations for Refresh Situation.
    snapshotSituationsOrig();
}


function snapshotSituationsOrig(){
  try{
    const snap = {};
    (SITUATIONS||[]).forEach(s=>{
      if(!s || !s.key) return;
      snap[s.key] = JSON.parse(JSON.stringify(s));
    });
    SITUATIONS_ORIG_BY_KEY = snap;
  }catch(_e){
    SITUATIONS_ORIG_BY_KEY = {};
  }
}

function restoreSituationFromOrig(key){
  const orig = SITUATIONS_ORIG_BY_KEY && SITUATIONS_ORIG_BY_KEY[key];
  if(!orig) return;
  const idx = (SITUATIONS||[]).findIndex(s=>s && s.key===key);
  if(idx>=0){
    SITUATIONS[idx] = JSON.parse(JSON.stringify(orig));
    // keep currentSituation pointing at the live object
    if(currentSituation && currentSituation.key===key){
      currentSituation = SITUATIONS[idx];
    }
  }
}


// Merge situations from an imported JSON array. Existing keys are deep-merged (import wins).
// Also updates startsMap/hitsMap so imported starts/hit are reflected immediately.
function _diqDeepMerge(dst, src){
  if(!dst || typeof dst!=='object' || Array.isArray(dst)) return deepClone(src);
  if(!src || typeof src!=='object' || Array.isArray(src)) return deepClone(src);
  const out = { ...dst };
  Object.keys(src).forEach(k=>{
    const sv = src[k];
    const dv = dst[k];
    if(sv && typeof sv==='object' && !Array.isArray(sv) && dv && typeof dv==='object' && !Array.isArray(dv)){
      out[k] = _diqDeepMerge(dv, sv);
    }else{
      out[k] = deepClone(sv);
    }
  });
  return out;
}

function mergeSituationsFromArray(rawArr){
  if(!Array.isArray(rawArr)) throw new Error('Situations JSON must be an array.');
  let added = 0, updated = 0;

  rawArr.forEach((raw,i)=>{
    const incoming = normalizeSituation(raw, i);
    if(!incoming || !incoming.key) return;

    const idx = (SITUATIONS||[]).findIndex(s=>s && s.key===incoming.key);
    if(idx >= 0){
      const merged = _diqDeepMerge(SITUATIONS[idx], incoming);
      SITUATIONS[idx] = normalizeSituation(merged, idx);
      // Keep currentSituation pointing at the live object
      if(currentSituation && currentSituation.key === incoming.key){
        currentSituation = SITUATIONS[idx];
      }
      updated++;
    }else{
      SITUATIONS.push(incoming);
      added++;
    }

    // Imported starts/hit should apply immediately (local starts/hit override otherwise)
    if(incoming.starts){
      startsMap[incoming.key] = Fcopy(incoming.starts);
    }else if(!startsMap[incoming.key]){
      startsMap[incoming.key] = Fcopy(DEFAULT_STARTS);
    }
    if(incoming.hit && !isNaN(incoming.hit.x) && !isNaN(incoming.hit.y)){
      setHitSaved(incoming.key, incoming.hit);
    }
  });

  // Persist local overrides so reloading keeps the merged set consistent
  try{ saveStarts(); }catch(_e){}
  try{ saveHits(); }catch(_e){}

  return { added, updated };
}


/* ===== [A8.1] Description HUD helpers (mobile-friendly) ===== */
function updateDescriptionHudText(){
  const el = document.getElementById('descHud');
  if (!el || !currentSituation) return;
  const txt = currentSituation.desc || '';
  el.textContent = txt;
  el.title = txt || '';
}

document.addEventListener('click', (e)=>{
  if (!targetPanel || coachUnlocked) return;
  if (_phase2Ended) return; // never reshow after Phase 2 has finished

  const clickedRing = e.target.closest?.('.tgt');
  // Only re-show the instruction if we're truly in post-Phase-1, pre-Phase-2 state
  if (!clickedRing &&
      targetPanelBody &&
      targetPanelBody.classList.contains('show-instruction') === false &&
      typeof isPostRound === 'function' &&
      isPostRound()) {
    showTargetInstruction?.();
  }
});

// @diq:end [A8]
/// @diq:begin [A9] Situation lifecycle
function updateCurrentOptionLabel(){
  if (!sitSelect || !currentSituation) return;
  const opt = sitSelect.querySelector(`option[value="${currentSituation.key}"]`);
  if (opt) opt.textContent = currentSituation.title || currentSituation.key;
}

function syncSituationInputsFromCurrent(){
  if (!currentSituation) return;

  withInputMute(() => {
    if (newTitleInput) newTitleInput.value = currentSituation.title || currentSituation.key || '';
    if (newDescInput)  newDescInput.value  = currentSituation.desc  || '';
  });

  if (descHud)     descHud.textContent     = currentSituation.desc  || '';
const o = clampInt((currentSituation.outs ?? 0), 0, 2);
  setOuts(o, { quiet: true });

  // Coach tools: keep Play Sequence + notes inputs in sync with the selected situation
  if (seqNoteInput) seqNoteInput.value = (typeof currentSituation.seqNote === 'string') ? currentSituation.seqNote : '';
  if (typeof renderSeqBuilder === 'function') renderSeqBuilder();
}

function startsToTargets(starts, tol=DEFAULT_TOL){
  const out={}; POS_IDS.forEach(id=>{ const p=starts[id]; if(p) out[id]={ x:Math.round(p.x), y:Math.round(p.y), tol:Number(tol)||DEFAULT_TOL }; });
  return out;
}

// Generates a unique, title-independent key. Keys never change when you edit titles.
let __NEW_KEY_SEQ = 0;
function genUniqueKey(_title){
  const has = key => (SITUATIONS || []).some(s => s.key === key);
  let key;
  do {
    // S-<base36 timestamp>-<base36 counter>, all uppercase for consistency
    key = `S-${Date.now().toString(36)}-${(__NEW_KEY_SEQ++).toString(36)}`.toUpperCase();
  } while (has(key));
  return key;
}

function nextNewSituationTitle(){
  const base = 'New Situation';

  // Collect numbers from titles that match:
  // "New Situation"  -> 1
  // "New Situation N" -> N
  const nums = (SITUATIONS || [])
    .map(s => String(s.title || ''))
    .map(t => {
      const m = t.match(/^New Situation(?: (\d+))?$/);
      return m ? Number(m[1] || 1) : null;
    })
    .filter(n => n != null);

  if (nums.length === 0) return base;

  const next = Math.max(...nums) + 1;
  return `${base} ${next}`;
}

function makeBlankSituation(){
  const title = nextNewSituationTitle();            // UI label only; can be edited later
  const desc  = '';
  const key   = genUniqueKey(title);                // Stable key (not tied to title)

  const outsInit = outsSelSituation
    ? clampInt(outsSelSituation.value, 0, 2)
    : clampInt(currentSituation?.outs ?? 0, 0, 2);

  const runnersInit = getRunnersFromCheckboxes();

  return {
    key,
    title,
    desc,
    starts: Fcopy(DEFAULT_STARTS),
    targets: (() => {
      const t = {};
      POS_IDS.forEach(id => { const p = DEFAULT_STARTS[id]; if (p) t[id] = { x:p.x, y:p.y, tol:DEFAULT_TOL }; });
      return t;
    })(),
    hit: { x:1500, y:900 },
    hitType: 'line',
    batterAdvance: 1,
    outs: outsInit,
    runnersOn: normalizeRunnersOn(runnersInit)
  };
}

function addNewSituation(){
  const s = makeBlankSituation();

  // Add to model + persist default starts for this key
  SITUATIONS.push(s);
  startsMap[s.key] = Fcopy(s.starts);
  saveStarts();

  // Rebuild the dropdown (includes the new option) and switch to it immediately
  populateSituations(s.key);
  setSituation(s.key);                 // currentSituation now points to the newly created situation
  if (sitSelect) sitSelect.value = s.key;

  // Seed inputs without triggering 'input' listeners
  withInputMute(() => {
    if (newTitleInput) newTitleInput.value = s.title || '';
    if (newDescInput)  newDescInput.value  = s.desc  || '';
  });

  // Put caret in Title for convenience
  setTimeout(() => { try { newTitleInput?.focus(); } catch{} }, 0);

  if (typeof updateDescriptionHudText === 'function') updateDescriptionHudText();

  if (situationMsg){
    situationMsg.textContent = 'New situation created.';
    setTimeout(() => situationMsg.textContent = '', 1400);
  }
}

function deleteCurrentSituation(){
  if (!currentSituation) return;
  const key = currentSituation.key;
  const idx = (SITUATIONS||[]).findIndex(s=>s.key===key);
  if (idx < 0) return;
  const ok = confirm(`Delete situation "${currentSituation.title||key}"? This cannot be undone.`);
  if (!ok) return;

  // Remove from arrays/maps + persist
  SITUATIONS.splice(idx,1);
  if (startsMap && startsMap[key]){ delete startsMap[key]; saveStarts(); }
  if (hitsMap && hitsMap[key]){ delete hitsMap[key]; saveHits(); }

  // Ensure at least one situation remains
  if (!SITUATIONS.length){
    const s = makeBlankSituation();
    SITUATIONS.push(s);
    startsMap[s.key] = Fcopy(s.starts||DEFAULT_STARTS);
    saveStarts();
  }
  try{ if(preSnap) sbPushUndo(preSnap); }catch(e){}

  // Pick next selection (prefer previous index)
  const nextIdx = Math.max(0, Math.min(idx, SITUATIONS.length - 1));
  const nextKey = SITUATIONS[nextIdx].key;

  // Rebuild UI
  populateSituations(nextKey);
  setSituation(nextKey);

  if (situationMsg){
    situationMsg.textContent = 'Situation deleted.';
    setTimeout(()=> situationMsg.textContent = '', 1400);
  }
}

function resetStartsToDefaults(){
  if (!currentSituation) return;
  const preSnap = (coachUnlocked ? sbSnapshot() : null);
  POS_IDS.forEach(id=>{
    const p = DEFAULT_STARTS[id];
    const rec = tokens.get(id);
    if (rec){ rec.pos = { x:p.x, y:p.y }; placeToken(id); }
  });
  currentSituation.starts = Fcopy(DEFAULT_STARTS);
  if (currentSituation.key){
    startsMap[currentSituation.key] = Fcopy(DEFAULT_STARTS);
    saveStarts();
  }
  try{ if(preSnap) sbPushUndo(preSnap); }catch(e){}
  if (situationMsg){
    situationMsg.textContent = 'Player starts reset to defaults.';
    setTimeout(()=> situationMsg.textContent = '', 1400);
  }
}
function pickRandomSituation(){
  if (!Array.isArray(SITUATIONS) || SITUATIONS.length === 0) return;
  const cur = sitSelect && sitSelect.value || (currentSituation && currentSituation.key);
  let keys = SITUATIONS.map(s=>s.key);
  if (cur && keys.length > 1) keys = keys.filter(k=>k !== cur);
  const key = keys[Math.floor(Math.random() * keys.length)];
  if (sitSelect) sitSelect.value = key;
  setSituation(key);
}

function populateSituations(selectedKey){
  const prev = sitSelect ? sitSelect.value : '';
  if (sitSelect) sitSelect.innerHTML = '';

  (SITUATIONS||[]).forEach(s=>{
    const o = document.createElement('option');
    o.value = s.key;
    o.textContent = s.title || s.key;
    sitSelect.appendChild(o);
  });

  const keyExists = k => (SITUATIONS||[]).some(s => s.key === k);
  const want =
    (selectedKey && keyExists(selectedKey)) ? selectedKey :
    (keyExists(prev) ? prev :
     (SITUATIONS[0] && SITUATIONS[0].key));

  if (want && sitSelect) sitSelect.value = want;
}




function setSituation(key){
  currentSituation = getSituationByKey(key) || SITUATIONS[0];
  if (!currentSituation) return;

  renderSeqBuilder();

  wipePhase2StateUI();
  stopTimer();
  _timerSecs = TIMER_START_SECS;
  updateTimerHud();

  // Any time we switch situations, selection mode should be off
  disableTargetSelection();
  hideTargetPanel();
  _allTargetsCorrect = false;
  _roundHasStarted = false;
  _phase2Ended = false;

  if (!tokens || tokens.size===0) buildTokens();
  resetBallAndRunnerForSituation();

  // Title + Description UI
  if (descHud)  descHud.textContent  = currentSituation.desc  || '';
const savedHit = getHitSaved(currentSituation.key); if (savedHit) currentSituation.hit = savedHit;

  // Tolerance dropdown
  tolTargetSel.innerHTML='';
  POS_IDS.forEach(id=>{
    const opt=document.createElement('option'); opt.value=id; opt.textContent=id;
    tolTargetSel.appendChild(opt);
  });

  // Move chips to starts
  POS_IDS.forEach(id=>{
    const t=tokens.get(id); if(!t) return;
    t.pos = Fcopy(getStartFor(currentSituation.key,id));
    placeToken(id);
  });

  // If this situation has no targets yet, seed them from the current chip starts
  if (!currentSituation.targets || Object.keys(currentSituation.targets).length === 0) {
    currentSituation.targets = startsToTargets(getOnscreenStarts(), DEFAULT_TOL);
  }

  // Targets & coach visibility
  buildTargets();
  if (!coachUnlocked) getAllRings().forEach(el=> el.style.display='none');

  // HUD / controls
  updateHud(0); gameActive=false; remainingTries=0;
  startBtn.disabled=false; resetBtn.disabled=true; checkBtn.disabled=true;
  setChipsLocked(!coachUnlocked);

  // Tolerance inputs
  const firstId=POS_IDS[0];
  tolTargetSel.value=firstId;
  syncTolInputsFromModel(firstId);

  // >>> sync the Notes textarea with the selected target <<<
  if (tolTargetSel){
    const id = tolTargetSel.value || POS_IDS[0];
    syncTolNotesFromModel(id);
  }

  // Hit + ball (single-ball model: no orange marker in coach mode)
  if (hitMarker){ hitMarker.remove(); hitMarker = null; }
  syncBallToHit();
  if (ballEl){
    ballEl.style.display = (coachUnlocked || gameActive) ? 'block' : 'none';
    ballEl.classList.toggle('locked', !coachUnlocked);
    ballEl.style.zIndex = '10';
  }

  // Hit meta
  if (typeof currentSituation.hitType==='string') hitTypeSel.value=currentSituation.hitType;
  else currentSituation.hitType = hitTypeSel.value || 'line';

  if (typeof currentSituation.batterAdvance==='number') {
    advanceSel.value = String(clampInt(currentSituation.batterAdvance,0,4));
  } else {
    advanceSel.value = String(mapHitTypeToAdvance(currentSituation.hitType));
    currentSituation.batterAdvance = clampInt(advanceSel.value,0,4);
  }

  // Outs and runners
  const outsInit=clampInt((currentSituation.outs ?? 0),0,2);
  setOuts(outsInit,{quiet:true});
  setRunnersOn(normalizeRunnersOn(currentSituation.runnersOn), {quiet:true});

  // Sync Coach Tool inputs
  syncSituationInputsFromCurrent();
  applyCoachVisibility();

  renderBaseRunners();
  scaleMarkers();
  updateRunnersHudFromLive();

  if (continueBtn) continueBtn.classList.add('hidden');
  endPhase2(false); // ensure phase state is cleared
  phase2ClearAllUI();

  if (seqInput){
    const seq = (currentSituation.playSeq || []).join(', ');
    withInputMute(()=> { seqInput.value = seq; });
  }

  // Reset Situation Builder history when switching situations
  try{ sbEnsureKey(); sbUpdateButtons(); }catch(e){}

  setHowToPhase('p1');

    // Initialize mode toggle + pitch recognition module
    DIQMode.initOnce();
    PR.initOnce();
    DIQMode.apply(DIQMode.getStored());
}

// @diq:end [A9]
/// @diq:begin [A10] Export helpers
function getOnscreenStarts(){ const out={}; POS_IDS.forEach(id=>{ const rec=tokens.get(id); if(rec&&rec.pos) out[id]={x:Math.round(rec.pos.x),y:Math.round(rec.pos.y)}; }); return out; }
function getRenderedTargets(){
  const out = {};
  getAllRings().forEach(el=>{
    const id   = el.dataset.id;
    const left = parseFloat(el.style.left), top = parseFloat(el.style.top);
    const native = cssToUnit(left, top);
    const modelT = currentSituation.targets?.[id];
    out[id] = {
      x: Math.round(native.x),
      y: Math.round(native.y),
      tol: Math.round(modelT?.tol ?? DEFAULT_TOL),
      notes: modelT?.notes || ''
    };
  });
  return out;
}


// --- Situation Builder Undo/Redo (chips + targets + tolerance + notes) ---
function sbSnapshot(){
  if(!currentSituation) return null;
  const key = currentSituation.key;
  const starts = getOnscreenStarts();
  const targets = {};
  const t = currentSituation.targets || {};
  Object.entries(t).forEach(([id,pt])=>{
    targets[id] = { x:Math.round(pt.x), y:Math.round(pt.y), tol:Number(pt.tol)||DEFAULT_TOL, notes: (typeof pt.notes==='string'?pt.notes:'') };
  });
  return {
    key,
    starts,
    targets,
    tolSel: (tolTargetSel && tolTargetSel.value) ? String(tolTargetSel.value) : null
  };
}
function sbSame(a,b){
  if(!a || !b) return false;
  if(a.key !== b.key) return false;
  for(const id of POS_IDS){
    const pa=a.starts?.[id], pb=b.starts?.[id];
    if(!pa || !pb) return false;
    if(Math.round(pa.x)!==Math.round(pb.x) || Math.round(pa.y)!==Math.round(pb.y)) return false;
  }
  for(const id of POS_IDS){
    const ta=a.targets?.[id], tb=b.targets?.[id];
    if(!ta || !tb) return false;
    if(Math.round(ta.x)!==Math.round(tb.x) || Math.round(ta.y)!==Math.round(tb.y)) return false;
    if(Math.round(Number(ta.tol)||0)!==Math.round(Number(tb.tol)||0)) return false;
    if(String(ta.notes||'')!==String(tb.notes||'')) return false;
  }
  return true;
}
function sbEnsureKey(){
  const key = currentSituation && currentSituation.key;
  if(!key) return;
  if(sbHistKey !== key){
    sbHistKey = key;
    sbUndoStack = [];
    sbRedoStack = [];
    _sbTolStartSnap = null;
    _sbNotesStartSnap = null;
    sbUpdateButtons();
  }
}
function sbUpdateButtons(){
  if(sbUndoBtn) sbUndoBtn.disabled = !(coachUnlocked && sbUndoStack.length);
  if(sbRedoBtn) sbRedoBtn.disabled = !(coachUnlocked && sbRedoStack.length);
}
function sbPushUndo(preSnap){
  if(!coachUnlocked) return;
  if(!currentSituation) return;
  sbEnsureKey();
  if(!preSnap || preSnap.key !== sbHistKey) return;
  const cur = sbSnapshot();
  if(!cur) return;
  if(sbSame(preSnap, cur)) return;
  sbUndoStack.push(preSnap);
  if(sbUndoStack.length > SB_HISTORY_MAX) sbUndoStack.shift();
  sbRedoStack = [];
  sbUpdateButtons();
}
function sbApplySnap(snap){
  if(!snap || !currentSituation) return;
  if(snap.key !== currentSituation.key) return;

  // Apply starts (chips)
  const starts = snap.starts || {};
  POS_IDS.forEach(id=>{
    const pt = starts[id];
    const rec = tokens.get(id);
    if(rec && pt){
      rec.pos = { x:pt.x, y:pt.y };
      placeToken(id);
    }
  });

  // Persist starts for this situation (coach edits only)
  try{
    if(currentSituation.key){
      startsMap[currentSituation.key] = Fcopy(getOnscreenStarts());
      saveStarts();
      currentSituation.starts = Fcopy(startsMap[currentSituation.key]);
    }
  }catch(e){}

  // Apply targets model (x,y,tol,notes)
  const nextTargets = {};
  POS_IDS.forEach(id=>{
    const pt = (snap.targets && snap.targets[id]) ? snap.targets[id] : null;
    const base = pt || startsToTargets(getOnscreenStarts(), DEFAULT_TOL)[id];
    nextTargets[id] = {
      x: Math.round(base.x),
      y: Math.round(base.y),
      tol: Number(base.tol)||DEFAULT_TOL,
      notes: String(base.notes||'')
    };
  });
  currentSituation.targets = nextTargets;

  // Rebuild rings and re-sync tolerance/notes UI
  buildTargets();
  if(!coachUnlocked) getAllRings().forEach(el=> el.style.display='none');

  const sel = snap.tolSel && POS_IDS.includes(snap.tolSel) ? snap.tolSel : (tolTargetSel?.value || POS_IDS[0]);
  if(tolTargetSel){
    tolTargetSel.value = sel;
    syncTolInputsFromModel(sel);
  }
  sbUpdateButtons();
}
function sbUndo(){
  if(!coachUnlocked) return;
  if(!currentSituation) return;
  sbEnsureKey();
  if(!sbUndoStack.length) return;
  const cur = sbSnapshot();
  const prev = sbUndoStack.pop();
  if(cur) sbRedoStack.push(cur);
  sbApplySnap(prev);
}
function sbRedo(){
  if(!coachUnlocked) return;
  if(!currentSituation) return;
  sbEnsureKey();
  if(!sbRedoStack.length) return;
  const cur = sbSnapshot();
  const next = sbRedoStack.pop();
  if(cur) sbUndoStack.push(cur);
  sbApplySnap(next);
}

function getHitForExport(sit){ return sit && sit.hit ? { x:Math.round(sit.hit.x), y:Math.round(sit.hit.y) } : undefined; }
function getStartsForExport(key){
  const src=(startsMap && startsMap[key]) ? startsMap[key] : DEFAULT_STARTS;
  const out={}; POS_IDS.forEach(id=>{ const p=src[id] || DEFAULT_STARTS[id]; out[id]={ x:Math.round(p.x), y:Math.round(p.y) }; });
  return out;
}
function composeSituationForExport(base, starts, targets, hit){
  const extra = { ...base };
  delete extra.starts;
  delete extra.targets;
  delete extra.hit;

  const payload = { ...extra, starts, targets };
  if (hit) payload.hit = hit;

  if (base.hitType) payload.hitType = base.hitType;
  if (typeof base.batterAdvance === 'number') {
    payload.batterAdvance = clampInt(base.batterAdvance, 0, 4);
  }

  if (Array.isArray(base.playSeq) && base.playSeq.length) {
    payload.playSeq = base.playSeq.slice();
  }
  if (typeof base.seqNote === 'string' && base.seqNote.trim()) {
    payload.seqNote = base.seqNote;
  }

  return payload;
}

function buildCurrentSituationExport(){
  const s=currentSituation || SITUATIONS[0]; if(!s) return '[]';
  const one=composeSituationForExport(s, getOnscreenStarts(), getRenderedTargets(), getHitForExport(s));
  return JSON.stringify([one],null,2);
}
function buildAllSituationsExport(){
  const arr=(SITUATIONS||[]).map(s=>{
    const isCurrent=currentSituation && (s.key===currentSituation.key);
    const starts=isCurrent?getOnscreenStarts():getStartsForExport(s.key);
    let targets=isCurrent?getRenderedTargets():{};
    if (!isCurrent){
      Object.entries(s.targets||{}).forEach(([id,pt])=>{
        targets[id] = {
          x: Math.round(pt.x),
          y: Math.round(pt.y),
          tol: Math.round(pt.tol || DEFAULT_TOL),
          notes: pt.notes || ''
        };
      });
    }
    const hit=getHitSaved(s.key) || getHitForExport(s);
    return composeSituationForExport(s,starts,targets,hit);
  });
  return JSON.stringify(arr,null,2);
}

function buildResultsExportPayload(){
  return {
    type: 'diamondiq_results_v1',
    exportedAt: new Date().toISOString(),
    playerId: getPlayerId(),
    results: RESULTS
  };
}
function buildResultsExportText(){
  return JSON.stringify(buildResultsExportPayload(), null, 2);
}
function downloadResults(){
  const text = buildResultsExportText();
  const blob = new Blob([text], {type: 'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `diamondiq_results_${getPlayerId()}.json`;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
}
async function copyResults(){
  const text = buildResultsExportText();
  await navigator.clipboard.writeText(text);
}

/* =========================
   Coach: Player Results Viewer (parse + render)
   ========================= */

function parsePlayerResultsPayload(rawText){
  const txt = String(rawText || '').trim();
  if(!txt) return { ok:false, error:'Paste a player results JSON first.' };

  let obj;
  try{
    obj = JSON.parse(txt);
  }catch(e){
    return { ok:false, error:'Invalid JSON. Make sure you copied the full exported JSON.', detail: String((e && e.message) || e) };
  }

  // Expected wrapper: { type:'diamondiq_results_v1', exportedAt, playerId, results:{log,bySituation} }
  if(obj && typeof obj === 'object' && !Array.isArray(obj)){
    if(obj.type && String(obj.type).indexOf('diamondiq_results') === 0 && obj.results && typeof obj.results === 'object'){
      return { ok:true, kind:'results', meta:{ type:obj.type, exportedAt:obj.exportedAt, playerId:obj.playerId }, results: obj.results, raw: obj };
    }
    if(obj.log && obj.bySituation){
      return { ok:true, kind:'results', meta:{}, results: obj, raw: obj };
    }
    if(obj.situations || obj.SITUATIONS){
      return { ok:false, error:'This looks like situations JSON (coach export), not player results JSON.' };
    }
  }

  if(Array.isArray(obj)){
    return { ok:false, error:'This looks like situations JSON (an array). Paste the player Results JSON instead.' };
  }

  return { ok:false, error:'Unrecognized JSON shape. Paste the player Results JSON exported from the Player panel.' };
}

function _escHtml(s){
  return String(s==null?'':s).replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch]));
}
function _fmtMs(ms){
  if(ms==null || !Number.isFinite(ms)) return '‚Äî';
  const sec = Math.round(ms/100)/10; // 0.1s
  return sec.toFixed(1)+'s';
}
function _fmtIso(ts){
  if(!ts) return '‚Äî';
  try{ return new Date(ts).toLocaleString(); }catch(e){ return String(ts); }
}

function renderPlayerResultsForCoach(outEl, parsed){
  if(!outEl) return;

  if(!parsed || !parsed.ok){
    const msg = _escHtml(parsed && parsed.error ? parsed.error : 'Unable to parse.');
    const detail = parsed && parsed.detail ? `<div class="hint" style="margin-top:6px">${_escHtml(parsed.detail)}</div>` : '';
    outEl.innerHTML = `<div class="card" style="border:1px solid #fecaca;background:#fff1f2;padding:10px;border-radius:12px">
      <div style="font-weight:900;color:#991b1b">Parse failed</div>
      <div style="color:#7f1d1d">${msg}</div>${detail}
    </div>`;
    return;
  }

  const meta = parsed.meta || {};
  const results = parsed.results || {};
  const log = Array.isArray(results.log) ? results.log : [];
  const by = (results.bySituation && typeof results.bySituation==='object') ? results.bySituation : {};

  const keys = Object.keys(by);
  keys.sort((a,b)=> String(a).localeCompare(String(b), undefined, {numeric:true, sensitivity:'base'}));

  const totalAttempts = log.length;
  const totalScore = log.reduce((sum,e)=> sum + (Number(e && e.scoreDelta)||0), 0);

  const playerId =
    meta.playerId ||
    results.playerId ||
    (log[0] && log[0].playerId) ||
    '‚Äî';

  const exportedAt =
    meta.exportedAt ? _fmtIso(meta.exportedAt) :
    (results.exportedAt ? _fmtIso(results.exportedAt) : '‚Äî');

  const header = `
    <div class="card" style="padding:12px;border-radius:14px">
      <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between">
        <div>
          <div style="font-weight:900">Player Results</div>
          <div class="hint" style="margin-top:2px">
            Player ID: <span class="mono">${_escHtml(playerId)}</span><br/>
            Exported: ${_escHtml(exportedAt)}
          </div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <span class="pill" style="background:#ecfeff;border:1px solid #a5f3fc;color:#155e75">Attempts: <b>${totalAttempts}</b></span>
          <span class="pill" style="background:#eef2ff;border:1px solid #c7d2fe;color:#3730a3">Score Œî: <b>${totalScore}</b></span>
        </div>
      </div>
    </div>`;

  const ptxt = (p) => {
    if(!p) return '‚Äî';
    const b = p.correct===true ? '‚úÖ' : (p.correct===false ? '‚ùå' : '‚Äî');
    const tries = (p.triesUsed!=null ? p.triesUsed : '‚Äî');
    return `${b} ‚Ä¢ ${_escHtml(tries)} ‚Ä¢ ${_escHtml(_fmtMs(p.timeMs))}`;
  };

  const tableRows = keys.map(k=>{
    const s = by[k] || {};
    const p1 = s.p1 || null;
    const p21 = s.p2_1 || null;
    const p22 = s.p2_2 || null;

    const last = s.lastTs ? _fmtIso(s.lastTs) : '‚Äî';
    const attempts = (s.attempts!=null ? s.attempts : 0);

    return `<tr>
      <td class="mono">${_escHtml(k)}</td>
      <td>${_escHtml(s.title||'')}</td>
      <td style="white-space:nowrap">${ptxt(p1)}</td>
      <td style="white-space:nowrap">${ptxt(p21)}</td>
      <td style="white-space:nowrap">${ptxt(p22)}</td>
      <td style="white-space:nowrap">${_escHtml(String(attempts))}</td>
      <td style="white-space:nowrap">${_escHtml(last)}</td>
    </tr>`;
  }).join('');

  const table = `
    <div class="card" style="padding:12px;border-radius:14px;margin-top:10px">
      <div style="font-weight:900;margin-bottom:8px">Summary by Situation</div>
      <div style="overflow:auto">
        <table class="tbl" style="min-width:920px">
          <thead>
            <tr>
              <th style="text-align:left">Key</th>
              <th style="text-align:left">Title</th>
              <th style="text-align:left">Phase 1</th>
              <th style="text-align:left">Phase 2 ‚Äì Seq</th>
              <th style="text-align:left">Phase 2 ‚Äì Stage 2</th>
              <th style="text-align:left">Attempts</th>
              <th style="text-align:left">Last</th>
            </tr>
          </thead>
          <tbody>${tableRows || `<tr><td colspan="11" class="hint">No situations found in this export.</td></tr>`}</tbody>
        </table>
      </div>
      <details style="margin-top:10px">
        <summary class="hint" style="cursor:pointer">Show raw attempt log (${totalAttempts})</summary>
        <div style="margin-top:8px;max-height:260px;overflow:auto;border:1px solid var(--rule);border-radius:12px;padding:10px;background:#fbfbfd">
          <pre class="mono" style="margin:0;white-space:pre-wrap">${_escHtml(JSON.stringify(log.slice().reverse(), null, 2))}</pre>
        </div>
      </details>
<div class="subsec-desc">Paste a Coach Review Code from a player email to view a clean report + playback (Phase 2 sequence).</div>

          <div class="mt-3 grid gap-2">
            <label class="label" for="coachReviewInput">Coach Review Code</label>
            <textarea id="coachReviewInput" class="textarea mono" rows="5" placeholder="DIQ1:..."></textarea>
            <div class="flex gap-2">
              <button id="coachReviewLoadBtn" class="btn btn-white">Load Review</button>
              <button id="coachReviewClearBtn" class="btn btn-white">Clear</button>
            </div>
          </div>

          <div id="coachReviewOutput" class="mt-3"></div>
          <div id="coachReviewPlayback" class="mt-3"></div>
        </div>
</div>`;

  outEl.innerHTML = header + table;
}

function download(filename,content){
  const blob=new Blob([content], {type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=filename;
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href),2000);
}

function safeSituationJsonFilename(titleOrKey){
  let base = String(titleOrKey || '').trim();
  if(!base) base = 'situation';
  // Remove characters illegal in Windows filenames and trim length
  base = base.replace(/[\\/:*?\"<>|]+/g,'').replace(/\s+/g,' ').trim();
  if(!base) base = 'situation';
  base = base.slice(0, 80);
  // Avoid double extension
  if(!/\.json$/i.test(base)) base += '.json';
  return base;
}

/// @diq:begin [A10.1] One-button refresh (saves Coach Tools + rebuilds UI)
function refreshSituationAll(){
  if (!currentSituation) return;

  // 1) Title / Description
  if (newTitleInput){
    const t = newTitleInput.value.trim();
    if (t) currentSituation.title = t;
  }
  if (newDescInput){
    currentSituation.desc = newDescInput.value.trim();
  }

  // 2) Outs (HUD + dropdown sync)
  if (outsSelSituation){
    setOuts(outsSelSituation.value, {quiet:true});
  } else {
    currentSituation.outs = clampInt(currentSituation.outs ?? 0, 0, 2);
  }

  // 3) Runners (model + HUD + markers)
  setRunnersOn(getRunnersFromCheckboxes(), {quiet:true});

  // 4) Starts: pull from chips and persist
  const starts = getOnscreenStarts();
  const prevTargets = currentSituation.targets || {};
  let targets = getRenderedTargets();
  if (!targets || Object.keys(targets).length === 0){
    targets = {};
    POS_IDS.forEach(id=>{
      const p = starts[id];
      if (p) targets[id] = { x:Math.round(p.x), y:Math.round(p.y), tol:DEFAULT_TOL, notes:(typeof (prevTargets[id]||{}).notes==='string' ? (prevTargets[id]||{}).notes : '') };
    });
  }
  currentSituation.targets = {};
  Object.entries(targets).forEach(([id,pt])=>{
    const prev = prevTargets[id] || {};
    const notes = (typeof pt.notes === 'string') ? pt.notes : ((typeof prev.notes === 'string') ? prev.notes : '');
    currentSituation.targets[id] = {
      x: Math.round(pt.x),
      y: Math.round(pt.y),
      tol: Number(pt.tol) || DEFAULT_TOL,
      notes
    };
  });

  // 6) Hit + meta (+ persist hit location only)
  ensureDefaultHit();
  currentSituation.hitType = (hitTypeSel && hitTypeSel.value) || currentSituation.hitType || 'line';
  currentSituation.batterAdvance = clampInt(
    (advanceSel && advanceSel.value) ?? currentSituation.batterAdvance ?? 1,
    0, 4
  );
  setHitSaved(currentSituation.key, currentSituation.hit);
  saveHits();

  // 7) Rebuild UI pieces to reflect the saved model
  populateSituations(currentSituation.key);

  if (descHud) descHud.textContent = currentSituation.desc || '';
if (typeof updateDescriptionHudText === 'function') updateDescriptionHudText();

  // Rebuild targets (applies new tolerance sizes), hit marker & ball
  buildTargets();
  placeHitMarker();
  syncBallToHit();
  renderBaseRunners();
  scaleMarkers();
  updateRunnersHudFromLive();

  // Keep tolerance inputs in sync with selected target
  if (tolTargetSel){
    const id = tolTargetSel.value || POS_IDS[0];
    if (id) syncTolInputsFromModel(id);
  }

  // 8) Toasty message
  if (situationMsg){
    situationMsg.textContent='Situation refreshed.';
    setTimeout(()=> situationMsg.textContent='', 1400);
  }

  if (seqInput){
    const parts = String(seqInput.value || '')
      .split(',')
      .map(s => s.toUpperCase().trim())
      .filter(s => POS_IDS.includes(s));
    currentSituation.playSeq = parts; // [] disables Phase 2
  }

  if (seqNoteInput){
    currentSituation.seqNote = String(seqNoteInput.value || '');
  }

}

// Use one canonical saver; keep alias for any internal callers.
const saveCurrentSituation = refreshSituationAll;

// @diq:end [A10]
/// @diq:begin [A11] Game flow
function checkPositions(){
  if (!coachUnlocked && !gameActive) return;

  const t = currentSituation?.targets || {};
  let correct = 0;

  // Before decrementing tries, determine if this is the last available try
  const isFinalTry = (!coachUnlocked && gameActive && remainingTries === 1);

  // Evaluate each position vs its target ring
  getAllRings().forEach(el => {
    const id = el.dataset.id;
    const target = t[id];
    if (!target) return;

    const cur = tokens.get(id)?.pos;
    const tol = Number(target.tol) || DEFAULT_TOL;

    const d = Math.hypot((cur?.x ?? 0) - target.x, (cur?.y ?? 0) - target.y);
    const isCorrect = d <= tol;

    el.classList.toggle('good', isCorrect);
    el.classList.toggle('bad', !isCorrect);
    el.classList.add('show-label');

    if (coachUnlocked) {
      // Coach sees all rings
      el.style.display = 'block';
    } else {
      // Players: show only correct rings until final try; on final try show all
      el.style.display = (isFinalTry || isCorrect) ? 'block' : 'none';
    }

    if (isCorrect) correct++;
  });

  // Update numeric score + badge color
  updateHud(correct);
  if (scoreBadge){
    const pct = correct / 9;
    const state = pct >= 2/3 ? 'green' : (pct >= 1/3 ? 'yellow' : 'red');
    setBadgeState(scoreBadge, state, 'score');
  }

  // Non-coach: handle tries, end-of-round, and Phase-2 handoff
  if (!coachUnlocked){
    const allCorrectNow = (correct === POS_IDS.length);
    _allTargetsCorrect = allCorrectNow;

    if (gameActive){
      // Consume a try after showing rings
      remainingTries = Math.max(0, remainingTries - 1);
      updateHud(correct);
    }

    const outOfTries = (remainingTries === 0);
    const shouldEndRound = allCorrectNow || outOfTries;

    if (shouldEndRound){
      // Stop timer and hide the Check button
      stopTimer();
      // Capture Phase 1 outcome for Coach Review / exports (tokens passed or failed)
      try{
        _phase1Summary = {
          ok: !!allCorrectNow,
          scoreCorrect: correct,
          scoreTotal: (Array.isArray(POS_IDS) ? POS_IDS.length : 9),
          triesUsed: (MAX_TRIES - remainingTries),
          elapsed: (typeof _timerSecs === 'number') ? Math.max(0, TIMER_START_SECS - _timerSecs) : null,
          ts: Date.now()
        };
      }catch(e){ _phase1Summary = null; }

      if (checkBtn) checkBtn.classList.add('hidden');

      // Lock chips; keep round open for inspection
      setChipsLocked(true);
      gameActive = false;

      // Allow clicking target rings to view notes (post-round)
      enableTargetSelection();

      // Show the instruction card once a round actually started
      if (_roundHasStarted){
        if (typeof showTargetInstruction === 'function') {
          showTargetInstruction();
        } else if (typeof showTargetPanel === 'function') {
          showTargetPanel();
        }
        try{ window.__diqUpdateSituationSubcardsVisibility && window.__diqUpdateSituationSubcardsVisibility(); }catch(e){}
      }

      // If a sequence exists, reveal Continue and switch How-to to Phase 2
      const hasSeq = (typeof getSeqForCurrent === 'function') && getSeqForCurrent().length > 0;

      if (_roundHasStarted && continueBtn){
        if (hasSeq) continueBtn.classList.remove('hidden');
        else        continueBtn.classList.add('hidden');
      }

      // Swap the How-to card contents to Phase 2 rules when applicable
      if (hasSeq && typeof setHowToPhase === 'function'){
        setHowToPhase('p2');
      }
    }
  }
}

function resetBallAndRunnerForSituation(){
  if (animReq){ cancelAnimationFrame(animReq); animReq=null; }
  if (ballSvg) ballSvg.innerHTML='';
  if (ballEl) syncBallToHit();
  if (runnerAnimId){ cancelAnimationFrame(runnerAnimId); runnerAnimId=null; }
  hideRunner();
}

function resetPlayers(){
  wipePhase2StateUI();
  _phase2Ended = false;
  stopTimer();
  _timerSecs = TIMER_START_SECS;
  updateTimerHud();

  if (continueBtn) continueBtn.classList.add('hidden');

  // existing reset logic
  allowSeqPanel = false;
  disableTargetSelection();
  hideTargetPanel();
  _allTargetsCorrect = false;
  _roundHasStarted = false;

  POS_IDS.forEach(id=>{
    const t=tokens.get(id);
    if(!t) return;
    t.pos=Fcopy(getStartFor(currentSituation.key,id));
    placeToken(id);
  });

  getAllRings().forEach(el=> el.style.display=coachUnlocked ? 'block' : 'none');
  updateHud(0);
  gameActive=false;
  remainingTries=0;

  // Re-enable Start / Reset buttons
  startBtn.disabled=false;
  resetBtn.disabled=true;

  // ‚¨ÖÔ∏è Make sure Check Positions is visible and reset to its initial state
  if (checkBtn){
    checkBtn.classList.remove('hidden');
    checkBtn.disabled = true;   // start disabled until "Start Situation" is pressed
  }

  setChipsLocked(!coachUnlocked);

  if (ballSvg) ballSvg.innerHTML='';
  if (ballEl) syncBallToHit();

  hideRunner();

  liveRunners = normalizeRunnersOn(currentSituation.runnersOn);
  renderBaseRunners();
  scaleMarkers();
  updateRunnersHudFromLive();

  setHowToPhase('p1');
}

// @diq:end [A11]
/// @diq:begin [A12] Init & events

const COACH_COLLAPSE_KEY = "diq_coachSubsecCollapsed_v1";

function _loadCoachCollapseMap(){
  try{ return JSON.parse(localStorage.getItem(COACH_COLLAPSE_KEY) || "{}") || {}; }catch(e){ return {}; }
}
function _saveCoachCollapseMap(map){
  try{ localStorage.setItem(COACH_COLLAPSE_KEY, JSON.stringify(map || {})); }catch(e){}
}

function initCoachToolsCollapsibles(){
  const card = document.getElementById("coachCard");
  if(!card) return;

  const map = _loadCoachCollapseMap();

  const subsecs = Array.from(card.querySelectorAll(".subsec"));
  subsecs.forEach(subsec=>{
    const already = (subsec.dataset.diqCollapsible === "1");

    const header = subsec.querySelector(":scope > .title") || subsec.querySelector(":scope > .sectionTitle");
    if(!header) return;

    // If it was already prepared in HTML, ensure body/chevron exist; otherwise prepare.
    if(already){
      subsec.classList.add("diq-collapsible");
      // Ensure chevron exists
      if(!header.querySelector(".diq-chevron")){
        const chev = document.createElement("span");
        chev.className = "diq-chevron";
        chev.textContent = "‚ñæ";
        header.appendChild(chev);
      }
      // Ensure body wrapper exists
      let body = subsec.querySelector(":scope > .diq-body");
      if(!body){
        body = document.createElement("div");
        body.className = "diq-body";
        const kids = Array.from(subsec.children);
        kids.forEach(el=>{ if(el!==header) body.appendChild(el); });
        subsec.appendChild(body);
      }
    } else {

    // Mark + add chevron
    subsec.dataset.diqCollapsible = "1";
    subsec.classList.add("diq-collapsible");

    // Chevron (visual)
    const chev = document.createElement("span");
    chev.className = "diq-chevron";
    chev.textContent = "‚ñæ";
    header.appendChild(chev);

    // Wrap remaining children into body
    const body = document.createElement("div");
    body.className = "diq-body";
    const kids = Array.from(subsec.children);
    kids.forEach(el=>{
      if(el === header) return;
      body.appendChild(el);
    });
    subsec.appendChild(body);
    }

    const key = subsec.id || (header.textContent || "").trim() || ("subsec_" + Math.random());
    const defaultCollapsed = (key !== "coachReviewSubsec"); // Coach Review open by default
    const collapsed = (key in map) ? !!map[key] : defaultCollapsed;
    if(collapsed) subsec.classList.add("diq-collapsed");

    if(subsec.dataset.diqClickWired !== "1"){
      subsec.dataset.diqClickWired = "1";
      header.addEventListener("click", ()=>{
      const now = !subsec.classList.contains("diq-collapsed");
      // now=true means expanded; store collapsed=false
      subsec.classList.toggle("diq-collapsed");
      map[key] = subsec.classList.contains("diq-collapsed");
      _saveCoachCollapseMap(map);
      });
    }
  });
}

function setAllCoachSubsecsCollapsed(collapsed){
  const card = document.getElementById("coachCard");
  if(!card) return;
  const map = _loadCoachCollapseMap();
  const subsecs = Array.from(card.querySelectorAll(".subsec.diq-collapsible"));
  subsecs.forEach(subsec=>{
    const header = subsec.querySelector(":scope > .title") || subsec.querySelector(":scope > .sectionTitle");
    const key = subsec.id || (header && header.textContent ? header.textContent.trim() : "");
    if(!key) return;
    if(collapsed) subsec.classList.add("diq-collapsed");
    else subsec.classList.remove("diq-collapsed");
    map[key] = !!collapsed;
  });
  _saveCoachCollapseMap(map);
}

/* @diq:begin [MODE-200] Fielding vs Pitch Recognition mode + embedded Pitch Recognition MVP */
const DIQ_MODE_KEY = "diq_app_mode_v1"; // "fielding" | "pitch"

const DIQMode = (function(){
  let inited = false;

  function els(){
    return {
      btnFielding: document.getElementById("btnModeFielding"),
      btnPitch: document.getElementById("btnModePitch"),
      drillCard: document.getElementById("drillCard"),
      pitchStage: document.getElementById("pitchPlayStage"),
      fieldingStage: document.getElementById("fieldingPlayStage"),
    };
  }

  function getStored(){
    const v = (localStorage.getItem(DIQ_MODE_KEY) || "").trim();
    return (v === "pitch") ? "pitch" : "fielding";
  }

  function setStored(mode){
    localStorage.setItem(DIQ_MODE_KEY, mode);
  }

  function apply(mode){
    const e = els();
    const pitch = (mode === "pitch");

    document.body.classList.toggle("mode-pitch", pitch);
    if(e.btnFielding) e.btnFielding.classList.toggle("active", !pitch);
    if(e.btnPitch) e.btnPitch.classList.toggle("active", pitch);

    // Explicit display toggles (in addition to CSS) so layout calculations are correct.
    if(e.drillCard){ const _loggedNow = (window.isPlayerLoggedInNow ? window.isPlayerLoggedInNow() : false); e.drillCard.classList.toggle("prLocked", pitch && !_loggedNow); e.drillCard.style.display = (pitch && _loggedNow) ? "block" : "none"; }
    if(e.pitchStage) e.pitchStage.style.display = pitch ? "grid" : "none";

    // If not logged in, show Pitch Recognition as locked (no drill controls)
    if(pitch){
      const logged = (window.isPlayerLoggedInNow ? window.isPlayerLoggedInNow() : false);
      const overlay = document.getElementById("prOverlayCard");
      if(overlay){
        overlay.innerHTML = logged
          ? `<div style="font-weight:900">Press Start Round</div><div class="subtle">A pitch will appear briefly, then vanish. Identify it fast.</div>`
          : `<div style="font-weight:900">Player login required</div><div class="subtle">Select your Team & Player in the Player card to start Pitch Recognition.</div>`;
      }
      // also disable answer buttons when locked
      const ans = document.getElementById("prAnsGrid");
      if(ans){
        ans.querySelectorAll("button").forEach(b=>{ b.disabled = !logged; b.classList.toggle("disabled", !logged); });
      }
      const bStart = document.getElementById("prBtnStart");
      const bRes = document.getElementById("prBtnResume");
      if(bStart) bStart.disabled = !logged;
      if(bRes) bRes.disabled = !logged;
    }

    if(e.fieldingStage) e.fieldingStage.style.display = pitch ? "none" : "block";

    // Fielding login gate (prevents using Fielding when not logged in)
    if(!pitch){
      const logged = (window.isPlayerLoggedInNow ? window.isPlayerLoggedInNow() : false);
      const gate = document.getElementById("fieldingLoginGate");
      if(gate) gate.style.display = logged ? "none" : "grid";
      const w = document.getElementById("wrap");
      if(w) w.classList.toggle("lockedNoLogin", !logged);
    }


    // When switching into pitch mode, ensure canvas sizes correctly.
    if(pitch && PR && PR.ui && typeof PR.ui.resizeCanvas === "function"){
      requestAnimationFrame(()=>PR.ui.resizeCanvas());
    }
  }

  function initOnce(){
    if(inited) return;
    inited = true;
    const e = els();
    if(e.btnFielding){
      e.btnFielding.addEventListener("click", ()=>{
        setStored("fielding");
        apply("fielding");
      });
    }
    if(e.btnPitch){
      e.btnPitch.addEventListener("click", ()=>{
        setStored("pitch");
        apply("pitch");
      });
    }
  }

  return { initOnce, apply, getStored };
})();

/* Minimal embedded Pitch Recognition (Play + Drill only for now) */
const PR = (function(){
  const LS_KEY = "diq_pitchrec_embedded_v1";

  const PITCH_LABELS = {
    FB: "4S FB",
    CH: "Change",
    CB: "Curve",
    SL: "Slider",
    "2S": "2S FB",
    CT: "Cutter",
    SP: "Splitter",
    FK: "Fork",
    SV: "Slurve",
    CCH:"Circle CH",
  };

  const DEFAULT = {
    pitch_sets: [
      { id:"set_fb_ch", name:"FB vs CH", pitches:["FB","CH"] },
      { id:"set_mix4", name:"Mix 4 (FB/CH/CB/SL)", pitches:["FB","CH","CB","SL"] },
    ],
    drills: [
      { id:"d_fb_ch", name:"FB vs CH", pitch_set_id:"set_fb_ch",
        defaults:{ rounds:20, show_ms:1400, lock_ms:300, inter_ms:650 }
      },
      { id:"d_mix4", name:"Mix 4", pitch_set_id:"set_mix4",
        defaults:{ rounds:25, show_ms:1300, lock_ms:300, inter_ms:650 }
      },
    ],
    stimuli: [
      { type:"FB", recipe:{ trail:"straight", wiggle:0.04 } },
      { type:"CH", recipe:{ trail:"straight", wiggle:0.06, speed:0.78 } },
      { type:"CB", recipe:{ trail:"curve",   wiggle:0.05, speed:0.72 } },
      { type:"SL", recipe:{ trail:"slider",  wiggle:0.06, speed:0.86 } },
    ]
  };

  const state = {
    drill_id: "d_fb_ch",
    cfg: { rounds:20, show_ms:1400, lock_ms:300, inter_ms:650 },
    round: null
  };

  const ui = {};

  function load(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return JSON.parse(JSON.stringify(DEFAULT));
      const obj = JSON.parse(raw);
      if(!obj || !obj.drills || !obj.pitch_sets || !obj.stimuli) return JSON.parse(JSON.stringify(DEFAULT));
      return obj;
    }catch(e){
      return JSON.parse(JSON.stringify(DEFAULT));
    }
  }
  let data = load();

  async function loadRemoteData(){
    // Prefer external JSON so drills/pitch sets can be edited without touching index.html
    try{
      const res = await fetch("pitch-recognition.json", { cache: "no-store" });
      if(!res.ok) throw new Error("HTTP "+res.status);
      const obj = await res.json();
      if(obj && obj.drills && obj.pitch_sets && obj.stimuli){
        data = obj;
        try{ localStorage.setItem(LS_KEY, JSON.stringify(obj)); }catch(e){}
        // refresh UI if already bound
        if(ui.drillSel){
          refreshDrills();
          applyDrillDefaults();
          refreshAll();
        }
      }
    }catch(e){
      // fallback: localStorage or DEFAULT already loaded
    }
  }

  loadRemoteData();

  function saveState(){
    try{
      localStorage.setItem(LS_KEY+"_state", JSON.stringify({
        drill_id: state.drill_id,
        cfg: state.cfg,
        round: state.round ? {
          active: !!state.round.active,
          idx: state.round.idx,
          answered: state.round.answered,
          correct: state.round.correct,
          rts: state.round.rts,
          current: state.round.current,
          awaiting: !!state.round.awaiting,
          best_streak: state.round.best_streak,
          streak: state.round.streak
        } : null
      }));
    }catch(e){}
  }
  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY+"_state");
      if(!raw) return;
      const s = JSON.parse(raw);
      if(!s) return;
      state.drill_id = s.drill_id || state.drill_id;
      state.cfg = s.cfg || state.cfg;
      state.round = s.round || null;
    }catch(e){}
  }

  function byId(list,id){ return (list||[]).find(x=>x.id===id) || null; }
  function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
  function fmtPct(x){ return (x==null || Number.isNaN(x)) ? "‚Äî" : Math.round(x*100)+"%"; }
  function fmtMs(x){ return (x==null || Number.isNaN(x)) ? "‚Äî" : Math.round(x)+"ms"; }
  function avg(arr){ return arr.length ? (arr.reduce((a,b)=>a+b,0)/arr.length) : null; }

  function currentPlayerOk(){
    try{
      return !!(typeof getCurrentPlayerFromMeta === "function" && getCurrentPlayerFromMeta());
    }catch(e){ return false; }
  }

  function bindUI(){
    ui.drillSel = document.getElementById("prDrillSel");
    ui.roundsInp = document.getElementById("prRoundsInp");
    ui.showMsInp = document.getElementById("prShowMsInp");
    ui.lockMsInp = document.getElementById("prLockMsInp");
    ui.interMsInp = document.getElementById("prInterMsInp");
    ui.btnStart = document.getElementById("prBtnStart");
    ui.btnResume = document.getElementById("prBtnResume");
    ui.btnReset = document.getElementById("prBtnReset");

    ui.canvas = document.getElementById("prCanvas");
    ui.ansGrid = document.getElementById("prAnsGrid");
    ui.overlayCard = document.getElementById("prOverlayCard");
    ui.lastFeedback = document.getElementById("prLastFeedback");

    ui.hudScore = document.getElementById("prHudScore");
    ui.hudAcc = document.getElementById("prHudAcc");
    ui.hudRt = document.getElementById("prHudRt");
    ui.hudTimer = document.getElementById("prHudTimer");

    // Drill dropdown
    if(ui.drillSel){
      ui.drillSel.addEventListener("change", ()=>{
        state.drill_id = ui.drillSel.value;
        applyDrillDefaults();
        saveState();
        refreshAll();
      });
    }

    for(const [inp, key, min, max] of [
      [ui.roundsInp, "rounds", 5, 100],
      [ui.showMsInp, "show_ms", 80, 2500],
      [ui.lockMsInp, "lock_ms", 0, 1200],
      [ui.interMsInp, "inter_ms", 0, 2500],
    ]){
      if(!inp) continue;
      inp.addEventListener("change", ()=>{
        const v = clamp(parseInt(inp.value||"0",10), min, max);
        inp.value = String(v);
        state.cfg[key] = v;
        saveState();
      });
    }

    if(ui.btnStart) ui.btnStart.addEventListener("click", startRound);
    if(ui.btnResume) ui.btnResume.addEventListener("click", resumeRound);
    if(ui.btnReset) ui.btnReset.addEventListener("click", resetRound);

    setupCanvas();
  }

  function refreshDrills(){
    if(!ui.drillSel) return;
    ui.drillSel.innerHTML = "";
    for(const d of data.drills){
      const ps = byId(data.pitch_sets, d.pitch_set_id);
      const opt = document.createElement("option");
      opt.value = d.id;
      opt.textContent = `${d.name}${ps ? " ‚Ä¢ "+ps.pitches.map(p=>PITCH_LABELS[p]||p).join(" / ") : ""}`;
      ui.drillSel.appendChild(opt);
    }
    if(!state.drill_id) state.drill_id = data.drills[0]?.id || null;
    ui.drillSel.value = state.drill_id || "";
  }

  function applyDrillDefaults(){
    const d = byId(data.drills, state.drill_id);
    if(!d) return;
    state.cfg = {...d.defaults};
    if(ui.roundsInp) ui.roundsInp.value = String(state.cfg.rounds);
    if(ui.showMsInp) ui.showMsInp.value = String(state.cfg.show_ms);
    if(ui.lockMsInp) ui.lockMsInp.value = String(state.cfg.lock_ms);
    if(ui.interMsInp) ui.interMsInp.value = String(state.cfg.inter_ms);
  }

  function refreshHUD(){
    const r = state.round;
    if(!r || !r.active){
      if(ui.hudScore) ui.hudScore.textContent = "0 / 0";
      if(ui.hudAcc) ui.hudAcc.textContent = "Acc: ‚Äî";
      if(ui.hudRt) ui.hudRt.textContent = "Avg RT: ‚Äî";
      if(ui.hudTimer) ui.hudTimer.textContent = "Ready";
      if(ui.btnResume) ui.btnResume.disabled = true;
      return;
    }
    if(ui.btnResume) ui.btnResume.disabled = false;

    if(ui.hudScore) ui.hudScore.textContent = `${r.correct} / ${r.answered}`;
    const acc = r.answered ? (r.correct/r.answered) : null;
    if(ui.hudAcc) ui.hudAcc.textContent = `Acc: ${fmtPct(acc)}`;
    if(ui.hudRt) ui.hudRt.textContent = `Avg RT: ${r.rts.length ? fmtMs(avg(r.rts)) : "‚Äî"}`;
    if(ui.hudTimer) ui.hudTimer.textContent = r.awaiting ? "Answer" : "Wait";
  }

  function stopTimers(){
    const r = state.round;
    if(r && r._timer){
      clearTimeout(r._timer);
      r._timer = null;
    }
  }

  function startRound(){
    if(!currentPlayerOk()){
      toast("Select a Team and Player first.");
      return;
    }
    stopTimers();

    const d = byId(data.drills, state.drill_id);
    const ps = d ? byId(data.pitch_sets, d.pitch_set_id) : null;
    const allowed = ps?.pitches || ["FB","CH"];

    state.round = {
      active:true,
      idx: 0,
      answered:0,
      correct:0,
      rts:[],
      streak:0,
      best_streak:0,
      awaiting:false,
      current:null,
      allowed,
      cfg:{...state.cfg},
      _timer:null
    };

    if(ui.overlayCard){
      ui.overlayCard.innerHTML = '<div style="font-weight:900">Get Ready‚Ä¶</div><div class="subtle">Round starting.</div>';
      ui.overlayCard.classList.remove("hidden");
    }
    if(ui.lastFeedback) ui.lastFeedback.textContent = "‚Äî";

    renderAnswerButtons();
    refreshHUD();
    saveState();

    state.round._timer = setTimeout(()=>nextPitch(), 350);
  }

  function resumeRound(){
    if(!currentPlayerOk()){
      toast("Select a Team and Player first.");
      return;
    }
    const r = state.round;
    if(!(r && r.active)){
      toast("No active round to resume.");
      return;
    }
    if(ui.overlayCard){
      ui.overlayCard.classList.add("hidden");
    }
    renderAnswerButtons();
    refreshHUD();
    if(!r.awaiting) nextPitch();
  }

  function resetRound(){
    stopTimers();
    state.round = null;
    saveState();
    if(ui.overlayCard){
      ui.overlayCard.innerHTML = '<div style="font-weight:900">Press Start Round</div><div class="subtle">A pitch will appear briefly, then vanish. Identify it fast.</div>';
      ui.overlayCard.classList.remove("hidden");
    }
    if(ui.lastFeedback) ui.lastFeedback.textContent = "‚Äî";
    clearCanvas();
    renderAnswerButtons();
    refreshHUD();
  }

  function pickStim(type){
    const pool = data.stimuli.filter(s=>s.type===type);
    return pool.length ? pool[Math.floor(Math.random()*pool.length)] : data.stimuli[0];
  }

  function nextPitch(){
    const r = state.round;
    if(!r || !r.active) return;
    if(r.idx >= r.cfg.rounds){
      endRound();
      return;
    }

    r.awaiting = false;
    r.current = null;

    const type = r.allowed[Math.floor(Math.random()*r.allowed.length)];
    const stim = pickStim(type);

    r.current = { n: r.idx+1, type, recipe: {...(stim.recipe||{}), _ptype:type } };
    r.idx++;

    if(ui.overlayCard) ui.overlayCard.classList.add("hidden");

    showStimulus(r.current.recipe, r.cfg.show_ms, ()=>{
      r.awaiting = true;
      r.current.shown_at = performance.now();
      r.current.lock_until = r.current.shown_at + r.cfg.lock_ms;
      enableAnswers(true);
      refreshHUD();
      saveState();
    });

    renderAnswerButtons();
    refreshHUD();
    saveState();
  }

  function endRound(){
    stopTimers();
    const r = state.round;
    if(r) r.active = false;
    state.round = null;
    saveState();
    toast("Round ended.");
    if(ui.overlayCard){
      ui.overlayCard.innerHTML = '<div style="font-weight:900">Round complete</div><div class="subtle">Press Start Round to begin again.</div>';
      ui.overlayCard.classList.remove("hidden");
    }
    renderAnswerButtons();
    refreshHUD();
  }

  function enableAnswers(on){
    if(!ui.ansGrid) return;
    for(const b of ui.ansGrid.querySelectorAll(".prAns")){
      b.classList.toggle("disabled", !on);
      b.disabled = !on;
    }
  }

  function renderAnswerButtons(){
    if(!ui.ansGrid) return;

    const d = byId(data.drills, state.drill_id);
    const ps = d ? byId(data.pitch_sets, d.pitch_set_id) : null;
    const pitchTypes = ps?.pitches || ["FB","CH","CB","SL"];

    ui.ansGrid.innerHTML = "";
    for(const t of pitchTypes){
      const btn = document.createElement("button");
      btn.className = "prAns";
      btn.type = "button";
      btn.textContent = PITCH_LABELS[t] || t;
      btn.addEventListener("click", ()=>onAnswer(t));
      ui.ansGrid.appendChild(btn);
    }

    const active = !!(state.round && state.round.active && state.round.awaiting);
    enableAnswers(active);

    // columns
    ui.ansGrid.style.gridTemplateColumns =
      pitchTypes.length <= 2 ? "repeat(2,1fr)"
      : pitchTypes.length === 3 ? "repeat(3,1fr)"
      : "repeat(4,1fr)";
  }

  function onAnswer(type){
    const r = state.round;
    if(!r || !r.active || !r.awaiting) return;

    enableAnswers(false);

    const rt = (typeof r.current?.shown_at === "number") ? (performance.now() - r.current.shown_at) : null;
    const correct = (type === r.current.type);

    r.answered++;
    if(correct) r.correct++;
    if(typeof rt === "number") r.rts.push(rt);

    if(correct){
      r.streak++;
      r.best_streak = Math.max(r.best_streak, r.streak);
    }else{
      r.streak = 0;
    }

    if(ui.lastFeedback){
      const acc = r.answered ? (r.correct/r.answered) : null;
      ui.lastFeedback.innerHTML = correct
        ? `<span class="prBadge good">Correct</span> <span class="subtle">Actual: ${r.current.type} ‚Ä¢ RT ${fmtMs(rt)} ‚Ä¢ Acc ${fmtPct(acc)}</span>`
        : `<span class="prBadge bad">Miss</span> <span class="subtle">Actual: ${r.current.type} ‚Ä¢ You: ${type} ‚Ä¢ RT ${fmtMs(rt)} ‚Ä¢ Acc ${fmtPct(acc)}</span>`;
    }

    r.awaiting = false;
    refreshHUD();
    saveState();

    r._timer = setTimeout(()=>nextPitch(), r.cfg.inter_ms);
  }

  // ---- Canvas ----
  function getCanvasCSSSize(){
    const wrap = ui.canvas?.parentElement;
    if(!wrap) return {w:0,h:0};
    const rect = wrap.getBoundingClientRect();
    return { w: rect.width, h: rect.height };
  }

  function setupCanvas(){
    if(!ui.canvas) return;
    const c = ui.canvas;

    function resize(tries=0){
      const wrap = c.parentElement;
      if(!wrap) return;
      const rect = wrap.getBoundingClientRect();
      if(rect.width < 20 || rect.height < 20){
        if(tries < 20) setTimeout(()=>resize(tries+1), 60);
        return;
      }
      const dpr = window.devicePixelRatio || 1;
      c.width = Math.floor(rect.width * dpr);
      c.height = Math.floor(rect.height * dpr);
      const ctx = c.getContext("2d");
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);
      drawIdle();
    }

    ui.resizeCanvas = resize;
    window.addEventListener("resize", ()=>resize(0));
    resize(0);
  }

  function clearCanvas(){
    if(!ui.canvas) return;
    const ctx = ui.canvas.getContext("2d");
    const {w,h} = getCanvasCSSSize();
    ctx.clearRect(0,0,w,h);
    drawIdle(true);
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawIdle(skipClear=false){
    if(!ui.canvas) return;
    const ctx = ui.canvas.getContext("2d");
    const {w,h} = getCanvasCSSSize();
    if(!skipClear) ctx.clearRect(0,0,w,h);

    ctx.save();
    ctx.globalAlpha = 0.9;
    const zx = w*0.42, zy = h*0.30, zw = w*0.16, zh = h*0.36;
    ctx.strokeStyle = "rgba(100,116,139,.45)";
    ctx.lineWidth = 2;
    roundRect(ctx, zx, zy, zw, zh, 14);
    ctx.stroke();

    // plate
    const px = w*0.462, py = h*0.80, pw = w*0.076, ph = h*0.076;
    ctx.fillStyle = "rgba(15,23,42,.10)";
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(px+pw, py);
    ctx.lineTo(px+pw, py+ph*0.6);
    ctx.lineTo(px+pw*0.5, py+ph);
    ctx.lineTo(px, py+ph*0.6);
    ctx.closePath();
    ctx.fill();

    // mound dot
    ctx.fillStyle = "rgba(15,23,42,.10)";
    ctx.beginPath();
    ctx.arc(w*0.5, h*0.10, 6, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function showStimulus(recipe, showMs, done){
    if(!ui.canvas) return done && done();
    const ctx = ui.canvas.getContext("2d");
    const {w,h} = getCanvasCSSSize();

    const start = performance.now();
    const dur = Math.max(240, Math.round(showMs * 16.0)); // slow, training-friendly
    const smooth = (t)=> t*t*(3 - 2*t);

    const ptype = (recipe && recipe._ptype) ? recipe._ptype : "FB";
    const wiggle = ((recipe && recipe.wiggle) ? recipe.wiggle : 0);

    function posAt(u){
      const x0 = w*0.5, y0 = h*0.10;
      const x1 = w*0.5, y1 = h*0.78;
      let x = x0 + (x1-x0)*u;
      let y = y0 + (y1-y0)*u;

      // stylized movement
      const late = Math.pow(u, 4);
      if(ptype==="CB"){
        x += Math.sin(u*Math.PI)*(-0.10*w);
        y += (u*u)*(0.09*h);
      }else if(ptype==="SL"){
        x += late*(0.12*w);
        y += late*(0.05*h);
      }else if(ptype==="CH"){
        x += late*(-0.08*w);
        y += late*(0.07*h);
      }else{
        // FB
        y += (u*u)*(-0.03*h);
      }

      x += wiggle * Math.sin(u*10) * w*0.010;
      return {x,y};
    }

    function frame(tNow){
      const raw = clamp((tNow - start)/dur, 0, 1);
      const u = smooth(raw);

      ctx.clearRect(0,0,w,h);
      drawIdle(true);

      const steps = 42;
      const wStart = 1.6;
      const wEnd = 8.0;

      ctx.save();
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.shadowColor = "rgba(239,68,68,0.14)";
      ctx.shadowBlur = 12;

      // tail
      let prev = posAt(0);
      for(let i=1;i<=steps;i++){
        const uu = (i/steps) * u;
        const cur = posAt(uu);
        const g = smooth(uu);
        const wseg = wStart + (wEnd - wStart)*g;
        ctx.lineWidth = wseg;
        ctx.strokeStyle = "rgba(239,68,68,0.90)";
        ctx.beginPath();
        ctx.moveTo(prev.x, prev.y);
        ctx.lineTo(cur.x, cur.y);
        ctx.stroke();
        prev = cur;
      }
      ctx.restore();

      // ball
      const p = posAt(u);
      const rBall = 6 + 6*u;
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.98)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, rBall, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.75)";
      ctx.lineWidth = 2.2;
      ctx.stroke();
      ctx.restore();

      if(raw < 1){
        requestAnimationFrame(frame);
      }else{
        done && done();
      }
    }
    requestAnimationFrame(frame);
  }

  function refreshAll(){
    refreshDrills();
    if(!ui.roundsInp?.value) applyDrillDefaults();
    if(ui.roundsInp) ui.roundsInp.value = String(state.cfg.rounds);
    if(ui.showMsInp) ui.showMsInp.value = String(state.cfg.show_ms);
    if(ui.lockMsInp) ui.lockMsInp.value = String(state.cfg.lock_ms);
    if(ui.interMsInp) ui.interMsInp.value = String(state.cfg.inter_ms);

    // overlay based on stored active round
    if(state.round && state.round.active){
      if(ui.overlayCard){
        ui.overlayCard.innerHTML = '<div style="font-weight:900">Round paused</div><div class="subtle">Tap Resume to continue.</div>';
        ui.overlayCard.classList.remove("hidden");
      }
    }
    renderAnswerButtons();
    refreshHUD();
  }

  let inited = false;
  function initOnce(){
    if(inited) return;
    inited = true;
    bindUI();
    loadState();
    refreshAll();
  }

  return { initOnce, ui };
})();
/* @diq:end [MODE-200] Fielding vs Pitch Recognition mode + embedded Pitch Recognition MVP */

async function init(){
  ensurePlayerMeta();
  try{
    sizeOverlays();

    // Ensure header metrics/actions are grouped before first paint
    ensureHeaderGrouping();

    await loadSituationsFromJson();
      await loadTeamsFromJson();
      refreshTeamsUIAll();
    loadStarts(); loadHits();
    if (!Array.isArray(SITUATIONS) || SITUATIONS.length===0){
      SITUATIONS=[{ key:'S1', title:'Default', desc:'', starts:Fcopy(DEFAULT_STARTS), targets:{},
        hit:{x:1500,y:900}, hitType:'line', batterAdvance:1, outs:0, runnersOn:{first:false,second:false,third:false} }];
    }
    populateSituations();
    const firstKey = (sitSelect && sitSelect.value) || (SITUATIONS[0] && SITUATIONS[0].key);
    buildTokens(); updateChipScale(); setSituation(firstKey); setCoachMode(false);
    observeWrap(); scheduleLayout();

    updateDescriptionHudText();
    wireOnce();
  setCoachMode(coachUnlocked);
    // Coach Review deep-link: if a report code is in the URL, prompt for coach password immediately
    if(_pendingCoachReviewCode){
      if(coachUnlocked){
        try{ window._diqCoachReviewAutoload && window._diqCoachReviewAutoload(); }catch(e){}
      }else{
        try{
          if(typeof openPwModal === 'function') openPwModal();
          if(typeof pwMsg !== 'undefined' && pwMsg) pwMsg.textContent = 'Unlock Coach Tools to view the report.';
        }catch(e){}
      }
    }

// Teams UI elements are wired after JSON load; refresh dropdowns now
      refreshTeamsUIAll();
      // Mount Player panel into sidebar
      mountPlayerSidebar();
      // Apply pitch-recognition inspired layout (DOM moves only)
      applyPitchRecognitionLayout();
    setHowToPhase('p1');

  } catch (err){
    console.error('[Init] fatal error:', err && (err.stack||err.message||err));
    alert('There was an error starting the app. Open the console for details.');
  }
  ensurePlayerMeta();
}

function syncTolInputsFromModel(id){
  const t = getTargetFor(currentSituation.key, id);
  const tol = Number(t?.tol) || DEFAULT_TOL;
  if (tolNum)   tolNum.value   = String(tol);
  if (tolRange) tolRange.value = String(tol);
  // keep the ring sized live if it's on-screen
  const ring = getRingEl(id);
  if (ring){
    const d = tolToCssDiameter(tol, coachUnlocked);
    ring.style.width = d+'px';
    ring.style.height = d+'px';
  }
  // ALSO: sync notes
  syncTolNotesFromModel(id);
}

function syncTolNotesFromModel(id){
  const notes = getTargetNotes(currentSituation.key, id) || '';
  if (tolNotes) tolNotes.value = notes;
}

function setTolLive(id,tol){
  tol = clamp(Number(tol)||DEFAULT_TOL,5,400);
  let tgt = getTargetFor(currentSituation.key,id);
  if (!tgt){
    const pt = tokens.get(id)?.pos || getStartFor(currentSituation.key,id);
    setTargetFor(currentSituation.key,id,pt,tol);
    buildTargets();
  } else { tgt.tol = tol; }
  const ring = getRingEl(id);
  if (ring){
    const d=tolToCssDiameter(tol, coachUnlocked);
    ring.style.width=d+'px'; ring.style.height=d+'px';
    if (coachUnlocked) { ring.style.display='block'; ring.classList.add('show-label'); }
  }
  tolNum.value = tolRange.value = String(tol);
}

/* Kickoff */
if (img && img.complete) init();
else if (img){ img.addEventListener('load', init, { once:true }); window.addEventListener('load', ()=>{ if (!SITUATIONS.length) init(); }, { once:true }); }
/// @diq:end [A12] Init & events
else { window.addEventListener('load', init, { once:true }); }

// @diq:begin [A_ADMIN] Admin tools
  let adminUnlocked = false;

  const adminCollapseAllBtn = document.getElementById('adminCollapseAllBtn');
  const adminExpandAllBtn = document.getElementById('adminExpandAllBtn');

  const adminTeamsSubsec = document.getElementById('adminTeamsSubsec');
  const adminTeamsDownloadBtn = document.getElementById('adminTeamsDownloadBtn');
  const adminTeamsCopyBtn = document.getElementById('adminTeamsCopyBtn');
  const adminTeamsImportBtn = document.getElementById('adminTeamsImportBtn');
  const adminTeamsResetBtn = document.getElementById('adminTeamsResetBtn');

  const adminTeamSelect = document.getElementById('adminTeamSelect');
  const adminTeamName = document.getElementById('adminTeamName');
  const adminTeamEmail = document.getElementById('adminTeamEmail');
  const adminTeamAddBtn = document.getElementById('adminTeamAddBtn');
  const adminTeamUpdateBtn = document.getElementById('adminTeamUpdateBtn');
  const adminTeamRemoveBtn = document.getElementById('adminTeamRemoveBtn');

  const adminRosterSelect = document.getElementById('adminRosterSelect');
  const adminPlayerName = document.getElementById('adminPlayerName');
  const adminPlayerNumber = document.getElementById('adminPlayerNumber');
  const adminPlayerPass = document.getElementById('adminPlayerPass');
  const adminGenPassBtn = document.getElementById('adminGenPassBtn');
  const adminPlayerIdPreview = document.getElementById('adminPlayerIdPreview');
  const adminPlayerAddBtn = document.getElementById('adminPlayerAddBtn');
  const adminPlayerUpdateBtn = document.getElementById('adminPlayerUpdateBtn');
  const adminPlayerRemoveBtn = document.getElementById('adminPlayerRemoveBtn');

  function openAdminPwModal(){
    if (!adminPwModal) return;
    adminPwMsg.textContent = '';
    adminPwInput.value = '';
    adminPwModal.style.display = 'flex';
    setTimeout(()=>adminPwInput.focus(), 0);
  }
  function closeAdminPwModal(){
    if (!adminPwModal) return;
    adminPwModal.style.display = 'none';
  }

  function adminSetSubsecCollapsed(secEl, collapsed){
    if (!secEl) return;
    secEl.dataset.collapsed = collapsed ? '1' : '0';
    const body = secEl.querySelector('.adminSubsecBody');
    if (body) body.style.display = collapsed ? 'none' : '';
    const toggle = secEl.querySelector('.adminSubsecToggle');
    if (toggle) toggle.textContent = collapsed ? '‚ñ∏' : '‚ñæ';
  }

  function adminInitCollapsibles(){
    if (!adminCard) return;
    const secs = adminCard.querySelectorAll('.admin-subsec[data-admin-collapsible="1"]');
    secs.forEach(sec=>{
      const open = sec.dataset.adminOpen === '1';
      adminSetSubsecCollapsed(sec, !open);
      const t = sec.querySelector('.adminSubsecToggle');
      if (t){
        t.addEventListener('click', ()=>{
          const isCollapsed = sec.dataset.collapsed === '1';
          adminSetSubsecCollapsed(sec, !isCollapsed);
        });
      }
    });
  }

  function adminSetAllSubsecs(collapsed){
    if (!adminCard) return;
    const secs = adminCard.querySelectorAll('.admin-subsec[data-admin-collapsible="1"]');
    secs.forEach(sec=>adminSetSubsecCollapsed(sec, collapsed));
  }

  function adminSetMode(on){
    adminUnlocked = !!on;
    if (adminCard) adminCard.classList.toggle('hidden', !adminUnlocked);
    if (adminStatus) adminStatus.textContent = adminUnlocked ? 'unlocked' : 'locked';
    if (adminUnlocked){
      adminInitCollapsibles();
      adminRefreshAll();
    }
  }

  function tryUnlockAdmin(){
    if (!adminPwInput) return;
    if (adminPwInput.value === ADMIN_PASSWORD){
      closeAdminPwModal();
      adminSetMode(true);
    } else {
      adminPwMsg.textContent = 'Incorrect password.';
    }
  }

  if (adminPwCancel) adminPwCancel.addEventListener('click', closeAdminPwModal);
  if (adminPwOk) adminPwOk.addEventListener('click', tryUnlockAdmin);
  if (adminPwInput) adminPwInput.addEventListener('keydown', e=>{ if(e.key==='Enter') tryUnlockAdmin(); });

  if (adminBtn) adminBtn.addEventListener('click', ()=>{
    if (adminUnlocked){
      adminSetMode(false);
      if (adminCard) adminCard.classList.add('hidden');
    } else {
      openAdminPwModal();
    }
  });

  if (adminCollapseAllBtn) adminCollapseAllBtn.addEventListener('click', ()=>adminSetAllSubsecs(true));
  if (adminExpandAllBtn) adminExpandAllBtn.addEventListener('click', ()=>adminSetAllSubsecs(false));

  // --- Admin TEAMS (uses same underlying teams model as Coach TEAMS) ---
  function adminRefreshTeamSelect(){
    if (!adminTeamSelect) return;
    const curVal = adminTeamSelect.value;
    adminTeamSelect.innerHTML = '<option value="">‚Äî Select team ‚Äî</option>';
    const list = (TEAMS && Array.isArray(TEAMS.teams)) ? TEAMS.teams.slice() : [];
    list.sort((a,b)=>String(a.name||'').localeCompare(String(b.name||'')));
    list.forEach(t=>{
      const opt = document.createElement('option');
      opt.value = t.id || slugifyLoose(t.name||'');
      opt.textContent = t.name || t.id || '(unnamed)';
      adminTeamSelect.appendChild(opt);
    });
    if (curVal) adminTeamSelect.value = curVal;
  }

  function adminRefreshRosterSelect(){
    if (!adminRosterSelect) return;
    const teamId = adminTeamSelect ? adminTeamSelect.value : '';
    adminRosterSelect.innerHTML = '<option value="">‚Äî Select player ‚Äî</option>';
    const t = teamId ? findTeam(teamId) : null;
    if (!t) return;

    (t.roster || []).forEach(p=>{
      const o = document.createElement('option');
      const pid = (p && p.playerId) ? String(p.playerId) : slugifyLoose(`${(t && t.id) ? t.id : teamId}-${p && p.number ? p.number : ''}-${p && p.name ? p.name : ''}`);
      o.value = pid;
      o.textContent = `${p.number ? "#"+p.number+" " : ""}${p.name||'(no name)'}`;
      adminRosterSelect.appendChild(o);
    });
  }

  function adminSetTeamFieldsFromSelection(){
    if (!adminTeamSelect) return;
    const teamId = adminTeamSelect.value;
    const t = teamId ? findTeam(teamId) : null;
    if (adminTeamName) adminTeamName.value = t ? (t.name||'') : '';
    if (adminTeamEmail) adminTeamEmail.value = t ? (t.coachEmail||'') : '';

    const hasTeam = !!teamId;
    if (adminTeamUpdateBtn) adminTeamUpdateBtn.disabled = !hasTeam;
    if (adminTeamRemoveBtn) adminTeamRemoveBtn.disabled = !hasTeam;

    // enable/disable roster controls based on team selection
    const rosterEnabled = !!t;
    if (adminRosterSelect) adminRosterSelect.disabled = !rosterEnabled;
    if (adminPlayerName) adminPlayerName.disabled = !rosterEnabled;
    if (adminPlayerNumber) adminPlayerNumber.disabled = !rosterEnabled;
    if (adminPlayerPass) adminPlayerPass.disabled = !rosterEnabled;
    if (adminGenPassBtn) adminGenPassBtn.disabled = !rosterEnabled;
    if (adminPlayerAddBtn) adminPlayerAddBtn.disabled = !rosterEnabled;
    if (adminPlayerUpdateBtn) adminPlayerUpdateBtn.disabled = !rosterEnabled;
    if (adminPlayerRemoveBtn) adminPlayerRemoveBtn.disabled = !rosterEnabled;

    adminRefreshRosterSelect();
    if (adminRosterSelect) adminRosterSelect.value = '';
    adminSetPlayerFieldsFromSelection();
  }

  function adminSetPlayerFieldsFromSelection(){
    if (!adminRosterSelect || !adminTeamSelect) return;
    const teamId = adminTeamSelect.value;
    const t = teamId ? findTeam(teamId) : null;
    const pid = adminRosterSelect.value;
    const p = (t && pid) ? findPlayer(teamId, pid) : null;

    if (adminPlayerName) adminPlayerName.value = p ? (p.name||'') : '';
    if (adminPlayerNumber) adminPlayerNumber.value = p ? (p.number!=null ? String(p.number) : '') : '';
    if (adminPlayerPass) adminPlayerPass.value = p ? (p.password||'') : '';

    const hasPlayer = !!p;
    if (adminPlayerUpdateBtn) adminPlayerUpdateBtn.disabled = !hasPlayer;
    if (adminPlayerRemoveBtn) adminPlayerRemoveBtn.disabled = !hasPlayer;

    adminUpdatePlayerIdPreview();
  }

  function adminUpdatePlayerIdPreview(){
    if (!adminPlayerIdPreview || !adminTeamSelect) return;
    const teamId = adminTeamSelect.value;
    const t = teamId ? findTeam(teamId) : null;
    if (!t){
      adminPlayerIdPreview.textContent = '';
      return;
    }
    const name = String(adminPlayerName ? adminPlayerName.value : '').trim();
    const num = String(adminPlayerNumber ? adminPlayerNumber.value : '').trim();
    const baseId = ''; // preview only
    const pid = (typeof buildPlayerIdForTeam === 'function')
      ? buildPlayerIdForTeam(t.name, name, num, baseId)
      : computeRosterPlayerId(t, { name, number:num });
    adminPlayerIdPreview.textContent = pid;
  }

  function adminRefreshAll(){
    adminRefreshTeamSelect();
    adminSetTeamFieldsFromSelection();
  }

  if (adminTeamSelect) adminTeamSelect.addEventListener('change', adminSetTeamFieldsFromSelection);
  if (adminRosterSelect) adminRosterSelect.addEventListener('change', adminSetPlayerFieldsFromSelection);
  if (adminPlayerName) adminPlayerName.addEventListener('input', adminUpdatePlayerIdPreview);
  if (adminPlayerNumber) adminPlayerNumber.addEventListener('input', adminUpdatePlayerIdPreview);

  if (adminGenPassBtn){
    adminGenPassBtn.addEventListener('click', ()=>{
      if (!adminPlayerPass) return;
      adminPlayerPass.value = genSimplePassword(6);
    });
  }

  if (adminTeamsDownloadBtn){
    adminTeamsDownloadBtn.addEventListener('click', ()=>{ downloadJson('teams.json', TEAMS); });
  }
  if (adminTeamsCopyBtn){
    adminTeamsCopyBtn.addEventListener('click', ()=>{
      const txt = JSON.stringify(TEAMS, null, 2);
      copyTextToClipboard(txt)
        .then(()=> alert('Teams JSON copied.'))
        .catch(()=> alert('Clipboard copy failed. Use Download teams.json instead.'));
    });
  }

  if (adminTeamsImportBtn){
    adminTeamsImportBtn.addEventListener('click', ()=>{
      const inp = document.createElement('input');
      inp.type = 'file';
      inp.accept = '.json,application/json';
      inp.style.display = 'none';
      document.body.appendChild(inp);
      inp.addEventListener('change', async ()=>{
        try{
          const f = inp.files && inp.files[0];
          if(!f) return;
          const txt = await f.text();
          const parsed = JSON.parse(txt);
          if (!parsed || !parsed.teams || !Array.isArray(parsed.teams)) throw new Error('Expected JSON with { teams: [...] }');
          TEAMS = normalizeTeamsData(parsed);
          saveTeamsToLocal();
          if (typeof refreshTeamsUIAll === 'function') refreshTeamsUIAll();
          adminRefreshAll();
          alert('Imported teams JSON.');
        }catch(err){
          alert('Import failed: ' + (err && err.message ? err.message : String(err)));
        } finally {
          try{ document.body.removeChild(inp); }catch(_e){}
        }
      }, { once:true });
      inp.click();
    });
  }

  if (adminTeamsResetBtn){
    adminTeamsResetBtn.addEventListener('click', async ()=>{
      if(!confirm('Clear locally saved teams (does not affect teams.json on disk)?')) return;
      try{ localStorage.removeItem(TEAMS_STORAGE_KEY); }catch(_e){}
      if (typeof loadTeamsFromJson === 'function'){
        try{ await loadTeamsFromJson(); }catch(_e){}
      }
      if (typeof refreshTeamsUIAll === 'function') refreshTeamsUIAll();
      adminRefreshAll();
      alert('Local teams cleared.');
    });
  }

  // Admin CSV (v3) import/export
  const adminTeamsCsvFile = document.getElementById('adminTeamsCsvFile');
  const adminTeamsCsvUploadBtn = document.getElementById('adminTeamsCsvUploadBtn');
  const adminTeamsCsvTemplateBtn = document.getElementById('adminTeamsCsvTemplateBtn');
  const adminTeamsCsvSelectedBtn = document.getElementById('adminTeamsCsvSelectedBtn');

  // Admin SITUATIONS import/merge
  const adminSituationsJsonFile = document.getElementById('adminSituationsJsonFile');
  const adminSituationsJsonUploadBtn = document.getElementById('adminSituationsJsonUploadBtn');
  const adminSituationsMsg = document.getElementById('adminSituationsMsg');


  if(adminTeamsCsvUploadBtn && adminTeamsCsvFile){
    adminTeamsCsvUploadBtn.addEventListener('click', ()=> adminTeamsCsvFile.click());
    adminTeamsCsvFile.addEventListener('change', ()=>{
      const f = adminTeamsCsvFile.files && adminTeamsCsvFile.files[0];
      if(!f) return;
      const reader = new FileReader();
      reader.onload = ()=>{
        try{
          const txt = String(reader.result || '');
          const res = importTeamsFromCsvText(txt);
          alert(`Imported. Teams upserted: ${res.teams||0}. Players upserted: ${res.players||0}. Removed teams: ${res.removedTeams||0}. Removed players: ${res.removedPlayers||0}.`);
        }catch(e){
          alert('Could not import CSV: ' + (e && e.message ? e.message : e));
        }finally{
          adminTeamsCsvFile.value = '';
        }
      };
      reader.onerror = ()=>{
        alert('Could not read file.');
        adminTeamsCsvFile.value = '';
      };
      reader.readAsText(f);
    });
  }

  if(adminTeamsCsvTemplateBtn){
    adminTeamsCsvTemplateBtn.addEventListener('click', ()=> downloadTeamsCsvTemplate());
  }

  if(adminTeamsCsvSelectedBtn){
    adminTeamsCsvSelectedBtn.addEventListener('click', ()=>{
      const teamId = adminTeamSelect ? String(adminTeamSelect.value||'') : '';
      if(!teamId) return alert('Select a team first.');
      const csv = downloadSelectedTeamCsvV3(teamId);
      if(!csv) return alert('Could not export selected team.');
      const safeTeam = (findTeam(teamId) && findTeam(teamId).name) ? findTeam(teamId).name : 'team';
      downloadText(`diamondiq_${slugify(safeTeam)}_v3.csv`, csv, 'text/csv');
    });
  }
  if(adminSituationsJsonUploadBtn && adminSituationsJsonFile){
    adminSituationsJsonUploadBtn.addEventListener('click', ()=> adminSituationsJsonFile.click());
    adminSituationsJsonFile.addEventListener('change', async ()=>{
      const files = adminSituationsJsonFile.files ? Array.from(adminSituationsJsonFile.files) : [];
      if(!files.length) return;

      let addedTotal = 0, updatedTotal = 0;
      try{
        for(const f of files){
          const txt = await f.text();
          const parsed = JSON.parse(txt);
          const res = mergeSituationsFromArray(parsed);
          addedTotal += res.added || 0;
          updatedTotal += res.updated || 0;
        }

        // Refresh snapshots + dropdown + currently selected situation
        snapshotSituationsOrig();
        const keepKey = (currentSituation && currentSituation.key) ? currentSituation.key : (SITUATIONS[0] && SITUATIONS[0].key);
        populateSituations(keepKey);
        if (keepKey) setSituation(keepKey);

        if(adminSituationsMsg){
          adminSituationsMsg.textContent = `Merged situations. Added: ${addedTotal}. Updated: ${updatedTotal}.`;
          setTimeout(()=>{ if(adminSituationsMsg) adminSituationsMsg.textContent=''; }, 4000);
        }else{
          alert(`Merged situations. Added: ${addedTotal}. Updated: ${updatedTotal}.`);
        }
      }catch(err){
        alert('Situations import failed: ' + (err && err.message ? err.message : String(err)));
      }finally{
        try{ adminSituationsJsonFile.value = ''; }catch(_e){}
      }
    });
  }



  if (adminTeamAddBtn){
    adminTeamAddBtn.addEventListener('click', ()=>{
      const t = upsertTeam(adminTeamName ? adminTeamName.value : '', adminTeamEmail ? adminTeamEmail.value : '');
      if (typeof refreshTeamsUIAll === 'function') refreshTeamsUIAll();
      adminRefreshAll();
      if (t && adminTeamSelect) adminTeamSelect.value = t.id;
      adminSetTeamFieldsFromSelection();
    });
  }

  if (adminTeamUpdateBtn){
    adminTeamUpdateBtn.addEventListener('click', ()=>{
      const teamId = adminTeamSelect ? adminTeamSelect.value : '';
      if(!teamId) return alert('Select a team to update.');
      const old = findTeam(teamId);
      if(!old) return;

      const newName = String(adminTeamName ? adminTeamName.value : '').trim();
      const newId = slugifyLoose(newName) || teamId;
      const newEmail = String(adminTeamEmail ? adminTeamEmail.value : '').trim();

      if(newId !== teamId){
        // migrate (match coach tools behavior)
        const migrated = { id: newId, name: newName, coachEmail: newEmail, roster: deepClone(old.roster || []) };
        migrated.roster.forEach(p=>{
          p.playerId = buildPlayerIdForTeam(migrated.name, p.name, p.number, p.baseId);
        });
        removeTeam(teamId);
        TEAMS.teams.push(migrated);
      }else{
        old.name = newName || old.name;
        old.coachEmail = newEmail;
        (old.roster||[]).forEach(p=>{
          p.playerId = buildPlayerIdForTeam(old.name, p.name, p.number, p.baseId);
        });
      }

      TEAMS.teams = TEAMS.teams.sort((a,b)=> (a.name||"").localeCompare(b.name||""));
      saveTeamsToLocal();
      if (typeof refreshTeamsUIAll === 'function') refreshTeamsUIAll();
      adminRefreshAll();
      if (adminTeamSelect) adminTeamSelect.value = newId;
      adminSetTeamFieldsFromSelection();
    });
  }

  if (adminTeamRemoveBtn){
    adminTeamRemoveBtn.addEventListener('click', ()=>{
      const teamId = adminTeamSelect ? adminTeamSelect.value : '';
      if(!teamId) return;
      if(!confirm('Remove this team and all players?')) return;
      removeTeam(teamId);
      if (typeof refreshTeamsUIAll === 'function') refreshTeamsUIAll();
      adminRefreshAll();
      if (adminTeamSelect) adminTeamSelect.value = '';
      adminSetTeamFieldsFromSelection();
    });
  }

  if (adminPlayerAddBtn){
    adminPlayerAddBtn.addEventListener('click', ()=>{
      const teamId = adminTeamSelect ? adminTeamSelect.value : '';
      if(!teamId) return alert('Select a team first.');
      const name = String(adminPlayerName ? adminPlayerName.value : '').trim();
      const num = String(adminPlayerNumber ? adminPlayerNumber.value : '').trim();
      const pass = String(adminPlayerPass ? adminPlayerPass.value : '').trim();
      if(!name) return alert('Player Name is required.');
      if(!num) return alert('Player Number is required.');

      const p = upsertPlayer(teamId, name, num, pass);
      if (typeof refreshTeamsUIAll === 'function') refreshTeamsUIAll();
      adminRefreshAll();
      adminRefreshRosterSelect();
      if (adminRosterSelect && p && p.playerId) adminRosterSelect.value = p.playerId;
      adminSetPlayerFieldsFromSelection();
    });
  }

  if (adminPlayerUpdateBtn){
    adminPlayerUpdateBtn.addEventListener('click', ()=>{
      const teamId = adminTeamSelect ? adminTeamSelect.value : '';
      if(!teamId) return;
      const t = findTeam(teamId);
      if(!t) return;
      const pid = adminRosterSelect ? adminRosterSelect.value : '';
      if(!pid) return alert('Select a player to update.');
      const p = findPlayer(teamId, pid);
      if(!p) return;

      p.name = String(adminPlayerName ? adminPlayerName.value : '').trim() || p.name;
      p.number = String(adminPlayerNumber ? adminPlayerNumber.value : '').trim() || p.number;
      p.password = String(adminPlayerPass ? adminPlayerPass.value : '').trim() || p.password;
      p.playerId = buildPlayerIdForTeam(t.name, p.name, p.number, p.baseId);
      saveTeamsToLocal();

      if (typeof refreshTeamsUIAll === 'function') refreshTeamsUIAll();
      adminRefreshAll();
      adminRefreshRosterSelect();
      if (adminRosterSelect) adminRosterSelect.value = p.playerId;
      adminSetPlayerFieldsFromSelection();
    });
  }

  if (adminPlayerRemoveBtn){
    adminPlayerRemoveBtn.addEventListener('click', ()=>{
      const teamId = adminTeamSelect ? adminTeamSelect.value : '';
      if(!teamId) return;
      const pid = adminRosterSelect ? adminRosterSelect.value : '';
      if(!pid) return;
      if(!confirm('Remove this player?')) return;
      removePlayer(teamId, pid);

      if (typeof refreshTeamsUIAll === 'function') refreshTeamsUIAll();
      adminRefreshAll();
      adminRefreshRosterSelect();
      if (adminRosterSelect) adminRosterSelect.value = '';
      adminSetPlayerFieldsFromSelection();
    });
  }

  // Initialize hidden state
  adminSetMode(false);
  // @diq:end [A_ADMIN] Admin tools


// @diq:begin [A_RESETSTARTS_DELEGATE] Reset Starts delegated click
// Robust to DOM moves / collapsible wrappers.
document.addEventListener('click', (e)=>{
  const btn = e.target && e.target.closest ? e.target.closest('#resetStartsBtn') : null;
  if(!btn) return;
  // Prefer existing handler if one is wired on the element.
  // If not, fall back to calling the same reset function used elsewhere.
  try{
    if(typeof resetPlayerStarts === 'function') { resetPlayerStarts(); return; }
    if(typeof resetStarts === 'function') { resetStarts(); return; }
    // last-resort: trigger click on the element (if a listener exists)
    btn.click();
  } catch(_err){
    console.error('[ResetStarts] failed', _err);
  }
});
// @diq:end [A_RESETSTARTS_DELEGATE] Reset Starts delegated click

</script>

<!-- Coach Review Modal (Option B) -->
<div id="coachReviewModal" class="diq-modal hidden" role="dialog" aria-modal="true" aria-label="Coach Review">
  <div class="diq-modal-backdrop"></div>
  <div class="diq-modal-panel">
    <div class="diq-modal-head">
      <div style="font-weight:900;">Coach Review</div>
      <button id="coachReviewModalClose" class="btn btn-ghost" type="button">Close</button>
    </div>
    <div id="coachReviewModalMeta" class="muted" style="margin-top:6px;"></div>
    <div id="coachReviewModalOutput" style="margin-top:10px;"></div>
    <div id="coachReviewModalPlayback" style="margin-top:10px;"></div>
  </div>
</div>

</body></html>
