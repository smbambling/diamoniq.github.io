<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Diamond IQ - Situational Baseball</title>
<style>
  :root{
    --bg:#f5f7fb;
    --card:#ffffff;
    --ink:#0f172a;
    --muted:#6b7280;
    --accent:#ff8a00;  /* line-drive path */
    --popup:#06b6d4;   /* popup path */
    --ground:#374151;  /* grounder path */
    --pill:#e7eefc;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif}
  header#topBar{
    position:sticky; top:0; z-index:1000;
    display:flex; flex-wrap:wrap; gap:8px; align-items:center;
    padding:12px 16px; background:#fff; border-bottom:1px solid #e5e7eb;
  }
  header h1{margin:0 12px 0 0; font-size:18px}
  select, button{
    border:1px solid #d1d5db; background:#fff; color:#111827; border-radius:8px;
    padding:8px 10px; font-weight:600; cursor:pointer;
  }
  button.primary{background:#2563eb;color:#fff;border-color:#1d4ed8}
  button.warn{background:#fee2e2;color:#991b1b;border-color:#fecaca}
  .pill{
    display:inline-block; padding:6px 10px; border-radius:999px;
    background:var(--pill); color:#1f2937; font-weight:700; border:1px solid #c7d2fe;
  }
  .score{ margin-left:auto; font-weight:700; }
  .app{
    display:grid; grid-template-columns: 1fr 360px; gap:16px;
    padding:16px; max-width:1400px; margin:0 auto;
  }
  .fieldCard, .sideCard{
    background:var(--card); border:1px solid #e5e7eb; border-radius:12px; padding:12px;
  }
  .sideCol{ display:flex; flex-direction:column; gap:12px; }

  /* Field & overlays */
  #wrap{ position:relative; width:100%; }
  #fieldImg{ display:block; width:100%; height:auto; border-radius:10px; }
  .overlay{ position:absolute; inset:0; pointer-events:none; }
  #targetsLayer{ z-index:20; }
  #tokens      { z-index:30; }
  #runnersLayer{ z-index:40; }
  #ballCanvas  { z-index:50; width:100%; height:100%; }

  /* Chips (players) */
  #tokens .chip{
    position:absolute; transform:translate(-50%,-50%);
    width:36px; height:36px; border-radius:50%;
    background:#0f172a; color:#fff; border:2px solid #fff;
    display:flex; align-items:center; justify-content:center;
    font-weight:800; font-size:12px; box-shadow:0 2px 6px rgba(0,0,0,.25);
    pointer-events:auto; user-select:none; touch-action:none;
  }
  /* Runners (badges on bases) */
  #runnersLayer .runner{
    position:absolute; transform:translate(-50%,-50%);
    width:26px; height:26px; border-radius:50%;
    background:#10b981; color:#fff; border:2px solid #fff;
    display:flex; align-items:center; justify-content:center;
    font-weight:800; font-size:12px; box-shadow:0 1px 4px rgba(0,0,0,.2);
  }

  /* How-to card scales on large screens */
  .howto{ font-size: clamp(14px, 0.45vw + 13px, 18px); line-height:1.6; }
  .howto strong{ display:block; font-size: clamp(15px, 0.5vw + 14px, 20px); margin-bottom:6px; }
  .howto ol{ margin:10px 0 0 1.25em; padding:0 clamp(4px, 0.6vw, 14px); }
  .howto li{ margin: clamp(6px, 0.6vw, 14px) 0; }

  @media (max-width: 1024px){
    .app{ grid-template-columns: 1fr; }
  }
</style>
</head>
<body>

<header id="topBar">
  <h1>Diamond IQ - Situational Baseball</h1>
  <select id="sitSelect" aria-label="Select situation"></select>
  <span id="outsBadge" class="pill" title="Outs in this situation">Outs: 0</span>
  <button id="playHitBtn">Play Hit</button>
  <button id="resetBtn" class="warn">Reset Situation</button>
  <button id="exportSituationsBtn" title="Download situations.json">Export Situations</button>
  <input id="importSituationsInput" type="file" accept="application/json" style="display:none">
  <button id="importSituationsBtn" title="Load situations.json from your computer">Import Situations</button>
  <div class="score" id="score">Score: 0/9 • Try 0/3</div>
</header>

<main class="app">
  <section class="fieldCard">
    <div id="wrap">
      <!-- Use your 3000x2487 px image file at repo root -->
      <img id="fieldImg" src="baseballfield.png" alt="Baseball Field" />
      <div id="targetsLayer" class="overlay"></div>
      <div id="tokens" class="overlay"></div>
      <div id="runnersLayer" class="overlay"></div>
      <canvas id="ballCanvas" class="overlay"></canvas>
    </div>
  </section>

  <aside class="sideCol">
    <div class="sideCard howto">
      <strong>How to play</strong>
      <ol>
        <li>Select a situation.</li>
        <li>Drag the 9 player chips to where they should move for that situation.</li>
        <li>Click <em>Play Hit</em> to see the ball path and baserunners advance.</li>
        <li>Click <em>Reset Situation</em> to try again (also unlocks Play Hit).</li>
      </ol>
    </div>

    <div class="sideCard">
      <strong>Situation Notes</strong>
      <div id="sitText" style="color:#334155; margin-top:6px">Pick a situation.</div>
    </div>
  </aside>
</main>

<script>
/* ================== CONSTANTS & DEFAULTS ================== */

/* Native image size (your field is 3000 x 2487) */
const IMG_W = 3000, IMG_H = 2487;

/* Base anchors (native px on the image) */
const BASES = {
  HP: {x: 1500, y: 2300},  // approximate; tweak if you’ve calibrated
  '1B':{x: 2350, y: 1700},
  '2B':{x: 1500, y: 1200},
  '3B':{x:  650, y: 1700}
};

/* Default starting chip positions (native px) */
const DEFAULT_STARTS = {
  'P':  {x:1500, y:1550},
  'C':  {x:1500, y:1850},
  '1B': {x:2350, y:1650},
  '2B': {x:1800, y:1200},
  'SS': {x:1200, y:1200},
  '3B': {x: 650, y:1650},
  'LF': {x: 600, y: 900},
  'CF': {x:1500, y: 700},
  'RF': {x:2400, y: 900}
};

/* Storage keys (per-situation player starts) */
const STORAGE_STARTS_V2 = 'BaseballIQ_StartsMap_v2';

/* ================== STATE ================== */
let SITUATIONS = [];                    // loaded from situations.json
let currentSituation = null;
let attemptCount = 0;
let MAX_TRIES = 3;

let tokensLayer = null, runnersLayer = null, ballCanvas = null;
let tokens = new Map();                 // id -> {el, pos:{x,y}}
let currentRunners = [];                // ['1B','2B', 'HP' (BR), ...]
let rafId = null, runnerRafId = null;
let playLocked = false;

let startsMap = {}; // { [key]: {P:{x,y}, ...} }

/* ================== DOM HOOKS ================== */
const sitSelect  = document.getElementById('sitSelect');
const scoreBox   = document.getElementById('score');
const outsBadge  = document.getElementById('outsBadge');
const playHitBtn = document.getElementById('playHitBtn');
const resetBtn   = document.getElementById('resetBtn');

/* ================== UTIL ================== */
const Fcopy = (o)=> JSON.parse(JSON.stringify(o));

function cssDims(){
  const wrap = document.getElementById('wrap');
  const r = wrap.getBoundingClientRect();
  return {w:r.width, h:r.height};
}
function unitToCss(native){
  const {w,h} = cssDims();
  return {
    left: native.x * (w/IMG_W),
    top:  native.y * (h/IMG_H)
  };
}
function cssToNative(cssX, cssY){
  const {w,h} = cssDims();
  return { x: cssX * (IMG_W/w), y: cssY * (IMG_H/h) };
}
function sizeOverlays(){
  const wrap = document.getElementById('wrap');
  const cv = document.getElementById('ballCanvas');
  if (!wrap || !cv) return;
  const r = wrap.getBoundingClientRect();
  cv.width  = Math.max(1, Math.round(r.width));
  cv.height = Math.max(1, Math.round(r.height));
}

/* ================== STARTS (per situation) ================== */
function ensureStartsKey(key){
  if (!startsMap[key]) startsMap[key] = Fcopy(DEFAULT_STARTS);
}
function getStartsForCurrent(){
  ensureStartsKey(currentSituation.key);
  return startsMap[currentSituation.key];
}
function loadStarts(){
  try{
    const raw = localStorage.getItem(STORAGE_STARTS_V2);
    if (raw){ startsMap = JSON.parse(raw)||{}; }
  }catch(e){ startsMap = {}; }
}
function saveStarts(){
  try{ localStorage.setItem(STORAGE_STARTS_V2, JSON.stringify(startsMap)); }catch(e){}
}

/* ================== TOKENS (players) ================== */
function placeToken(id){
  const rec = tokens.get(id); if (!rec) return;
  const css = unitToCss(rec.pos);
  rec.el.style.left = css.left + 'px';
  rec.el.style.top  = css.top  + 'px';
}
function makeDraggable(el, id){
  let dragging=false, start={x:0,y:0};
  el.addEventListener('pointerdown', (e)=>{
    e.preventDefault(); dragging=true; el.setPointerCapture(e.pointerId);
  });
  el.addEventListener('pointermove', (e)=>{
    if(!dragging) return;
    const wrap = document.getElementById('wrap');
    const r = wrap.getBoundingClientRect();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;
    const native = cssToNative(x,y);
    tokens.get(id).pos = native;
    placeToken(id);
  });
  const end=()=>{ dragging=false; };
  el.addEventListener('pointerup', end);
  el.addEventListener('pointercancel', end);
}
function buildTokens(){
  tokensLayer = document.getElementById('tokens');
  tokensLayer.innerHTML=''; tokens.clear();
  const S = getStartsForCurrent();
  ['P','C','1B','2B','SS','3B','LF','CF','RF'].forEach(id=>{
    const el=document.createElement('div');
    el.className='chip'; el.textContent=id;
    tokensLayer.appendChild(el);
    tokens.set(id,{el,pos:Fcopy(S[id])});
    placeToken(id);
    makeDraggable(el,id);
  });
}

/* ================== RUNNERS ================== */
function drawRunners(override){
  runnersLayer = document.getElementById('runnersLayer');
  runnersLayer.innerHTML='';
  const active = override ?? (currentRunners.length? currentRunners : (currentSituation.runners||[]));
  active.forEach(b=>{
    const pt = BASES[b]; if (!pt) return;
    const css = unitToCss(pt);
    const badge = document.createElement('div');
    badge.className='runner';
    badge.dataset.base = b;
    badge.style.left = css.left+'px';
    badge.style.top  = css.top +'px';
    badge.textContent = (b==='HP'?'BR': b==='1B'?'R1': b==='2B'?'R2': b==='3B'?'R3': b);
    runnersLayer.appendChild(badge);
  });
}

/* ================== PLAY HIT (ball + runners) ================== */
function clearBallCanvas(){
  const ctx=ballCanvas.getContext('2d'); ctx.clearRect(0,0,ballCanvas.width,ballCanvas.height);
}
function lerp(a,b,t){ return a+(b-a)*t; }
function quadBezier(p0,p1,p2,t){
  return {
    x: (1-t)*(1-t)*p0.x + 2*(1-t)*t*p1.x + t*t*p2.x,
    y: (1-t)*(1-t)*p0.y + 2*(1-t)*t*p1.y + t*t*p2.y
  };
}
function getLaunchPoint(){ return BASES.HP; }
function drawBallDot(ctx,x,y){
  ctx.beginPath();
  ctx.fillStyle = '#ffffff';  // WHITE ball
  ctx.arc(x,y,6,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=1; ctx.stroke();
}
function playHitAnimation(fromNative, toNative, type){
  cancelAnimationFrame(rafId);
  const ctx = ballCanvas.getContext('2d');
  ctx.clearRect(0,0,ballCanvas.width,ballCanvas.height);

  const fromCss = unitToCss(fromNative);
  const toCss   = unitToCss(toNative);
  const start={x:fromCss.left, y:fromCss.top};
  const end  ={x:toCss.left  , y:toCss.top};

  const duration = (type==='popup') ? 2200 : (type==='grounder'? 1800 : 1600);
  const t0 = performance.now();

  const mid={ x:(start.x+end.x)/2, y:(start.y+end.y)/2 };
  const rise = -Math.hypot(end.x-start.x, end.y-start.y)*0.25;
  const ctrl={ x:mid.x, y:mid.y+rise };

  const strokeForType=()=>{
    ctx.lineWidth=4; ctx.lineCap='round';
    if(type==='line'){ ctx.setLineDash([]); ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()||'#ff8a00'; }
    if(type==='popup'){ ctx.setLineDash([]); ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--popup').trim() ||'#06b6d4'; }
    if(type==='grounder'){ ctx.setLineDash([8,8]); ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--ground').trim()||'#374151'; }
  };

  const draw=(now)=>{
    const t = Math.min(1,(now - t0)/duration);
    ctx.clearRect(0,0,ballCanvas.width,ballCanvas.height);
    strokeForType();

    ctx.beginPath();
    if(type==='popup'){
      const steps=48;
      let first=true;
      for(let i=0;i<=Math.floor(steps*t);i++){
        const tt=i/steps;
        const p=quadBezier(start,ctrl,end,tt);
        if(first){ ctx.moveTo(p.x,p.y); first=false; } else ctx.lineTo(p.x,p.y);
      }
      ctx.stroke();
      const pb = quadBezier(start,ctrl,end,t);
      drawBallDot(ctx,pb.x,pb.y);
    }else{
      const px = lerp(start.x,end.x,t), py=lerp(start.y,end.y,t);
      ctx.moveTo(start.x,start.y); ctx.lineTo(px,py); ctx.stroke();
      drawBallDot(ctx,px,py);
    }

    if(t<1){ rafId=requestAnimationFrame(draw); }
    else{
      setTimeout(()=>{ // clear trail but leave ball at landing spot
        ctx.clearRect(0,0,ballCanvas.width,ballCanvas.height);
        drawBallDot(ctx,end.x,end.y);
      },80);
    }
  };
  rafId = requestAnimationFrame(draw);
}

/* ---- Runner profiles (type + depth) ---- */
function distFromHP(native){ const hp=BASES.HP; return Math.hypot(native.x-hp.x, native.y-hp.y); }
function depthTier(native){
  const d = distFromHP(native);
  if (d < 520) return 'shallow';
  if (d < 900) return 'medium';
  return 'deep';
}
function nextBase(base){
  if (base==='HP') return '1B';
  if (base==='1B') return '2B';
  if (base==='2B') return '3B';
  if (base==='3B') return 'HP';
  return base;
}
const RUNNER_PROFILES = {
  line:{ shallow:{R1:1,R2:1,R3:1}, medium:{R1:1,R2:1,R3:1}, deep:{R1:2,R2:2,R3:1} },
  popup:{ shallow:{R1:0,R2:0,R3:0}, medium:{R1:0,R2:0,R3:1}, deep:{R1:1,R2:1,R3:1} },
  grounder:{ shallow:{R1:1,R2:1,R3:1}, medium:{R1:1,R2:1,R3:1}, deep:{R1:2,R2:1,R3:1} }
};
function planRunnerAdvancesForCurrent(hit){
  const type=hit?.type||'line';
  const depth=depthTier(hit?.target||BASES['2B']);
  const prof=(RUNNER_PROFILES[type]||RUNNER_PROFILES.line)[depth];
  const idForBase=(b)=> (b==='1B'?'R1': b==='2B'?'R2': b==='3B'?'R3':'R?');
  const plan={};
  (currentRunners||[]).forEach(b=>{
    const id=idForBase(b); plan[b] = prof[id]??0;
  });
  // Always add batter-runner: HP -> 1B
  plan['HP'] = 1;
  return plan;
}
function animateRunnersAdvancePlan(plan, durationMs){
  // snapshot movers
  const movers = (currentRunners||[])
    .filter(b=>(plan[b]||0)>0)
    .map(b=>{
      const steps=plan[b];
      const from=BASES[b], mid=nextBase(b), to=steps>=2? nextBase(mid): mid;
      const fromCss=unitToCss(from), midCss=unitToCss(BASES[mid]), toCss=unitToCss(BASES[to]);
      return {base:b, steps, fromCss, midCss, toCss, mid, to};
    });
  if (!movers.length) return;

  const t0=performance.now(), total=Math.max(1,durationMs);
  const step=(now)=>{
    const t=Math.min(1,(now-t0)/total);
    movers.forEach(m=>{
      const el = document.querySelector(`.runner[data-base="${m.base}"]`); if(!el) return;
      let x,y;
      if (m.steps===1){
        x = lerp(m.fromCss.left, m.midCss.left, t);
        y = lerp(m.fromCss.top , m.midCss.top , t);
      }else{
        if (t<=0.5){
          const tt=t*2;
          x = lerp(m.fromCss.left, m.midCss.left, tt);
          y = lerp(m.fromCss.top , m.midCss.top , tt);
        }else{
          const tt=(t-0.5)*2;
          x = lerp(m.midCss.left, m.toCss.left, tt);
          y = lerp(m.midCss.top , m.toCss.top , tt);
        }
      }
      el.style.left=x+'px'; el.style.top=y+'px';
    });
    if (t<1){ runnerRafId=requestAnimationFrame(step); }
    else{
      currentRunners = (currentRunners||[]).map(b=>{
        const s=plan[b]||0; if (s===0) return b;
        if (s===1) return nextBase(b);
        return nextBase(nextBase(b));
      }).filter(b=>b!=='HP'); // scored removed
      drawRunners();
      runnerRafId = null;
    }
  };
  runnerRafId=requestAnimationFrame(step);
}

/* ================== UI: Play/Reset Locking ================== */
function lockPlayHit(){
  playLocked = true;
  playHitBtn.disabled = true; playHitBtn.title='Reset or change situation to play again';
}
function unlockPlayHit(){
  playLocked = false;
  playHitBtn.disabled = false; playHitBtn.title='Play Hit';
}

/* ================== ACTIONS ================== */
function resetSituation(){
  try{ cancelAnimationFrame(rafId); }catch(e){}
  try{ cancelAnimationFrame(runnerRafId); }catch(e){}
  rafId = runnerRafId = null;
  clearBallCanvas();

  // players back to per-situation starts
  const S=getStartsForCurrent();
  tokens.forEach((_,id)=>{ tokens.get(id).pos = Fcopy(S[id]); placeToken(id); });

  // runners back to situation defaults
  currentRunners = (currentSituation.runners||[]).slice();
  drawRunners();

  // score/tries text
  attemptCount=0;
  scoreBox.textContent = `Score: 0/9 • Try 0/${MAX_TRIES}`;

  unlockPlayHit();
}
function playCurrentHit(){
  if (playLocked) return;
  lockPlayHit();

  const hit = currentSituation?.hit || {type:'line', target:{x:IMG_W*0.55, y:IMG_H*0.65}};
  const from = getLaunchPoint();

  // add batter-runner if missing & draw before animation
  if (!currentRunners.includes('HP')) currentRunners = ['HP', ...currentRunners];
  drawRunners();

  const duration = (hit.type==='popup') ? 2200 : (hit.type==='grounder' ? 1800 : 1600);
  const plan = planRunnerAdvancesForCurrent(hit);
  animateRunnersAdvancePlan(plan, duration);
  playHitAnimation(from, hit.target, hit.type);
}

/* ================== SITUATION LOADING & SWITCH ================== */
async function loadSituationsFromJson(){
  try{
    const res = await fetch('./situations.json', {cache:'no-store'});
    if(!res.ok) throw new Error('HTTP '+res.status);
    const arr = await res.json();
    if(!Array.isArray(arr)) throw new Error('situations.json must be an array');
    SITUATIONS = arr;
  }catch(err){
    console.warn('[Situations] load failed:', err);
    if (!SITUATIONS.length){
      SITUATIONS = [{
        key:'S1', title:'Sample (fallback)', outs:0, runners:[],
        desc:'Fallback inline situation. Create or import situations.json.',
        targets:{}, tolerances:{}, hit:{type:'line', target:{x:IMG_W*0.55, y:IMG_H*0.65}}
      }];
    }
  }
}
function populateSelect(selectedKey){
  sitSelect.innerHTML='';
  SITUATIONS.forEach(s=>{
    const o=document.createElement('option');
    o.value=s.key; o.textContent=s.title||s.key;
    sitSelect.appendChild(o);
  });
  const key = selectedKey || (currentSituation && currentSituation.key) || (SITUATIONS[0] && SITUATIONS[0].key);
  if (key) sitSelect.value = key;
}
function setSituation(key, {fromUser=false} = {}){
  const next = SITUATIONS.find(s=>s.key===key) || SITUATIONS[0];
  if (!next) return;

  currentSituation = next;
  ensureStartsKey(next.key);

  attemptCount=0;
  currentRunners = (next.runners||[]).slice();

  if (sitSelect && sitSelect.value !== next.key) sitSelect.value = next.key;
  if (outsBadge) outsBadge.textContent = `Outs: ${Number.isFinite(next.outs)?Number(next.outs):0}`;
  const sitText = document.getElementById('sitText'); if (sitText) sitText.textContent = next.desc || next.title || '';
  if (scoreBox) scoreBox.textContent = `Score: 0/9 • Try 0/${MAX_TRIES}`;

  clearBallCanvas();
  buildTokens();
  drawRunners();

  unlockPlayHit();
}

/* ================== BOOT ================== */
function waitForFieldImage(){
  const img = document.getElementById('fieldImg');
  if (!img) return Promise.resolve();
  if (img.complete && img.naturalWidth>0) return Promise.resolve();
  return new Promise(res=>{
    img.addEventListener('load',res,{once:true});
    img.addEventListener('error',res,{once:true});
  });
}

async function boot(){
  ballCanvas = document.getElementById('ballCanvas');
  runnersLayer = document.getElementById('runnersLayer');
  tokensLayer = document.getElementById('tokens');

  await loadSituationsFromJson();
  populateSelect();

  await waitForFieldImage();
  sizeOverlays();

  loadStarts();

  // initial situation
  const key = (sitSelect && sitSelect.value) || (SITUATIONS[0] && SITUATIONS[0].key);
  setSituation(key);

  // wire UI
  sitSelect.addEventListener('change', e=> setSituation(e.target.value, {fromUser:true}));
  playHitBtn.addEventListener('click', playCurrentHit);
  resetBtn.addEventListener('click', resetSituation);

  // Export/Import
  document.getElementById('exportSituationsBtn').addEventListener('click', ()=>{
    try{
      const blob=new Blob([JSON.stringify(SITUATIONS,null,2)],{type:'application/json'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
      a.download='situations.json'; a.click(); URL.revokeObjectURL(a.href);
    }catch(e){ alert('Export failed: '+(e?.message||e)); }
  });
  document.getElementById('importSituationsBtn').addEventListener('click', ()=>{
    document.getElementById('importSituationsInput').click();
  });
  document.getElementById('importSituationsInput').addEventListener('change', e=>{
    const f=e.target.files?.[0]; if(!f) return;
    const reader=new FileReader();
    reader.onload=()=>{
      try{
        const arr=JSON.parse(reader.result);
        if(!Array.isArray(arr)) throw new Error('Expected top-level array');
        SITUATIONS=arr;
        populateSelect();
        setSituation(sitSelect.value || (arr[0]&&arr[0].key));
        alert('Situations loaded. Use Export to download and commit to GitHub.');
      }catch(err){ alert('Invalid situations.json: '+err.message); }
    };
    reader.readAsText(f); e.target.value='';
  });

  window.addEventListener('resize', sizeOverlays);
}

window.addEventListener('DOMContentLoaded', boot);
</script>

</body>
</html>
